<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Keith&#39;s Blog</title>
  <subtitle>不疯魔,不成活</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://madordie.github.io/"/>
  <updated>2017-09-14T03:48:49.000Z</updated>
  <id>https://madordie.github.io/</id>
  
  <author>
    <name>Keith</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>AppStore的折叠效果</title>
    <link href="https://madordie.github.io/appstore-truncate/"/>
    <id>https://madordie.github.io/appstore-truncate/</id>
    <published>2017-09-14T03:46:18.000Z</published>
    <updated>2017-09-14T03:48:49.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="UITextView-More"><a href="#UITextView-More" class="headerlink" title="UITextView-More"></a><a href="https://github.com/madordie/UITextView-More" target="_blank" rel="external">UITextView-More</a></h2><p>使用UITextKit 实现“更多”的折叠效果</p>
<p><img src="https://github.com/madordie/UITextView-More/blob/master/Untitled.gif?raw=true" alt="预览"></p>
<a id="more"></a>
<h2 id="主要代码"><a href="#主要代码" class="headerlink" title="主要代码"></a>主要代码</h2><h3 id="获取最后一行Rect"><a href="#获取最后一行Rect" class="headerlink" title="获取最后一行Rect"></a>获取最后一行Rect</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> lastRect = <span class="type">CGRect</span>.zero</div><div class="line">layoutManager.enumerateEnclosingRects(forGlyphRange: <span class="type">NSRange</span>(location: <span class="number">0</span>, length: textStorage.string.characters.<span class="built_in">count</span>), withinSelectedGlyphRange: <span class="type">NSRange</span>(location: <span class="type">NSNotFound</span>, length: <span class="number">0</span>), <span class="keyword">in</span>: textContainer, using: &#123; [<span class="keyword">weak</span> <span class="keyword">self</span>] (rect, isStop) <span class="keyword">in</span></div><div class="line"><span class="keyword">guard</span> <span class="keyword">let</span> _self = <span class="keyword">self</span> <span class="keyword">else</span> &#123; <span class="keyword">return</span> &#125;</div><div class="line"><span class="keyword">var</span> newRect = rect</div><div class="line">newRect.origin.y += _self.textContainerInset.top</div><div class="line">lastRect = newRect</div><div class="line">&#125;)</div><div class="line"><span class="built_in">print</span>(lastRect)</div></pre></td></tr></table></figure>
<h3 id="增加-exclusionPaths"><a href="#增加-exclusionPaths" class="headerlink" title="增加 exclusionPaths"></a>增加 <code>exclusionPaths</code></h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">textContainer.exclusionPaths = [<span class="type">UIBezierPath</span>.<span class="keyword">init</span>(rect: rect)]</div></pre></td></tr></table></figure>
<h2 id="备注"><a href="#备注" class="headerlink" title="备注"></a>备注</h2><ul>
<li><code>UITextView</code>默认携带左右边距，通过<code>UITextView.textContainer.lineFragmentPadding</code>获取</li>
<li><code>UITextView</code>默认携带上下左右边距(<code>UITextView.textContainerInset</code>)，其中左右和<code>lineFragmentPadding</code>相加</li>
<li>此处并没有对<a href="https://github.com/madordie/UITextView-More/blob/master/TruncateTextView.swift" target="_blank" rel="external">TruncateTextView</a>进行过多的设置，主要是因为继承在UITextView下，<a href="https://github.com/madordie/UITextView-More/blob/master/Untitled.gif" target="_blank" rel="external">GIF</a>中的这部分设置放在了<a href="https://github.com/madordie/UITextView-More/blob/master/Demo-AppStore-More/ViewController.swift" target="_blank" rel="external">ViewController.swift</a>中</li>
<li>此处使用的是<code>frame</code>，可以在<code>UIView.sizeToFit()</code>之后获取到<code>UIView</code>的<code>Size</code>。约束也大抵如此</li>
</ul>
<hr>
<ul>
<li>感谢<a href="https://github.com/lexiaoyao20" target="_blank" rel="external">乐逍遥</a>提供的例子，才找到了<code>open func truncatedGlyphRange(inLineFragmentForGlyphAt glyphIndex: Int) -&gt; NSRange</code>方法😂</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;UITextView-More&quot;&gt;&lt;a href=&quot;#UITextView-More&quot; class=&quot;headerlink&quot; title=&quot;UITextView-More&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://github.com/madordie/UITextView-More&quot;&gt;UITextView-More&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;使用UITextKit 实现“更多”的折叠效果&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://github.com/madordie/UITextView-More/blob/master/Untitled.gif?raw=true&quot; alt=&quot;预览&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="iOS" scheme="https://madordie.github.io/categories/iOS/"/>
    
    
      <category term="效果" scheme="https://madordie.github.io/tags/%E6%95%88%E6%9E%9C/"/>
    
  </entry>
  
  <entry>
    <title>iOS自动化-Jenkins环境搭建</title>
    <link href="https://madordie.github.io/ios-automation-jenkins-configuration/"/>
    <id>https://madordie.github.io/ios-automation-jenkins-configuration/</id>
    <published>2017-09-10T01:49:32.000Z</published>
    <updated>2017-09-14T03:55:50.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>忙着适配iOS11  还没更新呢….</p>
<p><a href="https://madordie.github.io/ios11-beta/">iOS11-beta</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css&quot;&gt;&lt;p&gt;忙着适配iOS11  还没更新呢….&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;htt
    
    </summary>
    
      <category term="iOS" scheme="https://madordie.github.io/categories/iOS/"/>
    
    
      <category term="构建" scheme="https://madordie.github.io/tags/%E6%9E%84%E5%BB%BA/"/>
    
      <category term="Jenkins" scheme="https://madordie.github.io/tags/Jenkins/"/>
    
  </entry>
  
  <entry>
    <title>iOS逆向-monkeydev工具</title>
    <link href="https://madordie.github.io/reverse-ios-monkeydev/"/>
    <id>https://madordie.github.io/reverse-ios-monkeydev/</id>
    <published>2017-08-14T03:05:57.000Z</published>
    <updated>2017-08-14T04:09:06.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><blockquote>
<p>MonkeyDev wiki<br>这是一个为越狱和非越狱开发人员准备的工具，主要包括四个模块:</p>
<p> Logos Tweak</p>
<p>使用theos提供的logify.pl工具将<em>.xm文件转成</em>.mm文件进行编译，集成了CydiaSubstrate，可以使用MSHookMessageEx和MSHookFunction来Hook OC函数和指定地址。</p>
<p>CaptainHook Tweak</p>
<p>使用CaptainHook提供的头文件进行OC 函数的Hook，以及属性的获取。</p>
<p>Command-line Tool</p>
<p>可以直接创建运行于越狱设备的命令行工具</p>
<p>MonkeyApp</p>
<p>这是自动给第三方应用集成Reveal、Cycript和注入dylib的模块，支持调试dylib和第三方应用，支持Pod给第三放应用集成SDK，只需要准备一个砸壳后的ipa或者app文件即可。</p>
</blockquote>
<a id="more"></a>
<hr>
<ul>
<li><a href="https://github.com/AloneMonkey/MonkeyDev/wiki" target="_blank" rel="external">MonkeyDev wiki</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;MonkeyDev wiki&lt;br&gt;这是一个为越狱和非越狱开发人员准备的工具，主要包括四个模块:&lt;/p&gt;
&lt;p&gt; Logos Tweak&lt;/p&gt;
&lt;p&gt;使用theos提供的logify.pl工具将&lt;em&gt;.xm文件转成&lt;/em&gt;.mm文件进行编译，集成了CydiaSubstrate，可以使用MSHookMessageEx和MSHookFunction来Hook OC函数和指定地址。&lt;/p&gt;
&lt;p&gt;CaptainHook Tweak&lt;/p&gt;
&lt;p&gt;使用CaptainHook提供的头文件进行OC 函数的Hook，以及属性的获取。&lt;/p&gt;
&lt;p&gt;Command-line Tool&lt;/p&gt;
&lt;p&gt;可以直接创建运行于越狱设备的命令行工具&lt;/p&gt;
&lt;p&gt;MonkeyApp&lt;/p&gt;
&lt;p&gt;这是自动给第三方应用集成Reveal、Cycript和注入dylib的模块，支持调试dylib和第三方应用，支持Pod给第三放应用集成SDK，只需要准备一个砸壳后的ipa或者app文件即可。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="iOS" scheme="https://madordie.github.io/categories/iOS/"/>
    
    
      <category term="逆向" scheme="https://madordie.github.io/tags/%E9%80%86%E5%90%91/"/>
    
  </entry>
  
  <entry>
    <title>iOS逆向-class-dump工具</title>
    <link href="https://madordie.github.io/reverse-ios-class-dump/"/>
    <id>https://madordie.github.io/reverse-ios-class-dump/</id>
    <published>2017-08-10T04:40:27.000Z</published>
    <updated>2017-08-14T02:04:06.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="安装class-dump"><a href="#安装class-dump" class="headerlink" title="安装class-dump"></a>安装class-dump</h2><p>去<a href="http://stevenygard.com/projects/class-dump/" target="_blank" rel="external">stevenygard.com</a>下载最新的包。</p>
<p>将包中的<code>class-dump</code>可执行文件复制到<code>/opt/class-dump</code>。(我的逆向相关工具均在这下面😂）</p>
<p>在<code>~/.base_profile</code>中添加<code>export PATH=/opt/class-dump:$PATH</code></p>
<p>运行<code>source ~/.base_profile</code></p>
<p>最后确认一下安装OK ：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ class-dump --v</div><div class="line">class-dump 3.5 (64 bit) compiled Nov 16 2013 12:22:33</div></pre></td></tr></table></figure>
<a id="more"></a>
<h2 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h2><p>使用一个记录一个吧～</p>
<h3 id="用来导出ipa-decrypted头文件"><a href="#用来导出ipa-decrypted头文件" class="headerlink" title="用来导出ipa/.decrypted头文件"></a>用来导出<code>ipa</code>/<code>.decrypted</code>头文件</h3><p>此处只能导出未加密的<code>ipa</code>，或者砸过壳的。<a href="https://madordie.github.io/reverse-ios-dump-decrypted/">具体砸壳过程传送门</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$ ls WeChat.decrypted</div><div class="line">WeChat.decrypted</div><div class="line">$ class-dump -H WeChat.decrypted -o ./Headers/</div><div class="line">$ ls Headers</div><div class="line">Headers</div></pre></td></tr></table></figure>
<p>即得头文件目录：<code>Headers</code></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;安装class-dump&quot;&gt;&lt;a href=&quot;#安装class-dump&quot; class=&quot;headerlink&quot; title=&quot;安装class-dump&quot;&gt;&lt;/a&gt;安装class-dump&lt;/h2&gt;&lt;p&gt;去&lt;a href=&quot;http://stevenygard.com/projects/class-dump/&quot;&gt;stevenygard.com&lt;/a&gt;下载最新的包。&lt;/p&gt;
&lt;p&gt;将包中的&lt;code&gt;class-dump&lt;/code&gt;可执行文件复制到&lt;code&gt;/opt/class-dump&lt;/code&gt;。(我的逆向相关工具均在这下面😂）&lt;/p&gt;
&lt;p&gt;在&lt;code&gt;~/.base_profile&lt;/code&gt;中添加&lt;code&gt;export PATH=/opt/class-dump:$PATH&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;运行&lt;code&gt;source ~/.base_profile&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;最后确认一下安装OK ：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;$ class-dump --v&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;class-dump 3.5 (64 bit) compiled Nov 16 2013 12:22:33&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="iOS" scheme="https://madordie.github.io/categories/iOS/"/>
    
    
      <category term="逆向" scheme="https://madordie.github.io/tags/%E9%80%86%E5%90%91/"/>
    
  </entry>
  
  <entry>
    <title>iOS逆向-砸壳(cycript/clutch)</title>
    <link href="https://madordie.github.io/reverse-ios-dump-decrypted/"/>
    <id>https://madordie.github.io/reverse-ios-dump-decrypted/</id>
    <published>2017-08-09T12:31:50.000Z</published>
    <updated>2017-08-14T02:04:17.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h1><ul>
<li>越狱设备</li>
</ul>
<p>目前有两种砸壳工具，并不肩并肩，一个不行就用另一个呗，俩都不行就Google吧～～</p>
<p>下面分别对<code>cycript</code>、<code>clutch</code>进行砸壳:</p>
<a id="more"></a>
<h1 id="使用cycript进行砸壳"><a href="#使用cycript进行砸壳" class="headerlink" title="使用cycript进行砸壳"></a>使用cycript进行砸壳</h1><h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><ul>
<li><code>Cydia</code>中搜索<code>cycript</code>并安装 </li>
</ul>
<h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><h3 id="制作并上传dumpdecrypted-dylib-（已经OK的可忽略"><a href="#制作并上传dumpdecrypted-dylib-（已经OK的可忽略" class="headerlink" title="制作并上传dumpdecrypted.dylib （已经OK的可忽略"></a>制作并上传<code>dumpdecrypted.dylib</code> （已经OK的可忽略</h3><h4 id="制作"><a href="#制作" class="headerlink" title="制作"></a>制作</h4><p>目前我制作目录暂时在<code>~/Desktop</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ git clone https://github.com/stefanesser/dumpdecrypted.git ~/Desktop</div><div class="line">$ cd ～／Desktop/dumpdecrypted</div><div class="line">$ make</div><div class="line">$ ls dumpdecrypted.dylib</div></pre></td></tr></table></figure>
<p>没什么错误的话，即得<code>dumpdecrypted.dylib</code>。</p>
<h4 id="上传"><a href="#上传" class="headerlink" title="上传"></a>上传</h4><p>将<code>dumpdecrypted.dylib</code>放在越狱设备的<code>/var/root/</code>下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$ ls dumpdecrypted.dylib</div><div class="line">$ scp dumpdecrypted.dylib root@10.12.14.16:/var/root/</div><div class="line">root@10.12.14.16&apos;s password:</div><div class="line">dumpdecrypted.dylib                           100%  193KB   3.0MB/s   00:00</div><div class="line">$</div></pre></td></tr></table></figure>
<h3 id="登录进越狱设备"><a href="#登录进越狱设备" class="headerlink" title="登录进越狱设备"></a>登录进越狱设备</h3><p>可以使用<code>ssh root@IP</code>进行登录。</p>
<p>当然也可以使用<code>ssh ipad</code>，这样免密登录登录。 <a href="https://madordie.github.io/reverse-ios-ssh/">配置传送门</a></p>
<h3 id="找到可执行文件路径"><a href="#找到可执行文件路径" class="headerlink" title="找到可执行文件路径"></a>找到可执行文件路径</h3><p>这里以<code>WeChat</code>为例子啦～</p>
<p>记得先打开呀～～～</p>
<p><code>ps -e</code>： 显示所有程序<br><code>grep</code>: 这里是过滤一下。。具体用法Google。所有的程序有点多，我知道名字，所以直接过滤一下。也可忽略</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">$ ps -e | grep WeChat</div><div class="line">705 ??         0:02.20 /var/mobile/Containers/Bundle/Application/3AE519BF-2FD2-43FC-A14B-2893190B8E1E/WeChat.app/WeChat</div><div class="line">707 ttys000    0:00.01 grep WeChat</div><div class="line">$ cycript -p 705</div><div class="line">$ cycript -p 705</div><div class="line">cy# [[NSFileManager defaultManager] URLsForDirectory:NSDocumentDirectory inDomains:NSUserDomainMask][0]</div><div class="line">#&quot;file:///var/mobile/Containers/Data/Application/54EF9A70-8E3A-4B6D-B7F4-554AB256C48B/Documents/&quot;</div><div class="line">cy# exit(0)</div><div class="line">MS:Error: _krncall(mach_vm_read_overwrite(task, data, sizeof(*baton), reinterpret_cast&lt;mach_vm_address_t&gt;(baton), &amp;error)) =4</div><div class="line">*** _assert(status == 0):../Inject.cpp(143):InjectLibrary</div><div class="line">$</div></pre></td></tr></table></figure>
<p>此处获得两个目录：</p>
<ul>
<li><code>/var/mobile/Containers/Bundle/Application/3AE519BF-2FD2-43FC-A14B-2893190B8E1E/WeChat.app/WeChat</code></li>
<li><code>/var/mobile/Containers/Data/Application/54EF9A70-8E3A-4B6D-B7F4-554AB256C48B/Documents/</code></li>
</ul>
<h3 id="开砸"><a href="#开砸" class="headerlink" title="开砸"></a>开砸</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">$ cd ~</div><div class="line">$ cp dumpdecrypted.dylib /var/mobile/Containers/Data/Application/54EF9A70-8E3A-4B6D-B7F4-554AB256C48B/Documents/</div><div class="line">$ cd /var/mobile/Containers/Data/Application/54EF9A70-8E3A-4B6D-B7F4-554AB256C48B/Documents/</div><div class="line">$ DYLD_INSERT_LIBRARIES=dumpdecrypted.dylib /var/mobile/Containers/Bundle/Application/3AE519BF-2FD2-43FC-A14B-2893190B8E1E/WeChat.app/WeChat</div><div class="line">mach-o decryption dumper</div><div class="line"></div><div class="line">DISCLAIMER: This tool is only meant for security research purposes, not for application crackers.</div><div class="line"></div><div class="line">[+] detected 64bit ARM binary in memory.</div><div class="line">[+] offset to cryptid found: @0x1000c0ca8(from 0x1000c0000) = ca8</div><div class="line">[+] Found encrypted data at address 00004000 of length 51200000 bytes - type 1.</div><div class="line">[+] Opening /private/var/mobile/Containers/Bundle/Application/3AE519BF-2FD2-43FC-A14B-2893190B8E1E/WeChat.app/WeChat for reading.</div><div class="line">[+] Reading header</div><div class="line">[+] Detecting header type</div><div class="line">[+] Executable is a plain MACH-O image</div><div class="line">[+] Opening WeChat.decrypted for writing.</div><div class="line">[+] Copying the not encrypted start of the file</div><div class="line">[+] Dumping the decrypted data into the file</div><div class="line">[+] Copying the not encrypted remainder of the file</div><div class="line">[+] Setting the LC_ENCRYPTION_INFO-&gt;cryptid to 0 at offset ca8</div><div class="line">[+] Closing original file</div><div class="line">[+] Closing dump file</div><div class="line">$ ls WeChat.decrypted</div><div class="line">WeChat.decrypted</div><div class="line">$ pwd</div><div class="line">/var/mobile/Containers/Data/Application/54EF9A70-8E3A-4B6D-B7F4-554AB256C48B/Documents</div></pre></td></tr></table></figure>
<p>最后得到文件:</p>
<ul>
<li><code>/var/mobile/Containers/Data/Application/54EF9A70-8E3A-4B6D-B7F4-554AB256C48B/Documents/WeChat.decrypted</code></li>
</ul>
<h3 id="将-decrypted拷贝出来"><a href="#将-decrypted拷贝出来" class="headerlink" title="将*.decrypted拷贝出来"></a>将<code>*.decrypted</code>拷贝出来</h3><p>我这里直接使用<code>scp</code>吧～。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">$ cd /Users/Madordie/Desktop/Madordie/iOS/xxx</div><div class="line">$ scp root@10.12.14.16:/var/mobile/Containers/Data/Application/54EF9A70-8E3A-4B6D-B7F4-554AB256C48B/Documents/WeChat.decrypted .</div><div class="line">root@10.12.14.16&apos;s password:</div><div class="line">WeChat.decrypted                              100%   61MB   4.7MB/s   00:12</div><div class="line">$ ls WeChat.decrypted</div><div class="line">WeChat.decrypted</div></pre></td></tr></table></figure>
<p>至此在主机上得到：</p>
<ul>
<li><code>/Users/Madordie/Desktop/Madordie/iOS/xxx/WeChat.decrypted</code></li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>为什么将<code>dumpdecrypted.dylib</code>  <code>copy</code> 至<code>*/Documents/</code>下？<br>  ：别的目录没有权限～～（<code>dumpdecrypted.dylib: stat() failed with errno=1</code> ）</li>
</ul>
<h1 id="使用clutch进行砸壳"><a href="#使用clutch进行砸壳" class="headerlink" title="使用clutch进行砸壳"></a>使用clutch进行砸壳</h1><h2 id="步骤-1"><a href="#步骤-1" class="headerlink" title="步骤"></a>步骤</h2><h3 id="下载上传clutch-无须重复做"><a href="#下载上传clutch-无须重复做" class="headerlink" title="下载上传clutch(无须重复做)"></a>下载上传clutch(无须重复做)</h3><p><code>clutch</code>可以从<a href="https://github.com/KJCracks/Clutch" target="_blank" rel="external">https://github.com/KJCracks/Clutch</a>下载编译。</p>
<p>当然也可以从<a href="https://github.com/KJCracks/Clutch/releases" target="_blank" rel="external">https://github.com/KJCracks/Clutch/releases</a>直接下载。</p>
<p>目前下载到目录<code>~/Clutch-2.0.4</code></p>
<p>上传到设备：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ cd ~</div><div class="line">$ scp Clutch-2.0.4 root@10.12.14.16:/usr/bin/</div><div class="line">root@10.12.14.16&apos;s password:</div><div class="line">Clutch-2.0.4                                  100% 1204KB   4.7MB/s   00:00</div></pre></td></tr></table></figure>
<h3 id="登录进越狱设备-1"><a href="#登录进越狱设备-1" class="headerlink" title="登录进越狱设备"></a>登录进越狱设备</h3><p>可以使用<code>ssh root@IP</code>进行登录。</p>
<p>当然也可以使用<code>ssh ipad</code>，这样免密登录登录。 <a href="https://madordie.github.io/reverse-ios-ssh/">配置传送门</a></p>
<h3 id="修改权限"><a href="#修改权限" class="headerlink" title="修改权限"></a>修改权限</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ cd ~</div><div class="line">$ cd /usr/bin</div><div class="line">$ mv Clutch-2.0.4 clutch</div><div class="line">$ chmod +x clutch</div></pre></td></tr></table></figure>
<h3 id="砸壳"><a href="#砸壳" class="headerlink" title="砸壳"></a>砸壳</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">$ clutch -i</div><div class="line">Installed apps:</div><div class="line">1:   钉钉 &lt;com.laiwang.DingTalk&gt;</div><div class="line">2:   韩剧TV-最新热门韩剧大全 &lt;com.baoyun.hanju&gt;</div><div class="line">3:   PG Client - a better client for dribbble &lt;com.az.azdribbble&gt;</div><div class="line">4:   窝牛－设计装修我们的家 &lt;com.lingduohome.acorn&gt;</div><div class="line">$ clutch -d 1</div><div class="line">com.laiwang.DingTalk contains watchOS 2 compatible application. It&apos;s not possible to dump watchOS 2 apps with Clutch 2.0.4 at this moment.</div><div class="line">Zipping DingTalk.app</div><div class="line">ASLR slide: 0x10001c000</div><div class="line">Dumping &lt;DingTalk&gt; (arm64)</div><div class="line">Patched cryptid (64bit segment)</div><div class="line">Writing new checksum</div><div class="line">DONE: /private/var/mobile/Documents/Dumped/com.laiwang.DingTalk-iOS7.0-(Clutch-2.0.4).ipa</div><div class="line">Finished dumping com.laiwang.DingTalk in 40.6 seconds</div><div class="line">$</div></pre></td></tr></table></figure>
<p>生成最终路径:</p>
<ul>
<li><code>/private/var/mobile/Documents/Dumped/com.laiwang.DingTalk-iOS7.0-(Clutch-2.0.4).ipa</code></li>
</ul>
<h3 id="传至本地"><a href="#传至本地" class="headerlink" title="传至本地"></a>传至本地</h3><p>注意路径中有<code>()</code>这样的字符，需要转义一下。如下：</p>
<p>在本地终端中使用<code>scp</code>拉取：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">$ scp root@10.12.14.16:&apos;/private/var/mobile/Documents/Dumped/com.laiwang.DingTalk-iOS7.0-\(Clutch-2.0.4\).ipa&apos; .</div><div class="line">root@10.12.14.16&apos;s password:</div><div class="line">com.laiwang.DingTalk-iOS7.0-(Clutch-2.0.4).ip 100%   48MB   3.6MB/s   00:13</div><div class="line">$ ls com.laiwang.DingTalk-iOS7.0-\(Clutch-2.0.4\).ipa</div><div class="line">com.laiwang.DingTalk-iOS7.0-(Clutch-2.0.4).ipa</div><div class="line">$ pwd</div><div class="line">/Users/Madordie/Desktop/Madordie/ios-reverse</div></pre></td></tr></table></figure>
<p>至此在主机上得到：</p>
<ul>
<li><code>/Users/Madordie/Desktop/Madordie/ios-reverse/com.laiwang.DingTalk-iOS7.0-\(Clutch-2.0.4\).ipa</code></li>
</ul>
<h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><ul>
<li>并不是每一个都可以支持这种工具砸壳，失败了用第一种试试。。。</li>
</ul>
<h1 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h1><p>目前发现这两种砸壳工具。但是并不是每一个APP都可以使用2种工具。有的只有一个有效，有的两个都有效，还有一种两个都失败的😂</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;准备工作&quot;&gt;&lt;a href=&quot;#准备工作&quot; class=&quot;headerlink&quot; title=&quot;准备工作&quot;&gt;&lt;/a&gt;准备工作&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;越狱设备&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;目前有两种砸壳工具，并不肩并肩，一个不行就用另一个呗，俩都不行就Google吧～～&lt;/p&gt;
&lt;p&gt;下面分别对&lt;code&gt;cycript&lt;/code&gt;、&lt;code&gt;clutch&lt;/code&gt;进行砸壳:&lt;/p&gt;
    
    </summary>
    
      <category term="iOS" scheme="https://madordie.github.io/categories/iOS/"/>
    
    
      <category term="逆向" scheme="https://madordie.github.io/tags/%E9%80%86%E5%90%91/"/>
    
  </entry>
  
  <entry>
    <title>iOS逆向-设备ssh免密登录</title>
    <link href="https://madordie.github.io/reverse-ios-ssh/"/>
    <id>https://madordie.github.io/reverse-ios-ssh/</id>
    <published>2017-08-09T07:31:30.000Z</published>
    <updated>2017-08-14T02:04:27.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="前提条件"><a href="#前提条件" class="headerlink" title="前提条件"></a>前提条件</h2><ul>
<li>已越狱设备</li>
<li>越狱设备安装OpenSSH(⚠️记得修改默认的’alpine’登录密码)</li>
<li>电脑和设备同局域网。（我这里设备IP：10.11.12.13，并且设置成静态IP了😂）</li>
</ul>
<a id="more"></a>
<h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><h3 id="生成RSA证书"><a href="#生成RSA证书" class="headerlink" title="生成RSA证书"></a>生成RSA证书</h3><p>我这里生成的证书为:<code>ipad</code>，可自己需要定义。（注意如果直接回车会覆盖<code>~/.ssh/id_rsa</code>）</p>
<p>执行命令<code>ssh-keygen</code>，如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">$ cd ~/.ssh/</div><div class="line">$ ssh-keygen</div><div class="line">Generating public/private rsa key pair.</div><div class="line">Enter file in which to save the key (/Users/Madordie/.ssh/id_rsa): ipad</div><div class="line">Enter passphrase (empty for no passphrase):</div><div class="line">Enter same passphrase again:</div><div class="line">Your identification has been saved in ipad.</div><div class="line">Your public key has been saved in ipad.pub.</div><div class="line">The key fingerprint is:</div><div class="line">SHA256:GpQBeAf+oqUzWlUhtItDcVyVFz2wd0EcIgD+BZLPK8U Madordie@Bingo.local</div><div class="line">The key&apos;s randomart image is:</div><div class="line">+---[RSA 2048]----+</div><div class="line">|  .+*+*++o++.o+. |</div><div class="line">|  .+o+o=...oo... |</div><div class="line">|  ..o.=+ .o ...  |</div><div class="line">| . . = .E. . .   |</div><div class="line">|  o = o.S.       |</div><div class="line">|   * ..o.        |</div><div class="line">|  *   ..         |</div><div class="line">| o o             |</div><div class="line">|.                |</div><div class="line">+----[SHA256]-----+</div><div class="line"></div><div class="line">$ ls ~/.ssh/ipad*</div><div class="line">/Users/Madordie/.ssh/ipad     /Users/Madordie/.ssh/ipad.pub</div></pre></td></tr></table></figure></p>
<h3 id="将公钥推送至越狱设备"><a href="#将公钥推送至越狱设备" class="headerlink" title="将公钥推送至越狱设备"></a>将公钥推送至越狱设备</h3><p>默认是没有<code>~/.ssh</code>目录的，暂时放置在<code>/var/root</code>下。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ scp ~/.ssh/ipad.pub root@10.11.12.13:/var/root</div></pre></td></tr></table></figure>
<p><code>scp</code> 默认端口为<code>22</code> 如果需要自定义端口可以在路径前添加<code>-P 端口号</code>参数。</p>
<h3 id="配置本机-ssh-config文件"><a href="#配置本机-ssh-config文件" class="headerlink" title="配置本机~/.ssh/config文件"></a>配置本机<code>~/.ssh/config</code>文件</h3><p>使用顺手的工具编辑<code>~/.ssh/config</code>文件。（没有就新建一个啦～</p>
<p>按照如下格式填写。默认<code>ssh</code>登录端口为<code>22</code>可以不写。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Host ipad</div><div class="line">    Hostname 10.11.12.13</div><div class="line">    User root</div><div class="line">    Port 22</div><div class="line">    PreferredAuthentications publickey</div><div class="line">    IdentityFile ~/.ssh/ipad</div></pre></td></tr></table></figure></p>
<h3 id="配置越狱设备"><a href="#配置越狱设备" class="headerlink" title="配置越狱设备"></a>配置越狱设备</h3><p>先用<code>ssh root@10.11.12.13</code>登录进设备。刚才我们将<code>ipad.pub</code>通过<code>scp</code>放在了<code>/var/root</code>下。</p>
<p>一般情况下<code>/var/root/.ssh</code>是不存在的，使用命令<code>mkdir -p /var/root/.ssh</code>即可创建。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ cat ipad.pub &gt;&gt; /var/root/.ssh/authorized_keys</div></pre></td></tr></table></figure>
<p>然后强迫症的可以使用<code>rm -rf ipad.pub</code>删除啦～</p>
<p>对了，退出<code>ssh</code>登录的设备使用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ exit</div><div class="line">logout</div><div class="line">Connection to 10.11.12.13 closed.</div></pre></td></tr></table></figure>
<h3 id="赶紧测试一下远程登录效果"><a href="#赶紧测试一下远程登录效果" class="headerlink" title="赶紧测试一下远程登录效果"></a>赶紧测试一下远程登录效果</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ ssh ipad</div></pre></td></tr></table></figure>
<p>然后你会发现你已经完成了免密码登录越狱设备。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>其实这并不是只有越狱iOS设备才能使用的免登录，而是<code>ssh</code>所支持的。用途也很方便～</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前提条件&quot;&gt;&lt;a href=&quot;#前提条件&quot; class=&quot;headerlink&quot; title=&quot;前提条件&quot;&gt;&lt;/a&gt;前提条件&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;已越狱设备&lt;/li&gt;
&lt;li&gt;越狱设备安装OpenSSH(⚠️记得修改默认的’alpine’登录密码)&lt;/li&gt;
&lt;li&gt;电脑和设备同局域网。（我这里设备IP：10.11.12.13，并且设置成静态IP了😂）&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="iOS" scheme="https://madordie.github.io/categories/iOS/"/>
    
    
      <category term="逆向" scheme="https://madordie.github.io/tags/%E9%80%86%E5%90%91/"/>
    
  </entry>
  
  <entry>
    <title>自定义数据填充Sketch插件</title>
    <link href="https://madordie.github.io/format-sketchplugin/"/>
    <id>https://madordie.github.io/format-sketchplugin/</id>
    <published>2017-07-17T06:45:12.000Z</published>
    <updated>2017-08-14T02:01:51.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="先来个README-md"><a href="#先来个README-md" class="headerlink" title="先来个README.md"></a>先来个README.md</h2><blockquote>
<h2 id="format-sketchplugin"><a href="#format-sketchplugin" class="headerlink" title="format-sketchplugin"></a><a href="https://github.com/madordie/format-sketchplugin" target="_blank" rel="external">format-sketchplugin</a></h2><p>为Sketch自动生成自定义填充数据源插件。</p>
<p><img src="https://github.com/madordie/format-sketchplugin/blob/master/Images/Untitled.gif?raw=true" alt="预览"></p>
<h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><ul>
<li>下载<a href="https://github.com/madordie/format-sketchplugin/releases" target="_blank" rel="external">Release</a>上的包，并双击打开</li>
<li>选择要随机填充的文本数据(支持多选，文本数据按照回车进行随机，会默认删除空数据)</li>
<li>选择随机填充的图片文件夹(只支持单选文件夹，选中文件夹内的<code>.png</code>、 <code>.PNG</code>、 <code>.jpg</code>、 <code>.JPG</code>、 <code>.jpeg</code>、 <code>.JPEG</code>、 <code>.gif</code>、 <code>.GIF</code>文件将会被识别并作为数据源)</li>
<li>将插件生成目录拖拽至窗口即完成设置</li>
<li>文本、图片文件夹 可在保存前重复多次选择</li>
<li>点击<code>制作</code>，即可在生成目录看到插件生成</li>
</ul>
<h2 id="生成说明"><a href="#生成说明" class="headerlink" title="生成说明"></a>生成说明</h2><ul>
<li>文本数据按照文本文件名作为标示</li>
<li>图片文件夹按照图片文件夹名作为标示</li>
<li>保存时，文本数据会读取至插件内</li>
<li>保存时，图片文件夹会复制至插件内(不识别子目录，并只拷贝可识别的素材)</li>
</ul>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css&quot;&gt;&lt;h2 id=&quot;先来个README-md&quot;&gt;&lt;a href=&quot;#先来个README
    
    </summary>
    
      <category term="工具" scheme="https://madordie.github.io/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="Sketchplugin" scheme="https://madordie.github.io/tags/Sketchplugin/"/>
    
  </entry>
  
  <entry>
    <title>iOS11-beta</title>
    <link href="https://madordie.github.io/ios11-beta/"/>
    <id>https://madordie.github.io/ios11-beta/</id>
    <published>2017-06-12T09:20:58.000Z</published>
    <updated>2017-09-14T04:01:14.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>iOS11 预览版安装体验笔记。</p>
<a id="more"></a>
<h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>毕竟beta版，升级需谨慎。目前来看体验上还是有点卡的～～😂</p>
<p>卡顿让我实在无法忍受，并与6.15号重置回iOS10.3.2 。。。</p>
<p>9.13 GM出来了，再安装～～</p>
<h2 id="API"><a href="#API" class="headerlink" title="API"></a>API</h2><h3 id="失效的automaticallyAdjustsScrollViewInsets"><a href="#失效的automaticallyAdjustsScrollViewInsets" class="headerlink" title="失效的automaticallyAdjustsScrollViewInsets"></a>失效的<code>automaticallyAdjustsScrollViewInsets</code></h3><p>iOS11 版本中 <strong>立即失效</strong>。</p>
<p>最容易出问题的就是无导航的顶部刷新会莫名其妙的缩不进去～～</p>
<p>API 声明：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@available</span>(iOS <span class="number">2.0</span>, *)</div><div class="line">open <span class="class"><span class="keyword">class</span> <span class="title">UIViewController</span> : <span class="title">UIResponder</span>, ... </span>&#123;</div><div class="line">	...</div><div class="line">	<span class="meta">@available</span>(iOS, introduced: <span class="number">7.0</span>, deprecated: <span class="number">11.0</span>)</div><div class="line">	open <span class="keyword">var</span> automaticallyAdjustsScrollViewInsets: <span class="type">Bool</span> <span class="comment">// Defaults to YES</span></div><div class="line">	...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>相应的的替换方案：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@available</span>(iOS <span class="number">2.0</span>, *)</div><div class="line">open <span class="class"><span class="keyword">class</span> <span class="title">UIScrollView</span> : <span class="title">UIView</span>, ... </span>&#123;</div><div class="line">	...</div><div class="line">    <span class="comment">/* Configure the behavior of adjustedContentInset.</span></div><div class="line">     Default is UIScrollViewContentInsetAdjustmentAutomatic.</div><div class="line">     */</div><div class="line">    <span class="meta">@available</span>(iOS <span class="number">11.0</span>, *)</div><div class="line">    open <span class="keyword">var</span> contentInsetAdjustmentBehavior: <span class="type">UIScrollViewContentInsetAdjustmentBehavior</span></div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="筛选view"><a href="#筛选view" class="headerlink" title="筛选view"></a>筛选view</h3><h3 id="WKWebView"><a href="#WKWebView" class="headerlink" title="WKWebView"></a>WKWebView</h3>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;iOS11 预览版安装体验笔记。&lt;/p&gt;
    
    </summary>
    
      <category term="iOS" scheme="https://madordie.github.io/categories/iOS/"/>
    
    
  </entry>
  
  <entry>
    <title>「转」Unowned 还是 Weak？生命周期和性能对比</title>
    <link href="https://madordie.github.io/swiftgg-unowned-or-weak-lifetime-and-performance/"/>
    <id>https://madordie.github.io/swiftgg-unowned-or-weak-lifetime-and-performance/</id>
    <published>2017-05-18T12:55:17.000Z</published>
    <updated>2017-08-14T02:07:26.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><blockquote>
<p>作者：Umberto Raimondi，原文链接，原文日期：2016-10-27<br>译者：shanks；校对：Crystal Sun；定稿：CMB</p>
</blockquote>
<p>每当处理循环引用（retain cycles）时，需要考量对象生命周期来选择unowned或者weak标识符，这已经成为了一个共识。但是有时仍然会心存疑问，在具体的使用中应该选择哪一个，或者退一步讲，保守的只使用 weak 是不是一个好的选择呢？</p>
<p>本文首先对循环引用的基础知识做一个简要介绍，然后会分析 Swift 源代码的一些片段，讲解 unowned 和 weak 在生命周期和性能上的差异点，希望看完本文以后，在的使用场景中，能使用正确的弱引用类型。</p>
<a id="more"></a>
<h2 id="目录"><a href="#目录" class="headerlink" title="目录:"></a>目录:</h2><ul>
<li>基础知识</li>
<li>问题来了: unowened 还是 weak?</li>
<li>性能：深度探索</li>
<li>捕获列表处理解析</li>
<li>结论</li>
<li>脚注</li>
</ul>
<blockquote>
<p>从 GitHub 或者 zipped 获取本文相关的 Playground 代码。然后从这里获取闭包案例和 SIL，SILGen 以及 LLVM IR 的输出。</p>
</blockquote>
<h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><p>众所周知，Swift 利用古老并且有效的自动引用计数（ARC, Automatic Reference Counting）来管理内存，带来的后果和在 Objective-C 中使用的情况类似，需要手动使用弱引用来解决循环引用问题。</p>
<p>如果对 ARC 不了解，只需要知道的是，每一个引用类型实例都有一个引用计数与之关联，这个引用计数用来记录这个对象实例正在被变量或常量引用的总次数。当引用计数变为 0 时，实例将会被析构，实例占有的内存和资源都将变得重新可用。</p>
<p>当有两个实例通过某种形式互相引用时，就会形成循环引用（比如：两个类实例都有一个属性指向对方的类实例；双向链表中两个相邻的节点实例等…）, 由于两个实例的引用计数都一直大于 0， 循环引用将会阻止这些实例的析构。</p>
<p>为了解决这个问题，和其他一些有类似问题的语言一样， 在 Swift 中，弱引用 的概念被提了出来，弱引用不会被 ARC 计算，也就是说，当一个弱引用指向一个引用类型实例时，引用计数不会增加。</p>
<p>弱引用不会阻止实例的析构, 只需要记住的是，在任何情况下，弱引用都不会拥有它指向的对象。在正式的场景中不是什么大问题，但是在我们处理这类引用的时候，需要意识到这一点。</p>
<p>在 Swift 中有 2 种 弱 引用形式，unowned 和 weak。</p>
<p>虽然它们的作用类似，但与它们相关实例生命周期的假设会略有不同，并且具有不同的性能特征。</p>
<p>为了举例说明循环引用，这里不使用大家期望看到的类之间的循环引用，而使用闭包的上下文案例，这在 Objective-C 日常开发中处理循环引用时经常会遇到的情况。和类的循环引用类似，通过创建一个强引用指向外部实例，或捕获它，阻止它析构。</p>
<p>在 Objective-C ，按照标准的做法，定义一个弱引用指向闭包外部的实例，然后在闭包内部定义强引用指向这个实例，在闭包执行期间使用它。当然，有必要在使用前检查引用的有效性。</p>
<p>为了更方便的处理循环引用，Swift 引入了一个新的概念，用于简化和更加明显地表达在闭包内部外部变量的捕获：捕获列表（capture list）。使用捕获列表，可以在函数的头部定义和指定那些需要用在内部的外部变量，并且指定引用类型(译者注：这里是指 unowned 和 weak）。</p>
<p>接下来举一些例子，在各种情况下捕获变量的表现。</p>
<p>当不使用捕获列表时，闭包将会创建一个外部变量的强引用：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> i1 = <span class="number">1</span>, i2 = <span class="number">1</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> fStrong = &#123;</div><div class="line">    i1 += <span class="number">1</span></div><div class="line">    i2 += <span class="number">2</span></div><div class="line">&#125;</div><div class="line"></div><div class="line">fStrong()</div><div class="line"><span class="built_in">print</span>(i1,i2) <span class="comment">//Prints 2 and 3</span></div></pre></td></tr></table></figure>
<p>闭包内部对变量的修改将会改变外部原始变量的值，这与预期是一致的。</p>
<p>使用捕获列表，闭包内部会创建一个新的可用常量。如果没有指定常量修饰符，闭包将会简单地拷贝原始值到新的变量中，对于值类型和引用类型都是一样的。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> fCopy = &#123; [i1] <span class="keyword">in</span></div><div class="line">    <span class="built_in">print</span>(i1,i2)</div><div class="line">&#125;</div><div class="line"></div><div class="line">fStrong()</div><div class="line"><span class="built_in">print</span>(i1,i2) <span class="comment">//打印结果是 2 和 3  </span></div><div class="line"></div><div class="line">fCopy()  <span class="comment">//打印结果是 1 和 3</span></div></pre></td></tr></table></figure>
<p>在上面的例子中，在调用 fStrong 之前定义函数 fCopy ,在该函数定义的时候，私有常量已经被创建了。正如你所看到的，当调用第二个函数时候，仍然打印 i1 的原始值。</p>
<p>对于外部引用类型的变量，在捕获列表中指定 weak 或 unowned，这个常量将会被初始化为一个弱引用，指向原始值，这种指定的捕获方式就是用来处理循环引用的方式。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">aClass</span></span>&#123;</div><div class="line">    <span class="keyword">var</span> value = <span class="number">1</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> c1 = aClass()</div><div class="line"><span class="keyword">var</span> c2 = aClass()</div><div class="line"></div><div class="line"><span class="keyword">var</span> fSpec = &#123; [<span class="keyword">unowned</span> c1, <span class="keyword">weak</span> c2] <span class="keyword">in</span></div><div class="line">    c1.value += <span class="number">1</span></div><div class="line">    <span class="keyword">if</span> <span class="keyword">let</span> c2 = c2 &#123;</div><div class="line">        c2.value += <span class="number">1</span></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">fSpec()</div><div class="line"><span class="built_in">print</span>(c1.value,c2.value) <span class="comment">//Prints 2 and 2</span></div></pre></td></tr></table></figure>
<p>两个 aClass 捕获实例的不同的定义方式，决定了它们在闭包中不同的使用方式。</p>
<p>unowned 引用使用的场景是，原始实例永远不会为 nil，闭包可以直接使用它，并且直接定义为显式解包可选值。当原始实例被析构后，在闭包中使用这个捕获值将导致崩溃。</p>
<p>如果捕获原始实例在使用过程中可能为 nil ，必须将引用声明为 weak， 并且在使用之前验证这个引用的有效性。</p>
<h2 id="问题来了-unowened-还是-weak"><a href="#问题来了-unowened-还是-weak" class="headerlink" title="问题来了: unowened 还是 weak?"></a>问题来了: unowened 还是 weak?</h2><p>在实际使用中如何选择这两种弱引用类型呢？</p>
<p>这个问题的答案可以简单由原始对象和引用它的闭包的生命周期来解释。</p>
<p><img src="/images/unownedbig.png" alt="unownedbig"></p>
<p>有两个可能出现的场景：</p>
<ul>
<li><p>闭包和捕获对象的生命周期相同，所以对象可以被访问，也就意味着闭包也可以被访问。外部对象和闭包有相同的生命周期(比如：对象和它的父对象的简单返回引用）。在这种情况下，你应该把引用定义为 unowned。</p>
<p>  一个经典的案例是: [unowned self], 主要用在闭包中，这种闭包主要在他们的父节点上下文中做一些事情，没有在其他地方被引用或传递，不能作用在父节点之外。</p>
</li>
<li><p>闭包的生命周期和捕获对象的生命周期相互独立，当对象不能再使用时，闭包依然能够被引用。这种情况下，你应该把引用定义为 weak，并且在使用它之前验证一下它是否为 nil（请不要对它进行强制解包).</p>
<p>  一个经典的案例是: [weak delegate = self.delegate!]，可以在某些使用闭包的场景中看到，闭包使用的是完全无关（生命周期独立）的代理对象。</p>
</li>
</ul>
<p>当无法确认两个对象之间生命周期的关系时，是否不应该去冒险选择一个无效 unowned 引用？而是保守选择 weak 引用是一个更好的选择？<br>答案是否定的，不仅仅是因为对象生命周期了解是一件必要的事情，而且这两个修饰符在性能特性上也有很大的不同。</p>
<p>弱引用最常见的实现是，每次一个新的引用生成时，都会把每个弱引用和它指向的对象信息存储到一个附加表中。</p>
<p>当没有任何强引用指向一个对象时，Swift 运行时会启动析构过程，但是在这之前，运行时会把所有相关的弱引用置为 nil 。弱引用的这种实现方式我们称之为”零和弱引用”。</p>
<p>这种实现有实际的开销，考虑到需要额外实现的数据结构，需要确保在并发访问情况下，对这个全局引用结构所有操作的正确性。一旦析构过程开始了，在任何环境中，都不允许访问弱引用所指向的对象了。</p>
<p>弱引用（包括 unowned 和一些变体的 weak)在 Swift 使用了更简单和快速的实现机制。</p>
<p>Swift 中的每个对象保持了两个引用计数器，一个是强引用计数器，用来决定 ARC 什么时候可以安全地析构这个对象，另外一个附加的弱引用计数器，用来计算创建了多少个指向这个对象的 unowned 或者 weak 引用，当这个计数器为零时，这个对象将被 析构 。</p>
<p>需要重点理解的是，只有等到所有 unowned 引用被释放后，这个对象才会被真正地析构，然后对象将会保持未解析可访问状态，当析构发生后，对象的内容才会被回收。</p>
<p>每当 unowned 引用被定义时，对应的 unowned 引用计数会进行原子级别地增加(使用原子gcc/llvm操作，进行一系列快速且线程安全的基本操作，例如：增加，减少，比较，交换等)，以保证线程安全。在增加计数之前，会检查强引用计数以确保对象是有效的。</p>
<p>试图访问一个无效的对象，将会导致错误的断言，你的应用在运行时中会报错(这就是为什么这里的 unownd 实现方式叫做 unowned(safe) 实现)<br>为了更好的优化，应用编译时带有 -OFast，unowned 引用不会去验证引用对象的有效性，unowned 引用的行为就会像 Objective-C 中的 __unsafe_unretained 一样。如果引用对象无效，unowned 引用将会指向已经释放垃圾内存（这种实现称之 unowned(unsafe)）。</p>
<p>当一个 unowned 引用被释放后，如果这时没有其他强引用或 unowned 引用指向这个对象，那么最终这个对象将被析构。这就是为什么一个引用对象不能在强引用计数器等于零的情况下，被析构的原因，所有的引用计数器必须能够被访问用来验证 unowned 引用和强引用数量。</p>
<p>Swift 的 weak 引用添加了附加层，间接地把 unowned 引用包裹到了一个可选容器里面，在指向的对象析构之后变成空的情况下，这样处理会更加的清晰。但是需要付出的代价是，附加的机制需要正确地处理可选值。</p>
<p>考虑到以上因素，在对象关系生命周期允许的情况下，优先选择使用 unowned 引用。但是这不是此故事的结局，接下来比较一下两者性能1上的差别。</p>
<h2 id="性能：深度探索"><a href="#性能：深度探索" class="headerlink" title="性能：深度探索"></a>性能：深度探索</h2><p>在查看 Swift 项目源码验证之前，需要理解 ARC 如何管理这两种引用类型，并且还需要解释 swiftc，LLVM 和 SIL 的相关知识。</p>
<p>接下来试着简要介绍本文所需要的必备知识点，如果想了解更多，将在最后的脚注中找到一些有用的链接。</p>
<p>使用一个图来解释 swiftc 整个编译过程的包含的模块：</p>
<p><img src="/images/swiftc.png" alt="swiftc"></p>
<p>Swiftc 和 clang 一样构建在 LLVM 上，遵循 clang 编译器相似的编译流程。</p>
<p>在编译过程的第一部分，使用一个特定语言前端进行管理，swift 源代码被解释生成一个抽象语法树(AST)表达2，然后抽象语法树的结果从语义角度进行分析，找出语义错误。</p>
<p>在这个点上，对于其他的基于 LLVM 的编译器来讲，在通过一个附加步骤对源代码进行静态分析后（必要时可以显示错误和警告），接着 IRGen 模块 会把 AST 的内容会转换成一个轻量的和底层的机器无关的表示，我们称之为 LLVM IR(LLVM 中间表示)。</p>
<p>尽管两个模块都需要做一些相同检查，但是这两个模块是区分开的，在两个模块之间也存在许多重复的代码。</p>
<p>IR 是一种静态单赋值形式（SSA-form）一致语言，可以看做注入了 LLVM 的虚拟机下的 RISC 类型汇编语言。基于 SSA 将简化接下来的编译过程，从语言前端提供的中间表达会在 IR 进行多重优化。</p>
<p>需要重点注意的是，IR 其中一个特点是，它具有三种不同的形式：内存表达（内部使用），序列化位代码形式（你已经知道的位代码形式）和可读形式。</p>
<p>最后一种形式非常有用，用来验证 IR 代码的最终结构，这个结构将会传入到整个过程中的最后一步，将会从机器独立的 IR 代码转换成平台相关的表达(比如：x86，ARM 等等)。最后一步将被 LLVM 平台后端执行。</p>
<p>那么 swiftc 和其他基于 LLVM 的编译器有什么不同呢？<br>swiftc 和其他编译器从结构形式上的差别主要体现在一个附加组件，这个附加组件是 SILGen ，在 IRGen 之前，执行代码的监测和优化，生成一个高级的中间表达，我们称之为 SIL （Swift Intermediate Language，Swift 中间语言），最后 SIL 将会转换成 LLVM IR。这一步加强了在单个软件模块上所有具体语言的检查，并且简化了 IRGen。</p>
<p>从 AST 到 IR 的转换分为两个步骤。SILGen 把 AST 源代码转换为原始 SIL ，然后编译器进行 Swift 语法检查（需要时打印错误或者警告信息），优化有效的原始 SIL ，通过一些步骤最后生成标准化 SIL 。如上面的示意图显示那样，标准化 SIL 的最后转化为 LLVM IR。</p>
<p>再次强调，SIL 是一个 SSA 类型语言，使用附加的结构扩展了 Swift 的语法。它依赖 Swift 的类型系统，并且能理解 Swift 的定义，但是需要重点记住的是，当编译一个手写的 SIL 源码（是的，可以手动写 SIL 然后编译它）时，高阶的 Swift 代码或者函数内容将被编译器忽略。</p>
<p>在接下来的章节，我们将分析一个标准化 SIL 的案例，来理解 unowned 和 weak 引用如何被编译器处理。一个包含捕获列表的基本闭包的例子，查看这个例子生成的 SIL 代码，可以看到被编译器添加的所有 ARC 相关的函数调用。</p>
<blockquote>
<p>从 GitHub 或者 zipped 获取本文相关的 Playground 代码。然后从这里获取闭包案例和 SIL ，SILGen 以及 LLVM IR 的输出。</p>
</blockquote>
<h2 id="捕获列表处理解析"><a href="#捕获列表处理解析" class="headerlink" title="捕获列表处理解析"></a>捕获列表处理解析</h2><p>接下来看看一个简单的 Swift 的例子，定义两个类变量，然后在一个闭包中对他们进行弱引用的捕获：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">aClass</span></span>&#123;</div><div class="line">    <span class="keyword">var</span> value = <span class="number">1</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> c1 = aClass()</div><div class="line"><span class="keyword">var</span> c2 = aClass()</div><div class="line"></div><div class="line"><span class="keyword">var</span> fSpec = &#123; </div><div class="line">    [<span class="keyword">unowned</span> c1, <span class="keyword">weak</span> c2] <span class="keyword">in</span></div><div class="line">    c1.value = <span class="number">42</span></div><div class="line">    <span class="keyword">if</span> <span class="keyword">let</span> c2o = c2 &#123;</div><div class="line">        c2o.value = <span class="number">42</span></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">fSpec()</div></pre></td></tr></table></figure>
<p>通过 xcrun swiftc -emit-sil sample.swift 编译 swift 源代码，生成标准化 SIL 代码。原始SIL 可以使用 -emit-silgen 选项来生成。</p>
<p>运行以上命令以后，会发现 swiftc 产生了许多代码。通过查看 swiftc 输出代码的片段，学习一下基本的 SIL 指令，理解整个结构。</p>
<p>在下面代码中需要的地方添加了一些多行注释（编译器也生成了一些单行注释），希望这些注释已经足够说清楚发生了什么：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line">  此文件包含典型 SIL 代码</div><div class="line">*/</div><div class="line">sil_stage canonical             </div><div class="line"></div><div class="line"><span class="comment">/* </span></div><div class="line">  只有在 SIL 内部使用的特殊的导入</div><div class="line">*/</div><div class="line"><span class="keyword">import</span> Builtin                  </div><div class="line"><span class="keyword">import</span> Swift</div><div class="line"><span class="keyword">import</span> SwiftShims</div><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line">	三个全局变量的定义，包括 c1，c2 和 闭包 fSpec。</div><div class="line">  	@_Tv4clos2c1CS_6aClass是变量的符号，$aClass 是它的类型（类型前缀为$)。</div><div class="line">  	变量名在这里看起来很乱，但是在后面的代码中将变得更加可读。</div><div class="line">*/</div><div class="line"><span class="comment">// c1</span></div><div class="line">sil_global hidden @_Tv4sample2c1CS_6aClass : $aClass</div><div class="line"></div><div class="line"><span class="comment">// c2</span></div><div class="line">sil_global hidden @_Tv4sample2c2CS_6aClass : $aClass</div><div class="line"></div><div class="line"><span class="comment">// fSpec</span></div><div class="line">sil_global hidden @_Tv4sample5fSpecFT_T_ : $@callee_owned () -&gt; ()</div><div class="line"></div><div class="line">...</div><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line">  层次作用域定义表示原始代码的位置。</div><div class="line">  每个 SIL 指示将会指向它生成的 `sil_scope`。</div><div class="line">*/</div><div class="line">sil_scope <span class="number">1</span> &#123;  parent @main : $<span class="meta">@convention</span>(<span class="built_in">c</span>) (<span class="type">Int32</span>, <span class="type">UnsafeMutablePointer</span>&lt;<span class="type">Optional</span>&lt;<span class="type">UnsafeMutablePointer</span>&lt;<span class="type">Int8</span>&gt;&gt;&gt;) -&gt; <span class="type">Int32</span> &#125;</div><div class="line">sil_scope <span class="number">2</span> &#123; loc <span class="string">"sample.swift"</span>:<span class="number">14</span>:<span class="number">1</span> parent <span class="number">1</span> &#125;</div><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line">	自动生成的 @main 函数包含了我们原始全部作用域的代码。</div><div class="line"> 	这里沿用了熟悉的 c main() 函数结构，接收参数个数和参数数组两个输入，这个函数遵循 c 调用约定。</div><div class="line">  	这个函数包含了需要调用闭包的指令。</div><div class="line">*/</div><div class="line"><span class="comment">// main</span></div><div class="line">sil @main : $<span class="meta">@convention</span>(<span class="built_in">c</span>) (<span class="type">Int32</span>, <span class="type">UnsafeMutablePointer</span>&lt;<span class="type">Optional</span>&lt;<span class="type">UnsafeMutablePointer</span>&lt;<span class="type">Int8</span>&gt;&gt;&gt;) -&gt; <span class="type">Int32</span> &#123;</div><div class="line"><span class="comment">/*</span></div><div class="line">  入口定义头部为 % 符号，后面跟随一个数字 id。</div><div class="line">  每当一个新的入口定义时（或者函数开头定义函数参数），编译器在入口行尾根据它的值（叫做 users）添加一个注释。</div><div class="line">  对于其他指令，需要提供 id 号。</div><div class="line">  在这里，入口 0 将被用来计算入口 4 的内容，入口 1 将被用来创建入口 10 的值。</div><div class="line">*/</div><div class="line"><span class="comment">// %0                                             // user: %4</span></div><div class="line"><span class="comment">// %1                                             // user: %10</span></div><div class="line"><span class="comment">/*</span></div><div class="line">  每一个函数被分解成一系列的基本指令块，每一个指令块结束于一个终止指令（一个分支或者一个返回）。</div><div class="line">  这一系列的指令块表示函数所有可能的执行路径。</div><div class="line">*/</div><div class="line">bb0(%<span class="number">0</span> : $<span class="type">Int32</span>, %<span class="number">1</span> : $<span class="type">UnsafeMutablePointer</span>&lt;<span class="type">Optional</span>&lt;<span class="type">UnsafeMutablePointer</span>&lt;<span class="type">Int8</span>&gt;&gt;&gt;):</div><div class="line">...</div><div class="line">  <span class="comment">/*</span></div><div class="line">    每一个 SIL 指令都包含一个引用，指向源代码的位置，包括指令具体从源代码中哪个地方来，属于哪一个作用域。</div><div class="line">    在后面分析具体的方法会看到这些内容。</div><div class="line">  */</div><div class="line">  unowned_retain %<span class="number">27</span> : $@sil_unowned aClass, loc <span class="string">"sample.swift"</span>:<span class="number">9</span>:<span class="number">14</span>, scope <span class="number">2</span> <span class="comment">// id: %28</span></div><div class="line">  store %<span class="number">27</span> to %<span class="number">2</span> : $*@sil_unowned aClass, loc <span class="string">"sample.swift"</span>:<span class="number">9</span>:<span class="number">14</span>, scope <span class="number">2</span> <span class="comment">// id: %29</span></div><div class="line">  %<span class="number">30</span> = alloc_box $@sil_weak <span class="type">Optional</span>&lt;aClass&gt;, <span class="keyword">var</span>, name <span class="string">"c2"</span>, loc <span class="string">"sample.swift"</span>:<span class="number">9</span>:<span class="number">23</span>, scope <span class="number">2</span> <span class="comment">// users: %46, %44, %43, %31</span></div><div class="line">  %<span class="number">31</span> = project_box %<span class="number">30</span> : $@box @sil_weak <span class="type">Optional</span>&lt;aClass&gt;, loc <span class="string">"sample.swift"</span>:<span class="number">9</span>:<span class="number">23</span>, scope <span class="number">2</span> <span class="comment">// user: %35</span></div><div class="line">  %<span class="number">32</span> = load %<span class="number">19</span> : $*aClass, loc <span class="string">"sample.swift"</span>:<span class="number">9</span>:<span class="number">23</span>, scope <span class="number">2</span> <span class="comment">// users: %34, %33</span></div><div class="line">  ...</div><div class="line">&#125;</div><div class="line"></div><div class="line">...</div><div class="line"></div><div class="line"><span class="comment">/* </span></div><div class="line">  下面是一系列自动生成的`aClass`的方法，包括： init/deinit, setter/getter 和其他一些工具方法。</div><div class="line">  每个方法前的注释是编译器添加的，用来说明代码的具体作用。</div><div class="line">*/</div><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line">  隐藏方法只在它们模块中可见。</div><div class="line">  @convention(方法名)是 Swift 中方法调用默认的约定，在尾部有一个附加的参数指向它自己。</div><div class="line">*/</div><div class="line"><span class="comment">// aClass.__deallocating_deinit</span></div><div class="line">sil hidden @_TFC4clos6aClassD : $<span class="meta">@convention</span>(method) (@owned aClass) -&gt; () &#123;</div><div class="line">    ...</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line">  @guaranteed 参数表示保证在整个周期内调用此方法都有效。</div><div class="line">*/</div><div class="line"><span class="comment">// aClass.deinit</span></div><div class="line">sil hidden @_TFC4clos6aClassd : $<span class="meta">@convention</span>(method) (@guaranteed aClass) -&gt; @owned <span class="type">Builtin</span>.<span class="type">NativeObject</span> &#123;</div><div class="line">    ...</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line">  [transparent] 修饰的方法是内联的小方法</div><div class="line">*/</div><div class="line"><span class="comment">// aClass.value.getter</span></div><div class="line">sil hidden [transparent] @_TFC4clos6aClassg5valueSi : $<span class="meta">@convention</span>(method) (@guaranteed aClass) -&gt; <span class="type">Int</span> &#123;</div><div class="line">    ...</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// aClass.value.setter</span></div><div class="line">sil hidden [transparent] @_TFC4clos6aClasss5valueSi : $<span class="meta">@convention</span>(method) (<span class="type">Int</span>, @guaranteed aClass) -&gt; () &#123;</div><div class="line">    ...</div><div class="line">&#125;</div><div class="line"><span class="comment">// aClass.value.materializeForSet</span></div><div class="line">sil hidden [transparent] @_TFC4clos6aClassm5valueSi : $<span class="meta">@convention</span>(method) (<span class="type">Builtin</span>.<span class="type">RawPointer</span>, @<span class="keyword">inout</span> <span class="type">Builtin</span>.<span class="type">UnsafeValueBuffer</span>, @guaranteed aClass) -&gt; (<span class="type">Builtin</span>.<span class="type">RawPointer</span>, <span class="type">Optional</span>&lt;<span class="type">Builtin</span>.<span class="type">RawPointer</span>&gt;) &#123;</div><div class="line">    ...</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line">  @owned 修饰符表示这个对象将被调用者拥有。</div><div class="line">*/</div><div class="line"><span class="comment">// aClass.init() -&gt; aClass</span></div><div class="line">sil hidden @_TFC4clos6aClasscfT_S0_ : $<span class="meta">@convention</span>(method) (@owned aClass) -&gt; @owned aClass &#123;</div><div class="line">    ...</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// aClass.__allocating_init() -&gt; aClass</span></div><div class="line">sil hidden @_TFC4clos6aClassCfT_S0_ : $<span class="meta">@convention</span>(method) (@thick aClass.<span class="type">Type</span>) -&gt; @owned aClass &#123;</div><div class="line">    ...</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/* </span></div><div class="line">  接下面是闭包代码段</div><div class="line">*/</div><div class="line"><span class="comment">// (closure #1)</span></div><div class="line">sil shared @_TF4closU_FT_T_ : $<span class="meta">@convention</span>(thin) (@owned @sil_unowned aClass, @owned @box @sil_weak <span class="type">Optional</span>&lt;aClass&gt;) -&gt; () &#123;</div><div class="line">    ...</div><div class="line">    <span class="comment">/* 关于闭包的 SIL 代码， 见下文 */</span></div><div class="line"></div><div class="line">    ...</div><div class="line">&#125;</div><div class="line"></div><div class="line">...</div><div class="line"><span class="comment">/* </span></div><div class="line">  sil_vtable 定义所有关于 aClass 类的虚函数表。</div><div class="line">  sil_vtable 包含了期望的所有自动生成的方法。</div><div class="line">*/</div><div class="line">sil_vtable aClass &#123;</div><div class="line">  #aClass.<span class="keyword">deinit</span>!deallocator: _TFC4clos6aClassD	<span class="comment">// aClass.__deallocating_deinit</span></div><div class="line">  #aClass.value!getter.<span class="number">1</span>: _TFC4clos6aClassg5valueSi	<span class="comment">// aClass.value.getter</span></div><div class="line">  #aClass.value!setter.<span class="number">1</span>: _TFC4clos6aClasss5valueSi	<span class="comment">// aClass.value.setter</span></div><div class="line">  #aClass.value!materializeForSet.<span class="number">1</span>: _TFC4clos6aClassm5valueSi	<span class="comment">// aClass.value.materializeForSet</span></div><div class="line">  #aClass.<span class="keyword">init</span>!initializer.<span class="number">1</span>: _TFC4clos6aClasscfT_S0_	<span class="comment">// aClass.init() -&gt; aClass</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>现在回到主函数，看看两个类实例如何被获取到，并如何传递给调用他们的闭包。</p>
<p>在这里，所有标识都被重新整理，使得代码片段更加可读。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// main</span></div><div class="line">sil @main : $<span class="meta">@convention</span>(<span class="built_in">c</span>) (<span class="type">Int32</span>, <span class="type">UnsafeMutablePointer</span>&lt;<span class="type">Optional</span>&lt;<span class="type">UnsafeMutablePointer</span>&lt;<span class="type">Int8</span>&gt;&gt;&gt;) -&gt; <span class="type">Int32</span> &#123;</div><div class="line"><span class="comment">// %0                                             // user: %4</span></div><div class="line"><span class="comment">// %1                                             // user: %10</span></div><div class="line">bb0(%<span class="number">0</span> : $<span class="type">Int32</span>, %<span class="number">1</span> : $<span class="type">UnsafeMutablePointer</span>&lt;<span class="type">Optional</span>&lt;<span class="type">UnsafeMutablePointer</span>&lt;<span class="type">Int8</span>&gt;&gt;&gt;):</div><div class="line">  ...</div><div class="line">  <span class="comment">/*</span></div><div class="line">    全局变量的引用使用三个入口来放置。</div><div class="line">  */</div><div class="line">  %<span class="number">13</span> = global_addr @clos.c1 : $*aClass, loc <span class="string">"sample.swift"</span>:<span class="number">5</span>:<span class="number">5</span>, scope <span class="number">1</span> <span class="comment">// users: %26, %17</span></div><div class="line">  ...</div><div class="line">  %<span class="number">19</span> = global_addr @clos.c2 : $*aClass, loc <span class="string">"sample.swift"</span>:<span class="number">6</span>:<span class="number">5</span>, scope <span class="number">1</span> <span class="comment">// users: %32, %23</span></div><div class="line">  ...</div><div class="line">  %<span class="number">25</span> = global_addr @clos.fSpec : $*@callee_owned () -&gt; (), loc <span class="string">"sample.swift"</span>:<span class="number">8</span>:<span class="number">5</span>, scope <span class="number">1</span> <span class="comment">// users: %48, %45</span></div><div class="line">  <span class="comment">/*</span></div><div class="line">    c1 是 unowned_retained 的。</div><div class="line">    下面的指令增加变量的 unowned 引用计数。</div><div class="line">  */</div><div class="line">  %<span class="number">26</span> = load %<span class="number">13</span> : $*aClass, loc <span class="string">"sample.swift"</span>:<span class="number">9</span>:<span class="number">14</span>, scope <span class="number">2</span> <span class="comment">// user: %27</span></div><div class="line">  %<span class="number">27</span> = ref_to_unowned %<span class="number">26</span> : $aClass to $@sil_unowned aClass, loc <span class="string">"sample.swift"</span>:<span class="number">9</span>:<span class="number">14</span>, scope <span class="number">2</span> <span class="comment">// users: %47, %38, %39, %29, %28</span></div><div class="line">  unowned_retain %<span class="number">27</span> : $@sil_unowned aClass, loc <span class="string">"sample.swift"</span>:<span class="number">9</span>:<span class="number">14</span>, scope <span class="number">2</span> <span class="comment">// id: %28</span></div><div class="line">  store %<span class="number">27</span> to %<span class="number">2</span> : $*@sil_unowned aClass, loc <span class="string">"sample.swift"</span>:<span class="number">9</span>:<span class="number">14</span>, scope <span class="number">2</span> <span class="comment">// id: %29</span></div><div class="line">  <span class="comment">/*</span></div><div class="line">    对 c2 的处理会更加复杂一些。</div><div class="line">	alloc_box 创建了一个这个变量的引用数容器，变量将会存在这个容器的堆中。</div><div class="line">    容器创建以后，将会创建一个可选变量，指向 c2，并且可选变量会存储在容器里。容器会增加所包含值的技术，正如下面看到的一样，一旦容器被迁移，可选值就会被释放。</div><div class="line">    在这里，c2 的值将被存储在这个可选值中，对象将暂时strong_retained 然后释放。</div><div class="line">  */</div><div class="line">  %<span class="number">30</span> = alloc_box $@sil_weak <span class="type">Optional</span>&lt;aClass&gt;, <span class="keyword">var</span>, name <span class="string">"c2"</span>, loc <span class="string">"sample.swift"</span>:<span class="number">9</span>:<span class="number">23</span>, scope <span class="number">2</span> <span class="comment">// users: %46, %44, %43, %31</span></div><div class="line">  %<span class="number">31</span> = project_box %<span class="number">30</span> : $@box @sil_weak <span class="type">Optional</span>&lt;aClass&gt;, loc <span class="string">"sample.swift"</span>:<span class="number">9</span>:<span class="number">23</span>, scope <span class="number">2</span> <span class="comment">// user: %35</span></div><div class="line">  %<span class="number">32</span> = load %<span class="number">19</span> : $*aClass, loc <span class="string">"sample.swift"</span>:<span class="number">9</span>:<span class="number">23</span>, scope <span class="number">2</span> <span class="comment">// users: %34, %33</span></div><div class="line">  strong_retain %<span class="number">32</span> : $aClass, loc <span class="string">"sample.swift"</span>:<span class="number">9</span>:<span class="number">23</span>, scope <span class="number">2</span> <span class="comment">// id: %33</span></div><div class="line">  %<span class="number">34</span> = <span class="class"><span class="keyword">enum</span> <span class="title">$Optional</span>&lt;<span class="title">aClass</span>&gt;, #<span class="title">Optional</span>.<span class="title">some</span>!<span class="title">enumelt</span>.1, %32 : <span class="title">$aClass</span>, <span class="title">loc</span> "<span class="title">sample</span>.<span class="title">swift</span>":9:23, <span class="title">scope</span> 2 // <span class="title">users</span>: %36, %35</span></div><div class="line">  <span class="title">store_weak</span> %34 <span class="title">to</span> [<span class="title">initialization</span>] %31 : <span class="title">$</span>*@<span class="title">sil_weak</span> <span class="title">Optional</span>&lt;<span class="title">aClass</span>&gt;, <span class="title">loc</span> "<span class="title">sample</span>.<span class="title">swift</span>":9:23, <span class="title">scope</span> 2 // <span class="title">id</span>: %35</div><div class="line">  <span class="title">release_value</span> %34 : <span class="title">$Optional</span>&lt;<span class="title">aClass</span>&gt;, <span class="title">loc</span> "<span class="title">sample</span>.<span class="title">swift</span>":9:23, <span class="title">scope</span> 2 // <span class="title">id</span>: %36</div><div class="line">  /*</div><div class="line">    获取到闭包的引用。</div><div class="line">  */</div><div class="line">  // <span class="title">function_ref</span> (<span class="title">closure</span> #1)</div><div class="line">  %37 = <span class="title">function_ref</span> @<span class="title">sample</span>.(<span class="title">closure</span> #1) : <span class="title">$</span>@<span class="title">convention</span>(<span class="title">thin</span>) (@<span class="title">owned</span> @<span class="title">sil_unowned</span> <span class="title">aClass</span>, @<span class="title">owned</span> @<span class="title">box</span> @<span class="title">sil_weak</span> <span class="title">Optional</span>&lt;<span class="title">aClass</span>&gt;) -&gt; (), <span class="title">loc</span> "<span class="title">sample</span>.<span class="title">swift</span>":8:13, <span class="title">scope</span> 2 // <span class="title">user</span>: %44</div><div class="line">  /*</div><div class="line">    <span class="title">c1</span> 将被标记为 <span class="title">tagged</span>，并且变量变为 <span class="title">unowned_retained</span>。</div><div class="line">  */</div><div class="line">  <span class="title">strong_retain_unowned</span> %27 : <span class="title">$</span>@<span class="title">sil_unowned</span> <span class="title">aClass</span>, <span class="title">loc</span> "<span class="title">sample</span>.<span class="title">swift</span>":8:13, <span class="title">scope</span> 2 // <span class="title">id</span>: %38</div><div class="line">  %39 = <span class="title">unowned_to_ref</span> %27 : <span class="title">$</span>@<span class="title">sil_unowned</span> <span class="title">aClass</span> <span class="title">to</span> <span class="title">$aClass</span>, <span class="title">loc</span> "<span class="title">sample</span>.<span class="title">swift</span>":8:13, <span class="title">scope</span> 2 // <span class="title">users</span>: %42, %40</div><div class="line">  %40 = <span class="title">ref_to_unowned</span> %39 : <span class="title">$aClass</span> <span class="title">to</span> <span class="title">$</span>@<span class="title">sil_unowned</span> <span class="title">aClass</span>, <span class="title">loc</span> "<span class="title">sample</span>.<span class="title">swift</span>":8:13, <span class="title">scope</span> 2 // <span class="title">users</span>: %44, %41</div><div class="line">  <span class="title">unowned_retain</span> %40 : <span class="title">$</span>@<span class="title">sil_unowned</span> <span class="title">aClass</span>, <span class="title">loc</span> "<span class="title">sample</span>.<span class="title">swift</span>":8:13, <span class="title">scope</span> 2 // <span class="title">id</span>: %41</div><div class="line">  <span class="title">strong_release</span> %39 : <span class="title">$aClass</span>, <span class="title">loc</span> "<span class="title">sample</span>.<span class="title">swift</span>":8:13, <span class="title">scope</span> 2 // <span class="title">id</span>: %42</div><div class="line">  /*</div><div class="line">    包含 <span class="title">c2</span> 的可选值容器是 <span class="title">strong_retained</span> 的。</div><div class="line">  */</div><div class="line">  <span class="title">strong_retain</span> %30 : <span class="title">$</span>@<span class="title">box</span> @<span class="title">sil_weak</span> <span class="title">Optional</span>&lt;<span class="title">aClass</span>&gt;, <span class="title">loc</span> "<span class="title">sample</span>.<span class="title">swift</span>":8:13, <span class="title">scope</span> 2 // <span class="title">id</span>: %43</div><div class="line">  /*</div><div class="line">    创建一个闭包对象，绑定方法到参数中。</div><div class="line">  */</div><div class="line">  %44 = <span class="title">partial_apply</span> %37(%40, %30) : <span class="title">$</span>@<span class="title">convention</span>(<span class="title">thin</span>) (@<span class="title">owned</span> @<span class="title">sil_unowned</span> <span class="title">aClass</span>, @<span class="title">owned</span> @<span class="title">box</span> @<span class="title">sil_weak</span> <span class="title">Optional</span>&lt;<span class="title">aClass</span>&gt;) -&gt; (), <span class="title">loc</span> "<span class="title">sample</span>.<span class="title">swift</span>":8:13, <span class="title">scope</span> 2 // <span class="title">user</span>: %45</div><div class="line">  <span class="title">store</span> %44 <span class="title">to</span> %25 : <span class="title">$</span>*@<span class="title">callee_owned</span> () -&gt; (), <span class="title">loc</span> "<span class="title">sample</span>.<span class="title">swift</span>":8:13, <span class="title">scope</span> 2 // <span class="title">id</span>: %45</div><div class="line">  /*</div><div class="line">    </div><div class="line">    对 <span class="title">c1</span> 和 <span class="title">c2</span> 的容器变量进行释放（使用 对应匹配的 *<span class="title">_release</span> 方法）。</div><div class="line">  */</div><div class="line">  <span class="title">strong_release</span> %30 : <span class="title">$</span>@<span class="title">box</span> @<span class="title">sil_weak</span> <span class="title">Optional</span>&lt;<span class="title">aClass</span>&gt;, <span class="title">loc</span> "<span class="title">sample</span>.<span class="title">swift</span>":14:1, <span class="title">scope</span> 2 // <span class="title">id</span>: %46</div><div class="line">  <span class="title">unowned_release</span> %27 : <span class="title">$</span>@<span class="title">sil_unowned</span> <span class="title">aClass</span>, <span class="title">loc</span> "<span class="title">sample</span>.<span class="title">swift</span>":9:14, <span class="title">scope</span> 2 // <span class="title">id</span>: %47</div><div class="line">  /*</div><div class="line">     加载原先存储的闭包对象，增加强引用然后调用它。</div><div class="line">  */</div><div class="line">   %48 = <span class="title">load</span> %25 : <span class="title">$</span>*@<span class="title">callee_owned</span> () -&gt; (), <span class="title">loc</span> "<span class="title">sample</span>.<span class="title">swift</span>":17:1, <span class="title">scope</span> 2 // <span class="title">users</span>: %50, %49</div><div class="line">  <span class="title">strong_retain</span> %48 : <span class="title">$</span>@<span class="title">callee_owned</span> () -&gt; (), <span class="title">loc</span> "<span class="title">sample</span>.<span class="title">swift</span>":17:1, <span class="title">scope</span> 2 // <span class="title">id</span>: %49</div><div class="line">  %50 = <span class="title">apply</span> %48() : <span class="title">$</span>@<span class="title">callee_owned</span> () -&gt; (), <span class="title">loc</span> "<span class="title">sample</span>.<span class="title">swift</span>":17:7, <span class="title">scope</span> 2</div><div class="line">  ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>闭包有一个更加复杂的结构：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line">  闭包参数被标记为 @sil, 指定参数如何被计数，有一个 unowned 的 aClass 类变量 c2, 和另外一个包含 c2 的可选值容器。</div><div class="line">*/</div><div class="line"><span class="comment">// (closure #1)</span></div><div class="line">sil shared @clos.fSpec: $<span class="meta">@convention</span>(thin) (@owned @sil_unowned aClass, @owned @box @sil_weak <span class="type">Optional</span>&lt;aClass&gt;) -&gt; () &#123;</div><div class="line"><span class="comment">// %0                                             // users: %24, %6, %5, %2</span></div><div class="line"><span class="comment">// %1                                             // users: %23, %3</span></div><div class="line"><span class="comment">/*</span></div><div class="line">  下面的函数包含三块，后面两块的执行依赖可选值 c2 具体的值。</div><div class="line">*/</div><div class="line">bb0(%<span class="number">0</span> : $@sil_unowned aClass, %<span class="number">1</span> : $@box @sil_weak <span class="type">Optional</span>&lt;aClass&gt;):</div><div class="line">...</div><div class="line">  <span class="comment">/*</span></div><div class="line">    c1 被强计数。</div><div class="line">  */</div><div class="line">  strong_retain_unowned %<span class="number">0</span> : $@sil_unowned aClass, loc <span class="string">"sample.swift"</span>:<span class="number">10</span>:<span class="number">5</span>, scope <span class="number">17</span> <span class="comment">// id: %5</span></div><div class="line">  %<span class="number">6</span> = unowned_to_ref %<span class="number">0</span> : $@sil_unowned aClass to $aClass, loc <span class="string">"sample.swift"</span>:<span class="number">10</span>:<span class="number">5</span>, scope <span class="number">17</span> <span class="comment">// users: %11, %10, %9</span></div><div class="line">  <span class="comment">/*</span></div><div class="line">    使用内部自带包，传入一个整型字面量到整型结构中，初始化了一个值为 42 的整型值。</div><div class="line">    这个值将被设置为 c1 的新值，完成以后这个变量将会被释放。</div><div class="line">    在这里，我们第一次看到 class_method 指令，用于获取 vtable 中的函数引用。</div><div class="line">  */</div><div class="line">  %<span class="number">7</span> = integer_literal $<span class="type">Builtin</span>.<span class="type">Int64</span>, <span class="number">42</span>, loc <span class="string">"sample.swift"</span>:<span class="number">10</span>:<span class="number">16</span>, scope <span class="number">17</span> <span class="comment">// user: %8</span></div><div class="line">  %<span class="number">8</span> = <span class="class"><span class="keyword">struct</span> <span class="title">$Int</span> (%7 : <span class="title">$Builtin</span>.<span class="title">Int64</span>), <span class="title">loc</span> "<span class="title">sample</span>.<span class="title">swift</span>":10:16, <span class="title">scope</span> 17 // <span class="title">user</span>: %10</span></div><div class="line">  %9 = <span class="title">class_method</span> %6 : <span class="title">$aClass</span>, #<span class="title">aClass</span>.<span class="title">value</span>!<span class="title">setter</span>.1 : (<span class="title">aClass</span>) -&gt; (<span class="title">Int</span>) -&gt; () , <span class="title">$</span>@<span class="title">convention</span>(<span class="title">method</span>) (<span class="title">Int</span>, @<span class="title">guaranteed</span> <span class="title">aClass</span>) -&gt; (), <span class="title">loc</span> "<span class="title">sample</span>.<span class="title">swift</span>":10:14, <span class="title">scope</span> 17 // <span class="title">user</span>: %10</div><div class="line">  %10 = <span class="title">apply</span> %9(%8, %6) : <span class="title">$</span>@<span class="title">convention</span>(<span class="title">method</span>) (<span class="title">Int</span>, @<span class="title">guaranteed</span> <span class="title">aClass</span>) -&gt; (), <span class="title">loc</span> "<span class="title">sample</span>.<span class="title">swift</span>":10:14, <span class="title">scope</span> 17</div><div class="line">  <span class="title">strong_release</span> %6 : <span class="title">$aClass</span>, <span class="title">loc</span> "<span class="title">sample</span>.<span class="title">swift</span>":10:16, <span class="title">scope</span> 17 // <span class="title">id</span>: %11</div><div class="line">  /*</div><div class="line">    接下来讨论 <span class="title">c2</span>。</div><div class="line">    获取可选值，然后根据它的内容执行接下来的分支语句。</div><div class="line"></div><div class="line">    <span class="title">If</span> <span class="title">the</span> <span class="title">optional</span> <span class="title">has</span> <span class="title">a</span> <span class="title">value</span> <span class="title">the</span> <span class="title">bb2</span> <span class="title">block</span> <span class="title">will</span> <span class="title">be</span> <span class="title">executed</span> <span class="title">before</span> <span class="title">jumping</span> </div><div class="line">    <span class="title">to</span> <span class="title">bb3</span>, <span class="title">if</span> <span class="title">it</span> <span class="title">doesn</span>'<span class="title">t</span> <span class="title">after</span> <span class="title">a</span> <span class="title">brief</span> <span class="title">jump</span> <span class="title">to</span> <span class="title">bb1</span>, <span class="title">the</span> <span class="title">function</span> <span class="title">will</span> <span class="title">proceed</span> <span class="title">to</span> <span class="title">bb3</span> <span class="title">releasing</span></div><div class="line">    <span class="title">the</span> <span class="title">retained</span> <span class="title">parameters</span>.</div><div class="line">    </div><div class="line">  */</div><div class="line">  %12 = <span class="title">load_weak</span> %3 : <span class="title">$</span>*@<span class="title">sil_weak</span> <span class="title">Optional</span>&lt;<span class="title">aClass</span>&gt;, <span class="title">loc</span> "<span class="title">sample</span>.<span class="title">swift</span>":11:18, <span class="title">scope</span> 18 // <span class="title">user</span>: %13</div><div class="line">  <span class="title">switch_enum</span> %12 : <span class="title">$Optional</span>&lt;<span class="title">aClass</span>&gt;, <span class="title">case</span> #<span class="title">Optional</span>.<span class="title">some</span>!<span class="title">enumelt</span>.1: <span class="title">bb2</span>, <span class="title">default</span> <span class="title">bb1</span>, <span class="title">loc</span> "<span class="title">sample</span>.<span class="title">swift</span>":11:18, <span class="title">scope</span> 18 // <span class="title">id</span>: %13</div><div class="line">  <span class="title">bb1</span>:                                              // <span class="title">Preds</span>: <span class="title">bb0</span></div><div class="line">  /*</div><div class="line">    跳转到闭包的结尾。</div><div class="line">  */</div><div class="line">  <span class="title">br</span> <span class="title">bb3</span>, <span class="title">loc</span> "<span class="title">sample</span>.<span class="title">swift</span>":11:18, <span class="title">scope</span> 16        // <span class="title">id</span>: %14</div><div class="line"></div><div class="line">// %15                                            // <span class="title">users</span>: %21, %20, %19, %16</div><div class="line"><span class="title">bb2</span>(%15 : <span class="title">$aClass</span>):                               // <span class="title">Preds</span>: <span class="title">bb0</span></div><div class="line">  /*</div><div class="line">    调用 <span class="title">aClass</span> 的 <span class="title">setter</span>，设置它的值为 42.</div><div class="line">  */</div><div class="line">  ...</div><div class="line">  %17 = <span class="title">integer_literal</span> <span class="title">$Builtin</span>.<span class="title">Int64</span>, 42, <span class="title">loc</span> "<span class="title">sample</span>.<span class="title">swift</span>":12:21, <span class="title">scope</span> 19 // <span class="title">user</span>: %18</div><div class="line">  %18 = <span class="title">struct</span> <span class="title">$Int</span> (%17 : <span class="title">$Builtin</span>.<span class="title">Int64</span>), <span class="title">loc</span> "<span class="title">sample</span>.<span class="title">swift</span>":12:21, <span class="title">scope</span> 19 // <span class="title">user</span>: %20</div><div class="line">  %19 = <span class="title">class_method</span> %15 : <span class="title">$aClass</span>, #<span class="title">aClass</span>.<span class="title">value</span>!<span class="title">setter</span>.1 : (<span class="title">aClass</span>) -&gt; (<span class="title">Int</span>) -&gt; () , <span class="title">$</span>@<span class="title">convention</span>(<span class="title">method</span>) (<span class="title">Int</span>, @<span class="title">guaranteed</span> <span class="title">aClass</span>) -&gt; (), <span class="title">loc</span> "<span class="title">sample</span>.<span class="title">swift</span>":12:19, <span class="title">scope</span> 19 // <span class="title">user</span>: %20</div><div class="line">  %20 = <span class="title">apply</span> %19(%18, %15) : <span class="title">$</span>@<span class="title">convention</span>(<span class="title">method</span>) (<span class="title">Int</span>, @<span class="title">guaranteed</span> <span class="title">aClass</span>) -&gt; (), <span class="title">loc</span> "<span class="title">sample</span>.<span class="title">swift</span>":12:19, <span class="title">scope</span> 19</div><div class="line">  <span class="title">strong_release</span> %15 : <span class="title">$aClass</span>, <span class="title">loc</span> "<span class="title">sample</span>.<span class="title">swift</span>":13:5, <span class="title">scope</span> 18 // <span class="title">id</span>: %21</div><div class="line">  <span class="title">br</span> <span class="title">bb3</span>, <span class="title">loc</span> "<span class="title">sample</span>.<span class="title">swift</span>":13:5, <span class="title">scope</span> 18         // <span class="title">id</span>: %22</div><div class="line"></div><div class="line"><span class="title">bb3</span>:                                              // <span class="title">Preds</span>: <span class="title">bb1</span> <span class="title">bb2</span></div><div class="line">  /*</div><div class="line">    释放所有获取的变量然后返回。</div><div class="line">  */</div><div class="line">  <span class="title">strong_release</span> %1 : <span class="title">$</span>@<span class="title">box</span> @<span class="title">sil_weak</span> <span class="title">Optional</span>&lt;<span class="title">aClass</span>&gt;, <span class="title">loc</span> "<span class="title">sample</span>.<span class="title">swift</span>":14:1, <span class="title">scope</span> 17 // <span class="title">id</span>: %23</div><div class="line">  <span class="title">unowned_release</span> %0 : <span class="title">$</span>@<span class="title">sil_unowned</span> <span class="title">aClass</span>, <span class="title">loc</span> "<span class="title">sample</span>.<span class="title">swift</span>":14:1, <span class="title">scope</span> 17 // <span class="title">id</span>: %24</div><div class="line">  %25 = <span class="title">tuple</span> (), <span class="title">loc</span> "<span class="title">sample</span>.<span class="title">swift</span>":14:1, <span class="title">scope</span> 17 // <span class="title">user</span>: %26</div><div class="line">  <span class="title">return</span> %25 : <span class="title">$</span>(), <span class="title">loc</span> "<span class="title">sample</span>.<span class="title">swift</span>":14:1, <span class="title">scope</span> 17 // <span class="title">id</span>: %26</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在这里，忽略掉不同的 ARC 指令带来的性能的差异点，对不同阶段每种类型的捕获变量做一个快速的对比：</p>
<table>
<thead>
<tr>
<th>动作</th>
<th>Unowned</th>
<th>Weak</th>
</tr>
</thead>
<tbody>
<tr>
<td>预先调用 #1</td>
<td>对象进行 unowned_retain</td>
<td>创建一个容器，并且对象进行 strong_retain 操作。创建一个可选值，存入到容器中，然后释放可选值</td>
</tr>
<tr>
<td>预先调用 #2</td>
<td>strong_retain_unowned，unowned_retain 和 strong_release</td>
<td>strong_retain</td>
</tr>
<tr>
<td>闭包执行</td>
<td>strong_retain_unowned，unowned_release</td>
<td>load_weak, 打开可选值, strong_release</td>
</tr>
<tr>
<td>调用之后</td>
<td>unowned_release</td>
<td>strong_release</td>
</tr>
</tbody>
</table>
<p>正如上面看到的 SIL 代码段那样，处理 weak 引用会涉及到更多的工作，因为需要处理引用需要的可选值。</p>
<p>参照官方文档的描述，这里对涉及到的所有 ARC 指令做一个简要的解释：</p>
<ul>
<li>unowned_retain：增加堆对象中的 unowned 引用计数。</li>
<li>strong_retain_unowned ：断言对象的强引用计数大于 0，然后增加这个引用计数。</li>
<li>strong_retain：增加对象的强引用计数。</li>
<li>load_weak：不是真正的 ARC 调用，但是它将增加可选值指向对象的强引用计数。</li>
<li>strong_release：减少对象的强引用计数。如果释放操作把对象强引用计数变为0，对象将被销毁，然后弱引用将被清除。当整个强引用计数和 unowned 引用计数都为0时，对象的内存才会被释放。</li>
<li>unowned_release：减少对象的 unowned 引用计数。当整个强引用计数和 unowned 引用计数都为 0 时，对象的内存才会被释放。</li>
</ul>
<p>接下来深入到 Swift 运行时看看，这些指令都是如何被实现的，相关的代码文件有：HeapObject.cpp，HeapObject.h，RefCount.h 和 Heap.cpp、 SwiftObject.mm 中的少量定义。容器实现可以在 MetadataImpl.h 找到，但是本文不展开讨论。</p>
<p>这些文件中定义大多数的 ARC 方法都有三种变体，一种是对 Swift 对象的基础实现，另外两种实现是针对非原生 Swift 对象的：桥接对象和未知对象。后面两种变体这里不予讨论。</p>
<p>第一个讨论指令集和 unowned 引用相关。</p>
<p>在 HeapObject.cpp 文件中间可以看到对 unowned_retain 和 unowned_release 的实现方法：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="type">SWIFT_RT_ENTRY_VISIBILITY</span></div><div class="line">void swift::swift_unownedRetain(<span class="type">HeapObject</span> *object)</div><div class="line">    <span class="type">SWIFT_CC</span>(<span class="type">RegisterPreservingCC_IMPL</span>) &#123;</div><div class="line">  <span class="keyword">if</span> (!object)</div><div class="line">    <span class="keyword">return</span>;</div><div class="line"></div><div class="line">  object-&gt;weakRefCount.increment();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="type">SWIFT_RT_ENTRY_VISIBILITY</span></div><div class="line">void swift::swift_unownedRelease(<span class="type">HeapObject</span> *object)</div><div class="line">    <span class="type">SWIFT_CC</span>(<span class="type">RegisterPreservingCC_IMPL</span>) &#123;</div><div class="line">  <span class="keyword">if</span> (!object)</div><div class="line">    <span class="keyword">return</span>;</div><div class="line"></div><div class="line">  <span class="keyword">if</span> (object-&gt;weakRefCount.decrementShouldDeallocate()) &#123;</div><div class="line">    <span class="comment">// Only class objects can be weak-retained and weak-released.</span></div><div class="line">    auto metadata = object-&gt;metadata;</div><div class="line">    <span class="built_in">assert</span>(metadata-&gt;isClassObject());</div><div class="line">    auto classMetadata = static_cast&lt;const <span class="type">ClassMetadata</span>*&gt;(metadata);</div><div class="line">    <span class="built_in">assert</span>(classMetadata-&gt;isTypeMetadata());</div><div class="line">    <span class="type">SWIFT_RT_ENTRY_CALL</span>(swift_slowDealloc)</div><div class="line">        (object, classMetadata-&gt;getInstanceSize(),</div><div class="line">         classMetadata-&gt;getInstanceAlignMask());</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>swift_unownedRetain 是 unowned_retain 的具体实现，简单地进行 unowned 引用计数的原子增加操作（这里定义为weakRefCount），swift_unownedRelease 更加复杂，原因之前也描述过，当没有其他 unowned 引用存在时，它需要执行对象的析构操作。</p>
<p>但是整体来讲都不复杂，在这里可以看到 doDecrementShouldDeallocate 方法，这个方法在上面代码中被一个命名类似的方法调用了。这个方法没有做太多，swift_slowDealloc 只是释放给定的指针。</p>
<p>到此已经有了一个对象的 unowned 引用，另外一个指令，strong_retain_unowned 用来创建一个强引用：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="type">SWIFT_RT_ENTRY_VISIBILITY</span></div><div class="line">void swift::swift_unownedRetainStrong(<span class="type">HeapObject</span> *object)</div><div class="line">    <span class="type">SWIFT_CC</span>(<span class="type">RegisterPreservingCC_IMPL</span>) &#123;</div><div class="line">  <span class="keyword">if</span> (!object)</div><div class="line">    <span class="keyword">return</span>;</div><div class="line">  <span class="built_in">assert</span>(object-&gt;weakRefCount.getCount() &amp;&amp;</div><div class="line">         <span class="string">"object is not currently weakly retained"</span>);</div><div class="line"></div><div class="line">  <span class="keyword">if</span> (! object-&gt;refCount.tryIncrement())</div><div class="line">    _swift_abortRetainUnowned(object);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>因为弱引用应该指向了这个对象，要使用断言来验证对象是否被弱引用，一旦断言通过，将尝试进行增加强引用计数的操作。一旦对象在进程中已经被释放，尝试将会失败。</p>
<p>所有类似于 tryIncrement 通过某种形式修改引用计数的方法都放到 RefCount.h 中，需要使用原子操作进行这些任务。</p>
<p>接下来讨论下 weak 引用的的实现，正如之前看到的那样，swift_weakLoadStrong 用来获取容器中可选值中强引用的对象。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="type">HeapObject</span> *swift::swift_weakLoadStrong(<span class="type">WeakReference</span> *ref) &#123;</div><div class="line">  <span class="keyword">if</span> (ref-&gt;<span class="type">Value</span> == (uintptr_t)nullptr) &#123;</div><div class="line">    <span class="keyword">return</span> nullptr;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">// ref 可能被其他线程访问</span></div><div class="line">  auto ptr = __atomic_fetch_or(&amp;ref-&gt;<span class="type">Value</span>, <span class="type">WR_READING</span>, __ATOMIC_RELAXED);</div><div class="line">  <span class="keyword">while</span> (ptr &amp; <span class="type">WR_READING</span>) &#123;</div><div class="line">    short <span class="built_in">c</span> = <span class="number">0</span>;</div><div class="line">    <span class="keyword">while</span> (__atomic_load_n(&amp;ref-&gt;<span class="type">Value</span>, __ATOMIC_RELAXED) &amp; <span class="type">WR_READING</span>) &#123;</div><div class="line">      <span class="keyword">if</span> (++<span class="built_in">c</span> == <span class="type">WR_SPINLIMIT</span>) &#123;</div><div class="line">        std::this_thread::yield();</div><div class="line">        <span class="built_in">c</span> -= <span class="number">1</span>;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">    ptr = __atomic_fetch_or(&amp;ref-&gt;<span class="type">Value</span>, <span class="type">WR_READING</span>, __ATOMIC_RELAXED);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  auto object = (<span class="type">HeapObject</span>*)(ptr &amp; ~<span class="type">WR_NATIVE</span>);</div><div class="line">  <span class="keyword">if</span> (object == nullptr) &#123;</div><div class="line">    __atomic_store_n(&amp;ref-&gt;<span class="type">Value</span>, (uintptr_t)nullptr, __ATOMIC_RELAXED);</div><div class="line">    <span class="keyword">return</span> nullptr;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">if</span> (object-&gt;refCount.isDeallocating()) &#123;</div><div class="line">    __atomic_store_n(&amp;ref-&gt;<span class="type">Value</span>, (uintptr_t)nullptr, __ATOMIC_RELAXED);</div><div class="line">    <span class="type">SWIFT_RT_ENTRY_CALL</span>(swift_unownedRelease)(object);</div><div class="line">    <span class="keyword">return</span> nullptr;</div><div class="line">  &#125;</div><div class="line">  auto result = swift_tryRetain(object);</div><div class="line">  __atomic_store_n(&amp;ref-&gt;<span class="type">Value</span>, ptr, __ATOMIC_RELAXED);</div><div class="line">  <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在这个实现中，获取一个强引用需要更多复杂同步操作，在多线程竞争严重的情况下，会带来性能损耗。</p>
<p>在这里第一次出现的 WeakReference 对象，是一个简单的结构体，包含一个整型值字段指向目标对象，目标对象是使用 HeapObject 类来承载的每一个运行时的 Swift 对象。</p>
<p>在 weak 引用询问当前线程设置的 WR_READING 标识之后，从 WeakReference 容器中获取 Swift 对象，如果对象不再有效，或者在等待获取资源时，它变成可以进行析构，当前的引用会被设置为 null。</p>
<p>如果对象依然有效，获取对象的尝试将会成功。</p>
<p>因此，从这个角度来讲，对 weak 引用的常规操作性能比 unowned 引用的更低（但是主要的问题还是在可选值操作上面）。</p>
<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>保守的使用 weak 引用是否明智呢？答案是否定的，无论是从性能的角度还是代码清晰的角度而言。</p>
<p>使用正确的捕获修饰符类型，明确的表明代码中的生命周期特性，当其他人或者你自己在读你的代码时不容易误解。</p>
<h2 id="脚注"><a href="#脚注" class="headerlink" title="脚注"></a>脚注</h2><p>1、苹果第一次讨论 weak/unowned 争议可以查看这里，之后在 twitter 上 Joe Groff 对此也进行了讨论，并且被 Michael Tsai 总结成文。<br>这篇文章从意图角度出发，提供了完整并且可操作的解释。</p>
<p>2、从维基百科中可以找到关于 AST 的解释，还可以从 Slava Pestov 的这篇文章中看到关于 Swift 编译器中如何实现 AST 的一些细节。</p>
<p>3、关于 SIL 的更多信息，请查看详尽的官方 SIL 指南，还有 2015 LLVM 开发者会议的视频。Lex Chou 写的 SIL 快速指南可以点击这里查看。</p>
<p>4、查看在 Swift 中如何进行名称粉碎（name mangling）的细节，请查看 Lex Chou 的这篇文章。</p>
<p>5、Mike Ash 在他的 Friday Q&amp;A 中的一篇文章中讨论了如何实现 weak 引用的一种实践方法，这种方法与目前 Swift 的方法对比起来有一些过时，但是其中的解释依然值得参考。</p>
<blockquote>
<p>本文由 SwiftGG 翻译组翻译，已经获得作者翻译授权，最新文章请访问 <a href="http://swift.gg。" target="_blank" rel="external">http://swift.gg。</a></p>
</blockquote>
<hr>
<p>文章转自 <a href="http://swift.gg/2017/05/16/unowned-or-weak-lifetime-and-performance/" target="_blank" rel="external">SwiftGG</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;作者：Umberto Raimondi，原文链接，原文日期：2016-10-27&lt;br&gt;译者：shanks；校对：Crystal Sun；定稿：CMB&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;每当处理循环引用（retain cycles）时，需要考量对象生命周期来选择unowned或者weak标识符，这已经成为了一个共识。但是有时仍然会心存疑问，在具体的使用中应该选择哪一个，或者退一步讲，保守的只使用 weak 是不是一个好的选择呢？&lt;/p&gt;
&lt;p&gt;本文首先对循环引用的基础知识做一个简要介绍，然后会分析 Swift 源代码的一些片段，讲解 unowned 和 weak 在生命周期和性能上的差异点，希望看完本文以后，在的使用场景中，能使用正确的弱引用类型。&lt;/p&gt;
    
    </summary>
    
      <category term="iOS" scheme="https://madordie.github.io/categories/iOS/"/>
    
    
      <category term="Unowned与Weak" scheme="https://madordie.github.io/tags/Unowned%E4%B8%8EWeak/"/>
    
  </entry>
  
  <entry>
    <title>侧滑导航栏消失问题笔记</title>
    <link href="https://madordie.github.io/push-pop-navigation-bar-hidden/"/>
    <id>https://madordie.github.io/push-pop-navigation-bar-hidden/</id>
    <published>2017-05-16T04:16:47.000Z</published>
    <updated>2017-08-14T02:02:25.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>如果前页面和后页面不同，则会出现轻微侧滑时导航栏莫名其妙没了😂</p>
<p><a href="https://github.com/madordie/Demo-PushAndPop" target="_blank" rel="external">Demo-PushAndPop</a></p>
<a id="more"></a>
<h2 id="Demo-PushAndPop"><a href="#Demo-PushAndPop" class="headerlink" title="Demo-PushAndPop"></a>Demo-PushAndPop</h2><p>[已解决] 隐藏导航栏+改变状态栏样式时出现导航栏莫名其妙没了</p>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p><img src="https://github.com/madordie/Demo-PushAndPop/blob/master/Untitled.gif?raw=true" alt="snapshot"></p>
<p>当<code>ViewController.swift</code>实现<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">override</span> <span class="keyword">var</span> preferredStatusBarStyle: <span class="type">UIStatusBarStyle</span> &#123;</div><div class="line">    <span class="keyword">return</span> .lightContent</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>时，两个<code>ViewController</code>对应的<code>UIStatusBarStyle</code>不同，则会出现如上图。<code>UIStatusBarStyle</code>一致则正常。</p>
<h2 id="解决关键"><a href="#解决关键" class="headerlink" title="解决关键"></a>解决关键</h2><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">NavigationController</span>: <span class="title">UINavigationController</span> </span>&#123;</div><div class="line">    <span class="keyword">override</span> <span class="keyword">var</span> childViewControllerForStatusBarStyle: <span class="type">UIViewController</span>? &#123;</div><div class="line">        <span class="keyword">return</span> topViewController</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>只需要将<code>childViewControllerForStatusBarStyle</code>设置为<code>UINavigationController.topViewController</code>即可。</p>
<h2 id="另外"><a href="#另外" class="headerlink" title="另外"></a>另外</h2><p>附上<code>BViewController</code>中相关代码。在切换的两个<code>UIViewController</code>的<code>preferredStatusBarStyle</code>一样时，不需要设置<code>UINavigationController.childViewControllerForStatusBarStyle</code>。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">BViewController</span>: <span class="title">UIViewController</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">var</span> navigationBarHidden = <span class="literal">false</span></div><div class="line"></div><div class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewWillAppear</span><span class="params">(<span class="number">_</span> animated: Bool)</span></span> &#123;</div><div class="line">        <span class="keyword">super</span>.viewWillAppear(animated)</div><div class="line"></div><div class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> navigationController = navigationController  <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">return</span></div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> navigationController.isNavigationBarHidden != navigationBarHidden &#123;</div><div class="line">            navigationController.setNavigationBarHidden(navigationBarHidden, animated: animated)</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewWillDisappear</span><span class="params">(<span class="number">_</span> animated: Bool)</span></span> &#123;</div><div class="line">        <span class="keyword">super</span>.viewWillDisappear(animated)</div><div class="line"></div><div class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> navigationController = navigationController  <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">return</span></div><div class="line">        &#125;</div><div class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> last = navigationController.viewControllers.last <span class="keyword">as</span>? <span class="type">BViewController</span> <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">return</span></div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> last.navigationBarHidden != navigationBarHidden &#123;</div><div class="line">            navigationController.setNavigationBarHidden(last.navigationBarHidden, animated: animated)</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="感谢"><a href="#感谢" class="headerlink" title="感谢"></a>感谢</h2><ul>
<li>@木头 <code>viewWillAppear</code>更换为<code>viewDidAppear</code>然后调试，在Demo中测试也可以曲线救国。</li>
<li>@Harry 提供的终极大法～</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;如果前页面和后页面不同，则会出现轻微侧滑时导航栏莫名其妙没了😂&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/madordie/Demo-PushAndPop&quot;&gt;Demo-PushAndPop&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="iOS" scheme="https://madordie.github.io/categories/iOS/"/>
    
    
      <category term="Debug" scheme="https://madordie.github.io/tags/Debug/"/>
    
  </entry>
  
  <entry>
    <title>「转」iOS图片加载速度极限优化—FastImageCache解析</title>
    <link href="https://madordie.github.io/bang-fastimagecache/"/>
    <id>https://madordie.github.io/bang-fastimagecache/</id>
    <published>2017-05-16T02:55:00.000Z</published>
    <updated>2017-08-14T02:20:29.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>原文：<a href="http://blog.cnbang.net/tech/2578/" target="_blank" rel="external">iOS图片加载速度极限优化—FastImageCache解析</a></p>
<p><a href="https://github.com/path/FastImageCache" target="_blank" rel="external">FastImageCache</a>是Path团队开发的一个开源库，用于提升图片的加载和渲染速度，让基于图片的列表滑动起来更顺畅，来看看它是怎么做的。</p>
<a id="more"></a>
<h2 id="优化点"><a href="#优化点" class="headerlink" title="优化点"></a>优化点</h2><p>iOS从磁盘加载一张图片，使用UIImageVIew显示在屏幕上，需要经过以下步骤：</p>
<ol>
<li>从磁盘拷贝数据到内核缓冲区</li>
<li>从内核缓冲区复制数据到用户空间</li>
<li>生成UIImageView，把图像数据赋值给UIImageView</li>
<li>如果图像数据为未解码的PNG/JPG，解码为位图数据</li>
<li>CATransaction捕获到UIImageView layer树的变化</li>
<li>主线程Runloop提交CATransaction，开始进行图像渲染<br> 6.1 如果数据没有字节对齐，Core Animation会再拷贝一份数据，进行字节对齐。<br> 6.2 GPU处理位图数据，进行渲染。</li>
</ol>
<p>FastImageCache分别优化了2,4,6.1三个步骤：</p>
<ol>
<li>使用mmap内存映射，省去了上述第2步数据从内核空间拷贝到用户空间的操作。</li>
<li>缓存解码后的位图数据到磁盘，下次从磁盘读取时省去第4步解码的操作。</li>
<li>生成字节对齐的数据，防止上述第6.1步CoreAnimation在渲染时再拷贝一份数据。</li>
</ol>
<p>接下来具体介绍这三个优化点以及它的实现。</p>
<h3 id="内存映射"><a href="#内存映射" class="headerlink" title="内存映射"></a>内存映射</h3><p>平常我们读取磁盘上的一个文件，上层API调用到最后会使用系统方法read()读取数据，内核把磁盘数据读入内核缓冲区，用户再从内核缓冲区读取数据复制到用户内存空间，这里有一次内存拷贝的时间消耗，并且读取后整个文件数据就已经存在于用户内存中，占用了进程的内存空间。</p>
<p>FastImageCache采用了另一种读写文件的方法，就是用mmap把文件映射到用户空间里的虚拟内存，文件中的位置在虚拟内存中有了对应的地址，可以像操作内存一样操作这个文件，相当于已经把整个文件放入内存，但在真正使用到这些数据前却不会消耗物理内存，也不会有读写磁盘的操作，只有真正使用这些数据时，也就是图像准备渲染在屏幕上时，虚拟内存管理系统VMS才根据缺页加载的机制从磁盘加载对应的数据块到物理内存，再进行渲染。这样的文件读写文件方式少了数据从内核缓存到用户空间的拷贝，效率很高。</p>
<h3 id="解码图像"><a href="#解码图像" class="headerlink" title="解码图像"></a>解码图像</h3><p>一般我们使用的图像是JPG/PNG，这些图像数据不是位图，而是是经过编码压缩后的数据，使用它渲染到屏幕之前需要进行解码转成位图数据，这个解码操作是比较耗时的，并且没有GPU硬解码，只能通过CPU，iOS默认会在主线程对图像进行解码。很多库都解决了图像解码的问题，不过由于解码后的图像太大，一般不会缓存到磁盘，SDWebImage的做法是把解码操作从主线程移到子线程，让耗时的解码操作不占用主线程的时间。</p>
<p>FastImageCache也是在子线程解码图像，不同的是它会缓存解码后的图像到磁盘。因为解码后的图像体积很大，FastImageCache对这些图像数据做了系列缓存管理，详见下文实现部分。另外缓存的图像体积大也是使用内存映射读取文件的原因，小文件使用内存映射无优势，内存拷贝的量少，拷贝后占用用户内存也不高，文件越大内存映射优势越大。</p>
<h3 id="字节对齐"><a href="#字节对齐" class="headerlink" title="字节对齐"></a>字节对齐</h3><p>Core Animation在图像数据非字节对齐的情况下渲染前会先拷贝一份图像数据，官方文档没有对这次拷贝行为作说明，模拟器和Instrument里有高亮显示“copied images”的功能，但似乎它有bug，即使某张图片没有被高亮显示出渲染时被copy，从调用堆栈上也还是能看到调用了CA::Render::copy_image方法：</p>
<p><img src="/images/fastImageCache1.png" alt="fastImageCache1"></p>
<p>那什么是字节对齐呢，按我的理解，为了性能，底层渲染图像时不是一个像素一个像素渲染，而是一块一块渲染，数据是一块块地取，就可能遇到这一块连续的内存数据里结尾的数据不是图像的内容，是内存里其他的数据，可能越界读取导致一些奇怪的东西混入，所以在渲染之前CoreAnimation要把数据拷贝一份进行处理，确保每一块都是图像数据，对于不足一块的数据置空。大致图示：(pixel是图像像素数据，data是内存里其他数据)</p>
<p><img src="/images/fastImageCache2.png" alt="fastImageCache2"></p>
<p>块的大小应该是跟CPU cache line有关，ARMv7是32byte，A9是64byte，在A9下CoreAnimation应该是按64byte作为一块数据去读取和渲染，让图像数据对齐64byte就可以避免CoreAnimation再拷贝一份数据进行修补。FastImageCache做的字节对齐就是这个事情。</p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>FastImageCache把同个类型和尺寸的图像都放在一个文件里，根据文件偏移取单张图片，类似web的css雪碧图，这里称为ImageTable。这样做主要是为了方便统一管理图片缓存，控制缓存的大小，整个FastImageCache就是在管理一个个ImageTable的数据。整体实现的数据结构如图：</p>
<p><img src="/images/fastImageCache3.png" alt="fastImageCache3"></p>
<p>一些补充和说明：</p>
<h3 id="ImageTable"><a href="#ImageTable" class="headerlink" title="ImageTable"></a>ImageTable</h3><ol>
<li>一个ImageFormat对应一个ImageTable，ImageFormat指定了ImageTable里图像渲染格式/大小等信息，ImageTable里的图像数据都由ImageFormat规定了统一的尺寸，每张图像大小都是一样的。</li>
<li>一个ImageTable一个实体文件，并有另一个文件保存这个ImageTable的meta信息。</li>
<li>图像使用entityUUID作为唯一标示符，由用户定义，通常是图像url的hash值。ImageTable Meta的indexMap记录了entityUUID-&gt;entryIndex的映射，通过indexMap就可以用图像的entityUUID找到缓存数据在ImageTable对应的位置。</li>
</ol>
<h3 id="ImageTableEntry"><a href="#ImageTableEntry" class="headerlink" title="ImageTableEntry"></a>ImageTableEntry</h3><ol>
<li>ImageTable的实体数据是ImageTableEntry，每个entry有两部分数据，一部分是对齐后的图像数据，另一部分是meta信息，meta保存这张图像的UUID和原图UUID，用于校验图像数据的正确性。</li>
<li>Entry数据是按内存分页大小对齐的，数据大小是内存分页大小的整数倍，这样可以保证虚拟内存缺页加载时使用最少的内存页加载一张图像。</li>
<li>图像数据做了字节对齐处理，CoreAnimation使用时无需再处理拷贝。具体做法是CGBitmapContextCreate创建位图画布时bytesPerRow参数传64倍数。</li>
</ol>
<h3 id="Chunk"><a href="#Chunk" class="headerlink" title="Chunk"></a>Chunk</h3><ul>
<li>ImageTable和实体数据Entry间多了层Chunk，Chunk是逻辑上的数据划分，N个Entry作为一个Chunk，内存映射mmap操作是以chunk为单位的，每一个chunk执行一次mmap把这个chunk的内容映射到虚拟内存。为什么要多一层chunk呢，按我的理解，这样做是为了灵活控制mmap的大小和调用次数，若对整个ImageTable执行mmap，载入虚拟内存的文件过大，若对每个Entry做mmap，调用次数会太多。</li>
</ul>
<h3 id="缓存管理"><a href="#缓存管理" class="headerlink" title="缓存管理"></a>缓存管理</h3><ul>
<li>用户可以定义整个ImageTable里最大缓存的图像数量，在有新图像需要缓存时，如果缓存没有超过限制，会以chunk为单位扩展文件大小，顺序写下去。如果已超过最大缓存限制，会把最少使用的缓存替换掉，实现方法是每次使用图像都会把UUID插入到MRUEntries数组的开头，MRUEntries按最近使用顺序排列了图像UUID，数组里最后一个图像就是最少使用的。被替换掉的图片下次需要再使用时，再走一次取原图—解压—存储的流程。</li>
</ul>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>FastImageCache适合用于tableView里缓存每个cell上同样规格的图像，优点是能极大加快第一次从磁盘加载这些图像的速度。但它有两个明显的缺点：一是占空间大。因为缓存了解码后的位图到磁盘，位图是很大的，宽高100<em>100的图像在2x的高清屏设备下就需要200</em>200*4byte/pixel=156KB，这也是为什么FastImageCache要大费周章限制缓存大小。二是接口不友好，需预定义好缓存的图像尺寸。FastImageCache无法像SDWebImage那样无缝接入UIImageView，使用它需要配置ImageTable，定义好尺寸，手动提供的原图，每种实体图像要定义一个FICEntity模型，使逻辑变复杂。</p>
<p>FastImageCache已经属于极限优化，做图像加载/渲染优化时应该优先考虑一些低代价高回报的优化点，例如CALayer代替UIImageVIew，减少GPU计算（去透明/像素对齐），图像子线程解码，避免Offscreen-Render等。在其他优化都做到位，图像的渲染还是有性能问题的前提下才考虑使用FastImageCache进一步提升首次加载的性能，不过字节对齐的优化倒是可以脱离FastImageCache直接运用在项目上，只需要在解码图像时bitmap画布的bytesPerRow设为64的倍数即可。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;原文：&lt;a href=&quot;http://blog.cnbang.net/tech/2578/&quot;&gt;iOS图片加载速度极限优化—FastImageCache解析&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/path/FastImageCache&quot;&gt;FastImageCache&lt;/a&gt;是Path团队开发的一个开源库，用于提升图片的加载和渲染速度，让基于图片的列表滑动起来更顺畅，来看看它是怎么做的。&lt;/p&gt;
    
    </summary>
    
      <category term="iOS" scheme="https://madordie.github.io/categories/iOS/"/>
    
    
      <category term="FastImageCache" scheme="https://madordie.github.io/tags/FastImageCache/"/>
    
  </entry>
  
  <entry>
    <title>debug-_SwiftValue-unsignedIntegerValue</title>
    <link href="https://madordie.github.io/debug-SwiftValue-unsignedIntegerValue/"/>
    <id>https://madordie.github.io/debug-SwiftValue-unsignedIntegerValue/</id>
    <published>2017-04-17T06:05:09.000Z</published>
    <updated>2017-08-14T01:59:55.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>crash:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">let attr = try? NSMutableAttributedString(data: data,</div><div class="line">                                          options: [NSDocumentTypeDocumentAttribute: NSHTMLTextDocumentType,</div><div class="line">                                                    NSCharacterEncodingDocumentAttribute: String.Encoding.utf8],</div><div class="line">                                          documentAttributes:nil)</div><div class="line">// log:</div><div class="line">2017-04-17 14:04:38.140 [41275:463875] -[_SwiftValue unsignedIntegerValue]: unrecognized selector sent to instance 0x608000256620</div></pre></td></tr></table></figure></p>
<a id="more"></a>
<p>WTF! 这个方法启动时不能直接调用，要异步？</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;crash:&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;let attr = try? NSMutableAttributedString(data: data,&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                                          options: [NSDocumentTypeDocumentAttribute: NSHTMLTextDocumentType,&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                                                    NSCharacterEncodingDocumentAttribute: String.Encoding.utf8],&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                                          documentAttributes:nil)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;// log:&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2017-04-17 14:04:38.140 [41275:463875] -[_SwiftValue unsignedIntegerValue]: unrecognized selector sent to instance 0x608000256620&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="iOS" scheme="https://madordie.github.io/categories/iOS/"/>
    
    
      <category term="Debug" scheme="https://madordie.github.io/tags/Debug/"/>
    
  </entry>
  
  <entry>
    <title>RxSwift语法笔记</title>
    <link href="https://madordie.github.io/rx-dictionary/"/>
    <id>https://madordie.github.io/rx-dictionary/</id>
    <published>2017-04-08T06:03:18.000Z</published>
    <updated>2017-08-14T02:15:02.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>记录RxSwift在使用过程中的一些常用语法。</p>
<a id="more"></a>
<h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>按照<a href="https://blog.callmewhy.com/2015/09/21/rxswift-getting-started-0/" target="_blank" rel="external">RxSwift 入坑手册 Part0 - 基础概念</a>格式进行补充。</p>
<h2 id="SupportCode"><a href="#SupportCode" class="headerlink" title="SupportCode"></a>SupportCode</h2><p>在进入正题之前，先看下项目里的 <code>SupportCode.swift</code> ，主要为 <code>playground</code> 提供了两个便利函数。</p>
<p>一个是 <code>example</code> 函数，专门用来写示例代码的，统一输出 log 便于标记浏览，同时还能保持变量不污染全局：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">example</span><span class="params">(description: String, action: <span class="params">()</span></span></span> -&gt; ()) &#123;</div><div class="line">    <span class="built_in">print</span>(<span class="string">"\n--- <span class="subst">\(description)</span> example ---"</span>)</div><div class="line">    action()</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>另一个是 <code>delay</code> 函数，通过 <code>dispatch_after</code> 用来演示延时的：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">delay</span><span class="params">(delay:Double, closure:<span class="params">()</span></span></span>-&gt;()) &#123;</div><div class="line">    dispatch_after(</div><div class="line">        dispatch_time(</div><div class="line">            <span class="type">DISPATCH_TIME_NOW</span>,</div><div class="line">            <span class="type">Int64</span>(delay * <span class="type">Double</span>(<span class="type">NSEC_PER_SEC</span>))</div><div class="line">        ),</div><div class="line">        dispatch_get_main_queue(), closure)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>主要介绍了 Rx 的基础： <code>Observable</code> 。 <code>Observable&lt;Element&gt;</code> 是观察者模式中被观察的对象，相当于一个事件序列 (<code>GeneratorType</code>) ，会向订阅者发送新产生的事件信息。事件信息分为三种：</p>
<ul>
<li>Next(value) 表示新的事件数据。</li>
<li>Completed 表示事件序列的完结。</li>
<li>Error 同样表示完结，但是代表异常导致的完结。<br>（打个岔：协议命名，想起来上午汤哥在微博说的一段话：</li>
</ul>
<blockquote>
<p>另外，我觉得 protocol 名字用形容词会更加语义分明，比如 Swift : Flyable, Killable, Visible。全用名词的话显得比较生硬，比如 Swift : Head, Wings, Ass。</p>
</blockquote>
<h3 id="empty"><a href="#empty" class="headerlink" title="empty"></a>empty</h3><p><code>empty</code> 是一个空的序列，它只发送 <code>.Completed</code> 消息。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">example(<span class="string">"empty"</span>) &#123;</div><div class="line">    <span class="keyword">let</span> emptySequence: <span class="type">Observable</span>&lt;<span class="type">Int</span>&gt; = empty()</div><div class="line">    <span class="keyword">let</span> subscription = emptySequence</div><div class="line">        .subscribe &#123; event <span class="keyword">in</span></div><div class="line">            <span class="built_in">print</span>(event)</div><div class="line">        &#125;</div><div class="line">&#125;</div><div class="line">--- empty example ---</div><div class="line"><span class="type">Completed</span></div></pre></td></tr></table></figure>
<h3 id="never"><a href="#never" class="headerlink" title="never"></a>never</h3><p><code>never</code> 是没有任何元素、也不会发送任何事件的空序列。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">example(<span class="string">"never"</span>) &#123;</div><div class="line">    <span class="keyword">let</span> neverSequence: <span class="type">Observable</span>&lt;<span class="type">String</span>&gt; = never()</div><div class="line">    <span class="keyword">let</span> subscription = neverSequence</div><div class="line">        .subscribe &#123; <span class="number">_</span> <span class="keyword">in</span></div><div class="line">            <span class="built_in">print</span>(<span class="string">"This block is never called."</span>)</div><div class="line">        &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">--- never example ---</div></pre></td></tr></table></figure>
<h3 id="just"><a href="#just" class="headerlink" title="just"></a>just</h3><p><code>just</code> 是只包含一个元素的序列，它会先发送 <code>.Next(value)</code> ，然后发送 <code>.Completed</code> 。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">example(<span class="string">"just"</span>) &#123;</div><div class="line">    <span class="keyword">let</span> singleElementSequence = just(<span class="number">32</span>)</div><div class="line">    <span class="keyword">let</span> subscription = singleElementSequence</div><div class="line">        .subscribe &#123; event <span class="keyword">in</span></div><div class="line">            <span class="built_in">print</span>(event)</div><div class="line">        &#125;</div><div class="line">&#125;</div><div class="line">--- just example ---</div><div class="line"><span class="type">Next</span>(<span class="number">32</span>)</div><div class="line"><span class="type">Completed</span></div><div class="line">sequenceOf</div></pre></td></tr></table></figure>
<p><code>sequenceOf</code> 可以把一系列元素转换成事件序列。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">example(<span class="string">"sequenceOf"</span>) &#123;</div><div class="line">    <span class="keyword">let</span> sequenceOfElements<span class="comment">/* : Observable&lt;Int&gt; */</span> = sequenceOf(<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</div><div class="line">    <span class="keyword">let</span> subscription = sequenceOfElements</div><div class="line">        .subscribe &#123; event <span class="keyword">in</span></div><div class="line">            <span class="built_in">print</span>(event)</div><div class="line">        &#125;</div><div class="line">&#125;</div><div class="line">--- sequenceOf example ---</div><div class="line"><span class="type">Next</span>(<span class="number">0</span>)</div><div class="line"><span class="type">Next</span>(<span class="number">1</span>)</div><div class="line"><span class="type">Next</span>(<span class="number">2</span>)</div><div class="line"><span class="type">Next</span>(<span class="number">3</span>)</div><div class="line"><span class="type">Completed</span></div><div class="line">from</div></pre></td></tr></table></figure>
<p><code>from</code> 是通过 <code>asObservable()</code> 方法把 Swift 中的序列 (<code>SequenceType</code>) 转换成事件序列。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">example(<span class="string">"from"</span>) &#123;</div><div class="line">    <span class="keyword">let</span> sequenceFromArray = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>].asObservable()</div><div class="line">    <span class="keyword">let</span> subscription = sequenceFromArray</div><div class="line">        .subscribe &#123; event <span class="keyword">in</span></div><div class="line">            <span class="built_in">print</span>(event)</div><div class="line">        &#125;</div><div class="line">&#125;</div><div class="line">--- from example ---</div><div class="line"><span class="type">Next</span>(<span class="number">1</span>)</div><div class="line"><span class="type">Next</span>(<span class="number">2</span>)</div><div class="line"><span class="type">Next</span>(<span class="number">3</span>)</div><div class="line"><span class="type">Next</span>(<span class="number">4</span>)</div><div class="line"><span class="type">Next</span>(<span class="number">5</span>)</div><div class="line"><span class="type">Completed</span></div></pre></td></tr></table></figure>
<h3 id="create"><a href="#create" class="headerlink" title="create"></a>create</h3><p><code>create</code> 可以通过闭包创建序列，通过 <code>.on(e: Event)</code> 添加事件。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">example(<span class="string">"create"</span>) &#123;</div><div class="line">    <span class="keyword">let</span> myJust = &#123; (singleElement: <span class="type">Int</span>) -&gt; <span class="type">Observable</span>&lt;<span class="type">Int</span>&gt; <span class="keyword">in</span></div><div class="line">        <span class="keyword">return</span> create &#123; observer <span class="keyword">in</span></div><div class="line">            observer.on(.<span class="type">Next</span>(singleElement))</div><div class="line">            observer.on(.<span class="type">Completed</span>)</div><div class="line">            <span class="keyword">return</span> <span class="type">NopDisposable</span>.instance</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">let</span> subscription = myJust(<span class="number">5</span>)</div><div class="line">        .subscribe &#123; event <span class="keyword">in</span></div><div class="line">            <span class="built_in">print</span>(event)</div><div class="line">        &#125;</div><div class="line">&#125;</div><div class="line">--- create example ---</div><div class="line"><span class="type">Next</span>(<span class="number">5</span>)</div><div class="line"><span class="type">Completed</span></div></pre></td></tr></table></figure>
<h3 id="failWith"><a href="#failWith" class="headerlink" title="failWith"></a>failWith</h3><p><code>failWith</code> 创建一个没有元素的序列，只会发送失败 (<code>.Error</code>) 事件。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">example(<span class="string">"failWith"</span>) &#123;</div><div class="line">    <span class="keyword">let</span> error = <span class="type">NSError</span>(domain: <span class="string">"Test"</span>, code: -<span class="number">1</span>, userInfo: <span class="literal">nil</span>)</div><div class="line">    <span class="keyword">let</span> erroredSequence: <span class="type">Observable</span>&lt;<span class="type">Int</span>&gt; = failWith(error)</div><div class="line">    <span class="keyword">let</span> subscription = erroredSequence</div><div class="line">        .subscribe &#123; event <span class="keyword">in</span></div><div class="line">            <span class="built_in">print</span>(event)</div><div class="line">        &#125;</div><div class="line">&#125;</div><div class="line">--- failWith example ---</div><div class="line"><span class="type">Error</span>(<span class="type">Error</span> <span class="type">Domain</span>=<span class="type">Test</span> <span class="type">Code</span>=-<span class="number">1</span> <span class="string">"The operation couldn’t be completed. (Test error -1.)"</span>)</div></pre></td></tr></table></figure>
<h3 id="deferred"><a href="#deferred" class="headerlink" title="deferred"></a>deferred</h3><p><code>deferred</code> 会等到有订阅者的时候再通过工厂方法创建 <code>Observable</code> 对象，每个订阅者订阅的对象都是内容相同而完全独立的序列。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">example(<span class="string">"deferred"</span>) &#123;</div><div class="line">    <span class="keyword">let</span> deferredSequence: <span class="type">Observable</span>&lt;<span class="type">Int</span>&gt; = deferred &#123;</div><div class="line">        <span class="built_in">print</span>(<span class="string">"creating"</span>)</div><div class="line">        <span class="keyword">return</span> create &#123; observer <span class="keyword">in</span></div><div class="line">            <span class="built_in">print</span>(<span class="string">"emmiting"</span>)</div><div class="line">            observer.on(.<span class="type">Next</span>(<span class="number">0</span>))</div><div class="line">            observer.on(.<span class="type">Next</span>(<span class="number">1</span>))</div><div class="line">            observer.on(.<span class="type">Next</span>(<span class="number">2</span>))</div><div class="line">            <span class="keyword">return</span> <span class="type">NopDisposable</span>.instance</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">print</span>(<span class="string">"go"</span>)</div><div class="line">    deferredSequence</div><div class="line">        .subscribe &#123; event <span class="keyword">in</span></div><div class="line">            <span class="built_in">print</span>(event)</div><div class="line">    &#125;</div><div class="line">    deferredSequence</div><div class="line">        .subscribe &#123; event <span class="keyword">in</span></div><div class="line">            <span class="built_in">print</span>(event)</div><div class="line">        &#125;</div><div class="line">&#125;</div><div class="line">--- deferred example ---</div><div class="line">go</div><div class="line">creating</div><div class="line">emmiting</div><div class="line"><span class="type">Next</span>(<span class="number">0</span>)</div><div class="line"><span class="type">Next</span>(<span class="number">1</span>)</div><div class="line"><span class="type">Next</span>(<span class="number">2</span>)</div><div class="line">creating</div><div class="line">emmiting</div><div class="line"><span class="type">Next</span>(<span class="number">0</span>)</div><div class="line"><span class="type">Next</span>(<span class="number">1</span>)</div><div class="line"><span class="type">Next</span>(<span class="number">2</span>)</div></pre></td></tr></table></figure>
<p>为什么需要 <code>defferd</code> 这样一个奇怪的家伙呢？其实这相当于是一种延时加载，因为在添加监听的时候数据未必加载完毕，例如下面这个例子：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">example(<span class="string">"TestDeferred"</span>) &#123;</div><div class="line">    <span class="keyword">var</span> value: <span class="type">String</span>? = <span class="literal">nil</span></div><div class="line">    <span class="keyword">var</span> subscription: <span class="type">Observable</span>&lt;<span class="type">String</span>?&gt; = just(value)</div><div class="line">    <span class="comment">// got value</span></div><div class="line">    value = <span class="string">"Hello!"</span></div><div class="line">    subscription.subscribe &#123; event <span class="keyword">in</span></div><div class="line">        <span class="built_in">print</span>(event)</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">--- <span class="type">TestDeferred</span> example ---</div><div class="line"><span class="type">Next</span>(<span class="literal">nil</span>)</div><div class="line"><span class="type">Completed</span></div></pre></td></tr></table></figure>
<p>如果使用 <code>deffered</code> 则可以正常显示想要的数据：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">example(<span class="string">"TestDeferred"</span>) &#123;</div><div class="line">    <span class="keyword">var</span> value: <span class="type">String</span>? = <span class="literal">nil</span></div><div class="line">    <span class="keyword">var</span> subscription: <span class="type">Observable</span>&lt;<span class="type">String</span>?&gt; = deferred &#123;</div><div class="line">        <span class="keyword">return</span> just(value)</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// got value</span></div><div class="line">    value = <span class="string">"Hello!"</span></div><div class="line">    subscription.subscribe &#123; event <span class="keyword">in</span></div><div class="line">        <span class="built_in">print</span>(event)</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">--- <span class="type">TestDeferred</span> example ---</div><div class="line"><span class="type">Next</span>(<span class="type">Optional</span>(<span class="string">"Hello!"</span>))</div><div class="line"><span class="type">Completed</span></div></pre></td></tr></table></figure>
<h2 id="Subjects"><a href="#Subjects" class="headerlink" title="Subjects"></a>Subjects</h2><p>接下来是关于 <code>Subject</code> 的内容。 <code>Subject</code> 可以看做是一种代理和桥梁。它既是订阅者又是订阅源，这意味着它既可以订阅其他 <code>Observable</code> 对象，同时又可以对它的订阅者们发送事件。</p>
<p>如果把 <code>Observable</code> 理解成不断输出事件的水管，那 <code>Subject</code> 就是套在上面的水龙头。它既怼着一根不断出水的水管，同时也向外面输送着新鲜水源。如果你直接用水杯接着水管的水，那可能导出来什么王水胶水完全把持不住；如果你在水龙头下面接着水，那你可以随心所欲的调成你想要的水速和水温。</p>
<p>（好吧上面一段文档里没有，是我瞎掰的，如果理解错了还望打脸(￣ε(#￣)☆╰╮(￣▽￣///))</p>
<p>在开始下面的代码之前，先定义一个辅助函数用于输出数据：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">writeSequenceToConsole</span>&lt;O: ObservableType&gt;<span class="params">(name: String, sequence: O)</span></span> &#123;</div><div class="line">    sequence</div><div class="line">        .subscribe &#123; e <span class="keyword">in</span></div><div class="line">            <span class="built_in">print</span>(<span class="string">"Subscription: <span class="subst">\(name)</span>, event: <span class="subst">\(e)</span>"</span>)</div><div class="line">        &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="PublishSubject"><a href="#PublishSubject" class="headerlink" title="PublishSubject"></a>PublishSubject</h3><p><code>PublishSubject</code> 会发送订阅者从订阅之后的事件序列。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">example(<span class="string">"PublishSubject"</span>) &#123;</div><div class="line">    <span class="keyword">let</span> subject = <span class="type">PublishSubject</span>&lt;<span class="type">String</span>&gt;()</div><div class="line">    writeSequenceToConsole(<span class="string">"1"</span>, sequence: subject)</div><div class="line">    subject.on(.<span class="type">Next</span>(<span class="string">"a"</span>))</div><div class="line">    subject.on(.<span class="type">Next</span>(<span class="string">"b"</span>))</div><div class="line">    writeSequenceToConsole(<span class="string">"2"</span>, sequence: subject)</div><div class="line">    subject.on(.<span class="type">Next</span>(<span class="string">"c"</span>))</div><div class="line">    subject.on(.<span class="type">Next</span>(<span class="string">"d"</span>))</div><div class="line">&#125;</div><div class="line">--- <span class="type">PublishSubject</span> example ---</div><div class="line"><span class="type">Subscription</span>: <span class="number">1</span>, event: <span class="type">Next</span>(a)</div><div class="line"><span class="type">Subscription</span>: <span class="number">1</span>, event: <span class="type">Next</span>(b)</div><div class="line"><span class="type">Subscription</span>: <span class="number">1</span>, event: <span class="type">Next</span>(<span class="built_in">c</span>)</div><div class="line"><span class="type">Subscription</span>: <span class="number">2</span>, event: <span class="type">Next</span>(<span class="built_in">c</span>)</div><div class="line"><span class="type">Subscription</span>: <span class="number">1</span>, event: <span class="type">Next</span>(d)</div><div class="line"><span class="type">Subscription</span>: <span class="number">2</span>, event: <span class="type">Next</span>(d)</div></pre></td></tr></table></figure>
<h3 id="ReplaySubject"><a href="#ReplaySubject" class="headerlink" title="ReplaySubject"></a>ReplaySubject</h3><p><code>ReplaySubject</code> 在新的订阅对象订阅的时候会补发所有已经发送过的数据队列， <code>bufferSize</code> 是缓冲区的大小，决定了补发队列的最大值。如果 <code>bufferSize</code> 是1，那么新的订阅者出现的时候就会补发上一个事件，如果是2，则补两个，以此类推。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">example(<span class="string">"ReplaySubject"</span>) &#123;</div><div class="line">    <span class="keyword">let</span> subject = <span class="type">ReplaySubject</span>&lt;<span class="type">String</span>&gt;.create(bufferSize: <span class="number">1</span>)</div><div class="line">    writeSequenceToConsole(<span class="string">"1"</span>, sequence: subject)</div><div class="line">    subject.on(.<span class="type">Next</span>(<span class="string">"a"</span>))</div><div class="line">    subject.on(.<span class="type">Next</span>(<span class="string">"b"</span>))</div><div class="line">    writeSequenceToConsole(<span class="string">"2"</span>, sequence: subject)</div><div class="line">    subject.on(.<span class="type">Next</span>(<span class="string">"c"</span>))</div><div class="line">    subject.on(.<span class="type">Next</span>(<span class="string">"d"</span>))</div><div class="line">&#125;</div><div class="line">--- <span class="type">ReplaySubject</span> example ---</div><div class="line"><span class="type">Subscription</span>: <span class="number">1</span>, event: <span class="type">Next</span>(a)</div><div class="line"><span class="type">Subscription</span>: <span class="number">1</span>, event: <span class="type">Next</span>(b)</div><div class="line"><span class="type">Subscription</span>: <span class="number">2</span>, event: <span class="type">Next</span>(b) <span class="comment">// 补了一个 b</span></div><div class="line"><span class="type">Subscription</span>: <span class="number">1</span>, event: <span class="type">Next</span>(<span class="built_in">c</span>)</div><div class="line"><span class="type">Subscription</span>: <span class="number">2</span>, event: <span class="type">Next</span>(<span class="built_in">c</span>)</div><div class="line"><span class="type">Subscription</span>: <span class="number">1</span>, event: <span class="type">Next</span>(d)</div><div class="line"><span class="type">Subscription</span>: <span class="number">2</span>, event: <span class="type">Next</span>(d)</div></pre></td></tr></table></figure>
<h3 id="BehaviorSubject"><a href="#BehaviorSubject" class="headerlink" title="BehaviorSubject"></a>BehaviorSubject</h3><p><code>BehaviorSubject</code> 在新的订阅对象订阅的时候会发送最近发送的事件，如果没有则发送一个默认值。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">example(<span class="string">"BehaviorSubject"</span>) &#123;</div><div class="line">    <span class="keyword">let</span> subject = <span class="type">BehaviorSubject</span>(value: <span class="string">"z"</span>)</div><div class="line">    writeSequenceToConsole(<span class="string">"1"</span>, sequence: subject)</div><div class="line">    subject.on(.<span class="type">Next</span>(<span class="string">"a"</span>))</div><div class="line">    subject.on(.<span class="type">Next</span>(<span class="string">"b"</span>))</div><div class="line">    writeSequenceToConsole(<span class="string">"2"</span>, sequence: subject)</div><div class="line">    subject.on(.<span class="type">Next</span>(<span class="string">"c"</span>))</div><div class="line">    subject.on(.<span class="type">Completed</span>)</div><div class="line">&#125;</div><div class="line">--- <span class="type">BehaviorSubject</span> example ---</div><div class="line"><span class="type">Subscription</span>: <span class="number">1</span>, event: <span class="type">Next</span>(z)</div><div class="line"><span class="type">Subscription</span>: <span class="number">1</span>, event: <span class="type">Next</span>(a)</div><div class="line"><span class="type">Subscription</span>: <span class="number">1</span>, event: <span class="type">Next</span>(b)</div><div class="line"><span class="type">Subscription</span>: <span class="number">2</span>, event: <span class="type">Next</span>(b)</div><div class="line"><span class="type">Subscription</span>: <span class="number">1</span>, event: <span class="type">Next</span>(<span class="built_in">c</span>)</div><div class="line"><span class="type">Subscription</span>: <span class="number">2</span>, event: <span class="type">Next</span>(<span class="built_in">c</span>)</div><div class="line"><span class="type">Subscription</span>: <span class="number">1</span>, event: <span class="type">Completed</span></div><div class="line"><span class="type">Subscription</span>: <span class="number">2</span>, event: <span class="type">Completed</span></div></pre></td></tr></table></figure>
<h3 id="Variable"><a href="#Variable" class="headerlink" title="Variable"></a>Variable</h3><p><code>Variable</code> 是基于 <code>BehaviorSubject</code> 的一层封装，它的优势是：不会被显式终结。即：不会收到 <code>.Completed</code> 和 <code>.Error</code> 这类的终结事件，它会主动在析构的时候发送 <code>.Complete</code> 。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">example(<span class="string">"Variable"</span>) &#123;</div><div class="line">    <span class="keyword">let</span> variable = <span class="type">Variable</span>(<span class="string">"z"</span>)</div><div class="line">    writeSequenceToConsole(<span class="string">"1"</span>, sequence: variable)</div><div class="line">    variable.value = <span class="string">"a"</span></div><div class="line">    variable.value = <span class="string">"b"</span></div><div class="line">    writeSequenceToConsole(<span class="string">"2"</span>, sequence: variable)</div><div class="line">    variable.value = <span class="string">"c"</span></div><div class="line">&#125;</div><div class="line">--- <span class="type">Variable</span> example ---</div><div class="line"><span class="type">Subscription</span>: <span class="number">1</span>, event: <span class="type">Next</span>(z)</div><div class="line"><span class="type">Subscription</span>: <span class="number">1</span>, event: <span class="type">Next</span>(a)</div><div class="line"><span class="type">Subscription</span>: <span class="number">1</span>, event: <span class="type">Next</span>(b)</div><div class="line"><span class="type">Subscription</span>: <span class="number">2</span>, event: <span class="type">Next</span>(b)</div><div class="line"><span class="type">Subscription</span>: <span class="number">1</span>, event: <span class="type">Next</span>(<span class="built_in">c</span>)</div><div class="line"><span class="type">Subscription</span>: <span class="number">2</span>, event: <span class="type">Next</span>(<span class="built_in">c</span>)</div><div class="line"><span class="type">Subscription</span>: <span class="number">1</span>, event: <span class="type">Completed</span></div><div class="line"><span class="type">Subscription</span>: <span class="number">2</span>, event: <span class="type">Completed</span></div></pre></td></tr></table></figure>
<h2 id="Transform"><a href="#Transform" class="headerlink" title="Transform"></a>Transform</h2><p>我们可以对序列做一些转换，类似于 <code>Swift</code> 中 <code>CollectionType</code> 的各种转换。在以前的坑中曾经提到过，可以参考：<a href="https://blog.callmewhy.com/2015/05/11/functional-reactive-programming-1/#函数式的函数/" target="_blank" rel="external">函数式的函数</a>。</p>
<h3 id="map"><a href="#map" class="headerlink" title="map"></a>map</h3><p><code>map</code> 就是对每个元素都用函数做一次转换，挨个映射一遍。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">example(<span class="string">"map"</span>) &#123;</div><div class="line">    <span class="keyword">let</span> originalSequence = sequenceOf(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</div><div class="line">    originalSequence</div><div class="line">        .<span class="built_in">map</span> &#123; $<span class="number">0</span> * <span class="number">2</span> &#125;</div><div class="line">        .subscribe &#123; <span class="built_in">print</span>($<span class="number">0</span>) &#125;</div><div class="line">&#125;</div><div class="line">--- <span class="built_in">map</span> example ---</div><div class="line"><span class="type">Next</span>(<span class="number">2</span>)</div><div class="line"><span class="type">Next</span>(<span class="number">4</span>)</div><div class="line"><span class="type">Next</span>(<span class="number">6</span>)</div><div class="line"><span class="type">Completed</span></div></pre></td></tr></table></figure>
<h3 id="flatMap"><a href="#flatMap" class="headerlink" title="flatMap"></a>flatMap</h3><p><code>map</code> 在做转换的时候很容易出现『升维』的情况，即：转变之后，从一个序列变成了一个序列的序列。</p>
<p>什么是『升维』？在集合中我们可以举这样一个例子，我有一个好友列表 <code>[p1, p2, p3]</code>，那么如果要获取我好友的好友的列表，可以这样做：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">myFriends.<span class="built_in">map</span> &#123; $<span class="number">0</span>.getFriends() &#125;</div></pre></td></tr></table></figure>
<p>结果就成了 <code>[[p1-1, p1-2, p1-3], [p2-1], [p3-1, p3-2]]</code> ，这就成了好友的好友列表的列表了。这就是一个『升维』的例子。</p>
<p>（以上内容文档中依旧没有，依旧是我瞎掰的，依旧欢迎有错误当面打脸(￣ε(#￣)☆╰╮(￣▽￣///))</p>
<p>在 <code>Swift</code> 中，我们可以用 <code>flatMap</code> 过滤掉 <code>map</code> 之后的 <code>nil</code> 结果。在 <code>Rx</code> 中， <code>flatMap</code> 可以把一个序列转换成一组序列，然后再把这一组序列『拍扁』成一个序列。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">example(<span class="string">"flatMap"</span>) &#123;</div><div class="line">    <span class="keyword">let</span> sequenceInt = sequenceOf(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</div><div class="line">    <span class="keyword">let</span> sequenceString = sequenceOf(<span class="string">"A"</span>, <span class="string">"B"</span>, <span class="string">"--"</span>)</div><div class="line">    sequenceInt</div><div class="line">        .flatMap &#123; int <span class="keyword">in</span></div><div class="line">            sequenceString</div><div class="line">        &#125;</div><div class="line">        .subscribe &#123;</div><div class="line">            <span class="built_in">print</span>($<span class="number">0</span>)</div><div class="line">        &#125;</div><div class="line">&#125;</div><div class="line">--- flatMap example ---</div><div class="line"><span class="type">Next</span>(<span class="type">A</span>)</div><div class="line"><span class="type">Next</span>(<span class="type">B</span>)</div><div class="line"><span class="type">Next</span>(--)</div><div class="line"><span class="type">Next</span>(<span class="type">A</span>)</div><div class="line"><span class="type">Next</span>(<span class="type">B</span>)</div><div class="line"><span class="type">Next</span>(--)</div><div class="line"><span class="type">Next</span>(<span class="type">A</span>)</div><div class="line"><span class="type">Next</span>(<span class="type">B</span>)</div><div class="line"><span class="type">Next</span>(--)</div><div class="line"><span class="type">Completed</span></div></pre></td></tr></table></figure>
<h3 id="scan"><a href="#scan" class="headerlink" title="scan"></a>scan</h3><p><code>scan</code> 有点像 <code>reduce</code> ，它会把每次的运算结果累积起来，作为下一次运算的输入值。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">example(<span class="string">"scan"</span>) &#123;</div><div class="line">    <span class="keyword">let</span> sequenceToSum = sequenceOf(<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)</div><div class="line">    sequenceToSum</div><div class="line">        .scan(<span class="number">0</span>) &#123; acum, elem <span class="keyword">in</span></div><div class="line">            acum + elem</div><div class="line">        &#125;</div><div class="line">        .subscribe &#123;</div><div class="line">            <span class="built_in">print</span>($<span class="number">0</span>)</div><div class="line">        &#125;</div><div class="line">&#125;</div><div class="line">--- scan example ---</div><div class="line"><span class="type">Next</span>(<span class="number">0</span>)</div><div class="line"><span class="type">Next</span>(<span class="number">1</span>)</div><div class="line"><span class="type">Next</span>(<span class="number">3</span>)</div><div class="line"><span class="type">Next</span>(<span class="number">6</span>)</div><div class="line"><span class="type">Next</span>(<span class="number">10</span>)</div><div class="line"><span class="type">Next</span>(<span class="number">15</span>)</div><div class="line"><span class="type">Completed</span></div></pre></td></tr></table></figure>
<h2 id="Filtering"><a href="#Filtering" class="headerlink" title="Filtering"></a>Filtering</h2><p>除了上面的各种转换，我们还可以对序列进行过滤。</p>
<h3 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h3><p><code>filter</code> 只会让符合条件的元素通过。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">example(<span class="string">"filter"</span>) &#123;</div><div class="line">    <span class="keyword">let</span> subscription = sequenceOf(<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>)</div><div class="line">        .<span class="built_in">filter</span> &#123;</div><div class="line">            $<span class="number">0</span> % <span class="number">2</span> == <span class="number">0</span></div><div class="line">        &#125;</div><div class="line">        .subscribe &#123;</div><div class="line">            <span class="built_in">print</span>($<span class="number">0</span>)</div><div class="line">        &#125;</div><div class="line">&#125;</div><div class="line">--- <span class="built_in">filter</span> example ---</div><div class="line"><span class="type">Next</span>(<span class="number">0</span>)</div><div class="line"><span class="type">Next</span>(<span class="number">2</span>)</div><div class="line"><span class="type">Next</span>(<span class="number">4</span>)</div><div class="line"><span class="type">Next</span>(<span class="number">6</span>)</div><div class="line"><span class="type">Next</span>(<span class="number">8</span>)</div><div class="line"><span class="type">Completed</span></div></pre></td></tr></table></figure>
<h3 id="distinctUntilChanged"><a href="#distinctUntilChanged" class="headerlink" title="distinctUntilChanged"></a>distinctUntilChanged</h3><p><code>distinctUntilChanged</code> 会废弃掉重复的事件。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">example(<span class="string">"distinctUntilChanged"</span>) &#123;</div><div class="line">    <span class="keyword">let</span> subscription = sequenceOf(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">4</span>)</div><div class="line">        .distinctUntilChanged()</div><div class="line">        .subscribe &#123;</div><div class="line">            <span class="built_in">print</span>($<span class="number">0</span>)</div><div class="line">        &#125;</div><div class="line">&#125;</div><div class="line">--- distinctUntilChanged example ---</div><div class="line"><span class="type">Next</span>(<span class="number">1</span>)</div><div class="line"><span class="type">Next</span>(<span class="number">2</span>)</div><div class="line"><span class="type">Next</span>(<span class="number">3</span>)</div><div class="line"><span class="type">Next</span>(<span class="number">1</span>)</div><div class="line"><span class="type">Next</span>(<span class="number">4</span>)</div><div class="line"><span class="type">Completed</span></div></pre></td></tr></table></figure>
<h3 id="take"><a href="#take" class="headerlink" title="take"></a>take</h3><p><code>take</code> 只获取序列中的前 <code>n</code> 个事件，在满足数量之后会自动 <code>.Completed</code> 。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">example(<span class="string">"take"</span>) &#123;</div><div class="line">    <span class="keyword">let</span> subscription = sequenceOf(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>)</div><div class="line">        .take(<span class="number">3</span>)</div><div class="line">        .subscribe &#123;</div><div class="line">            <span class="built_in">print</span>($<span class="number">0</span>)</div><div class="line">        &#125;</div><div class="line">&#125;</div><div class="line">--- take example ---</div><div class="line"><span class="type">Next</span>(<span class="number">1</span>)</div><div class="line"><span class="type">Next</span>(<span class="number">2</span>)</div><div class="line"><span class="type">Next</span>(<span class="number">3</span>)</div><div class="line"><span class="type">Completed</span></div></pre></td></tr></table></figure>
<h3 id="throttle-VS-debounce"><a href="#throttle-VS-debounce" class="headerlink" title="throttle VS. debounce"></a>throttle VS. debounce</h3><p><code>throttle</code> 和 <code>debounce</code> 目的都是控制某个时间段内事件序列的速度。但是又有差别：</p>
<ul>
<li><code>debounce</code> : <code>空闲控制</code>  空闲时间必须 <code>&gt;=</code> 固定的时间，事件序列才会被放行</li>
<li><code>throttle</code> : <code>频率控制</code>  事件序列满足 <code>1/delay</code> 才会被放行</li>
</ul>
<p>一般的按钮点击、用户输入、等都属于频率控制，应该使用 <code>throttle</code> 。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> searchResults = searchBar.rx.text.orEmpty</div><div class="line">    .throttle(<span class="number">0.3</span>, scheduler: <span class="type">MainScheduler</span>.instance)</div><div class="line">    .distinctUntilChanged()</div><div class="line">    .flatMapLatest &#123; query -&gt; <span class="type">Observable</span>&lt;[<span class="type">Repository</span>]&gt; <span class="keyword">in</span></div><div class="line">        <span class="keyword">if</span> query.isEmpty &#123;</div><div class="line">            <span class="keyword">return</span> .just([])</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> searchGitHub(query)</div><div class="line">            .catchErrorJustReturn([])</div><div class="line">    &#125;</div><div class="line">    .observeOn(<span class="type">MainScheduler</span>.instance)</div></pre></td></tr></table></figure>
<h2 id="Combining"><a href="#Combining" class="headerlink" title="Combining"></a>Combining</h2><p>这部分是关于序列的运算，可以将多个序列源进行组合拼装成一个新的事件序列。</p>
<h3 id="startWith"><a href="#startWith" class="headerlink" title="startWith"></a>startWith</h3><p><code>startWith</code> 会在队列开始之前插入一个事件元素。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">example(<span class="string">"startWith"</span>) &#123;</div><div class="line">    <span class="keyword">let</span> subscription = sequenceOf(<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>)</div><div class="line">        .startWith(<span class="number">3</span>)</div><div class="line">        .subscribe &#123;</div><div class="line">            <span class="built_in">print</span>($<span class="number">0</span>)</div><div class="line">        &#125;</div><div class="line">&#125;</div><div class="line">--- startWith example ---</div><div class="line"><span class="type">Next</span>(<span class="number">3</span>)</div><div class="line"><span class="type">Next</span>(<span class="number">4</span>)</div><div class="line"><span class="type">Next</span>(<span class="number">5</span>)</div><div class="line"><span class="type">Next</span>(<span class="number">6</span>)</div><div class="line"><span class="type">Completed</span></div></pre></td></tr></table></figure>
<h3 id="combineLatest"><a href="#combineLatest" class="headerlink" title="combineLatest"></a>combineLatest</h3><p>如果存在两条事件队列，需要同时监听，那么每当有新的事件发生的时候，<code>combineLatest</code> 会将每个队列的最新的一个元素进行合并。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">example(<span class="string">"combineLatest 1"</span>) &#123;</div><div class="line">    <span class="keyword">let</span> intOb1 = <span class="type">PublishSubject</span>&lt;<span class="type">String</span>&gt;()</div><div class="line">    <span class="keyword">let</span> intOb2 = <span class="type">PublishSubject</span>&lt;<span class="type">Int</span>&gt;()</div><div class="line">    combineLatest(intOb1, intOb2) &#123;</div><div class="line">        <span class="string">"<span class="subst">\($<span class="number">0</span>)</span> <span class="subst">\($<span class="number">1</span>)</span>"</span></div><div class="line">        &#125;</div><div class="line">        .subscribe &#123;</div><div class="line">            <span class="built_in">print</span>($<span class="number">0</span>)</div><div class="line">        &#125;</div><div class="line">    intOb1.on(.<span class="type">Next</span>(<span class="string">"A"</span>))</div><div class="line">    intOb2.on(.<span class="type">Next</span>(<span class="number">1</span>))</div><div class="line">    intOb1.on(.<span class="type">Next</span>(<span class="string">"B"</span>))</div><div class="line">    intOb2.on(.<span class="type">Next</span>(<span class="number">2</span>))</div><div class="line">&#125;</div><div class="line">--- combineLatest <span class="number">1</span> example ---</div><div class="line"><span class="type">Next</span>(<span class="type">A</span> <span class="number">1</span>)</div><div class="line"><span class="type">Next</span>(<span class="type">B</span> <span class="number">1</span>)</div><div class="line"><span class="type">Next</span>(<span class="type">B</span> <span class="number">2</span>)</div></pre></td></tr></table></figure>
<h3 id="zip"><a href="#zip" class="headerlink" title="zip"></a>zip</h3><p><code>zip</code> 人如其名，就是合并两条队列用的，不过它会等到两个队列的元素一一对应地凑齐了之后再合并，正如<a href="http://weibo.com/mrgreenhand" target="_blank" rel="external">百折不撓的米斯特菜</a>所提醒的， <code>zip</code> 就像是拉链一样，两根拉链拉着拉着合并到了一根上：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">example(<span class="string">"zip 1"</span>) &#123;</div><div class="line">    <span class="keyword">let</span> intOb1 = <span class="type">PublishSubject</span>&lt;<span class="type">String</span>&gt;()</div><div class="line">    <span class="keyword">let</span> intOb2 = <span class="type">PublishSubject</span>&lt;<span class="type">Int</span>&gt;()</div><div class="line">    <span class="built_in">zip</span>(intOb1, intOb2) &#123;</div><div class="line">        <span class="string">"<span class="subst">\($<span class="number">0</span>)</span> <span class="subst">\($<span class="number">1</span>)</span>"</span></div><div class="line">        &#125;</div><div class="line">        .subscribe &#123;</div><div class="line">            <span class="built_in">print</span>($<span class="number">0</span>)</div><div class="line">        &#125;</div><div class="line">    intOb1.on(.<span class="type">Next</span>(<span class="string">"A"</span>))</div><div class="line">    intOb2.on(.<span class="type">Next</span>(<span class="number">1</span>))</div><div class="line">    intOb1.on(.<span class="type">Next</span>(<span class="string">"B"</span>))</div><div class="line">    intOb1.on(.<span class="type">Next</span>(<span class="string">"C"</span>))</div><div class="line">    intOb2.on(.<span class="type">Next</span>(<span class="number">2</span>))</div><div class="line">&#125;</div><div class="line">--- <span class="built_in">zip</span> <span class="number">1</span> example ---</div><div class="line"><span class="type">Next</span>(<span class="type">A</span> <span class="number">1</span>)</div><div class="line"><span class="type">Next</span>(<span class="type">B</span> <span class="number">2</span>)</div></pre></td></tr></table></figure>
<h3 id="merge"><a href="#merge" class="headerlink" title="merge"></a>merge</h3><p><code>merge</code> 就是 <code>merge</code> 啦，把两个队列按照顺序组合在一起。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">example(<span class="string">"merge 1"</span>) &#123;</div><div class="line">    <span class="keyword">let</span> subject1 = <span class="type">PublishSubject</span>&lt;<span class="type">Int</span>&gt;()</div><div class="line">    <span class="keyword">let</span> subject2 = <span class="type">PublishSubject</span>&lt;<span class="type">Int</span>&gt;()</div><div class="line">    sequenceOf(subject1, subject2)</div><div class="line">        .merge()</div><div class="line">        .subscribeNext &#123; int <span class="keyword">in</span></div><div class="line">            <span class="built_in">print</span>(int)</div><div class="line">        &#125;</div><div class="line">    subject1.on(.<span class="type">Next</span>(<span class="number">1</span>))</div><div class="line">    subject1.on(.<span class="type">Next</span>(<span class="number">2</span>))</div><div class="line">    subject2.on(.<span class="type">Next</span>(<span class="number">3</span>))</div><div class="line">    subject1.on(.<span class="type">Next</span>(<span class="number">4</span>))</div><div class="line">    subject2.on(.<span class="type">Next</span>(<span class="number">5</span>))</div><div class="line">&#125;</div><div class="line">--- merge <span class="number">1</span> example ---</div><div class="line"><span class="number">1</span></div><div class="line"><span class="number">2</span></div><div class="line"><span class="number">3</span></div><div class="line"><span class="number">4</span></div><div class="line"><span class="number">5</span></div></pre></td></tr></table></figure>
<h3 id="switch"><a href="#switch" class="headerlink" title="switch"></a>switch</h3><p>当你的事件序列是一个事件序列的序列 (<code>Observable&lt;Observable&lt;T&gt;&gt;</code>) 的时候，（可以理解成二维序列？），可以使用 <code>switch</code> 将序列的序列平铺成一维，并且在出现新的序列的时候，自动切换到最新的那个序列上。和 <code>merge</code> 相似的是，它也是起到了将多个序列『拍平』成一条序列的作用。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">example(<span class="string">"switchLatest"</span>) &#123;</div><div class="line">    <span class="keyword">let</span> var1 = <span class="type">Variable</span>(<span class="number">0</span>)</div><div class="line">    <span class="keyword">let</span> var2 = <span class="type">Variable</span>(<span class="number">200</span>)</div><div class="line">    <span class="comment">// var3 is like an Observable&lt;Observable&lt;Int&gt;&gt;</span></div><div class="line">    <span class="keyword">let</span> var3 = <span class="type">Variable</span>(var1)</div><div class="line">    <span class="keyword">let</span> d = var3</div><div class="line">        .switchLatest()</div><div class="line">        .subscribe &#123;</div><div class="line">            <span class="built_in">print</span>($<span class="number">0</span>)</div><div class="line">        &#125;</div><div class="line">    var1.value = <span class="number">1</span></div><div class="line">    var1.value = <span class="number">2</span></div><div class="line">    var1.value = <span class="number">3</span></div><div class="line">    var1.value = <span class="number">4</span></div><div class="line">    var3.value = var2</div><div class="line">    var2.value = <span class="number">201</span></div><div class="line">    var1.value = <span class="number">5</span></div><div class="line">    var3.value = var1</div><div class="line">    var2.value = <span class="number">202</span></div><div class="line">    var1.value = <span class="number">6</span></div><div class="line">&#125;</div><div class="line">--- switchLatest example ---</div><div class="line"><span class="type">Next</span>(<span class="number">0</span>)</div><div class="line"><span class="type">Next</span>(<span class="number">1</span>)</div><div class="line"><span class="type">Next</span>(<span class="number">2</span>)</div><div class="line"><span class="type">Next</span>(<span class="number">3</span>)</div><div class="line"><span class="type">Next</span>(<span class="number">4</span>)</div><div class="line"><span class="type">Next</span>(<span class="number">200</span>)</div><div class="line"><span class="type">Next</span>(<span class="number">201</span>)</div><div class="line"><span class="type">Next</span>(<span class="number">5</span>)</div><div class="line"><span class="type">Next</span>(<span class="number">6</span>)</div></pre></td></tr></table></figure>
<p>注意，虽然都是『拍平』，但是和 <code>flatmap</code> 是不同的， <code>flatmap</code> 是将一条序列变成另一条序列，而这变换过程会让维度变高，所以需要『拍平』，而 <code>switch</code> 是将本来二维的序列（序列的序列）拍平成了一维的序列。</p>
<h2 id="Error-Handling"><a href="#Error-Handling" class="headerlink" title="Error Handling"></a>Error Handling</h2><p>在事件序列中，遇到异常也是很正常的事情，有以下几种处理异常的手段。</p>
<h3 id="catchError"><a href="#catchError" class="headerlink" title="catchError"></a>catchError</h3><p><code>catchError</code> 可以捕获异常事件，并且在后面无缝接上另一段事件序列，丝毫没有异常的痕迹。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">example(<span class="string">"catchError 1"</span>) &#123;</div><div class="line">    <span class="keyword">let</span> sequenceThatFails = <span class="type">PublishSubject</span>&lt;<span class="type">Int</span>&gt;()</div><div class="line">    <span class="keyword">let</span> recoverySequence = sequenceOf(<span class="number">100</span>, <span class="number">200</span>)</div><div class="line">    sequenceThatFails</div><div class="line">        .catchError &#123; error <span class="keyword">in</span></div><div class="line">            <span class="keyword">return</span> recoverySequence</div><div class="line">        &#125;</div><div class="line">        .subscribe &#123;</div><div class="line">            <span class="built_in">print</span>($<span class="number">0</span>)</div><div class="line">        &#125;</div><div class="line">    sequenceThatFails.on(.<span class="type">Next</span>(<span class="number">1</span>))</div><div class="line">    sequenceThatFails.on(.<span class="type">Next</span>(<span class="number">2</span>))</div><div class="line">    sequenceThatFails.on(.<span class="type">Error</span>(<span class="type">NSError</span>(domain: <span class="string">"Test"</span>, code: <span class="number">0</span>, userInfo: <span class="literal">nil</span>)))</div><div class="line">&#125;</div><div class="line">--- catchError <span class="number">1</span> example ---</div><div class="line"><span class="type">Next</span>(<span class="number">1</span>)</div><div class="line"><span class="type">Next</span>(<span class="number">2</span>)</div><div class="line"><span class="type">Next</span>(<span class="number">100</span>)</div><div class="line"><span class="type">Next</span>(<span class="number">200</span>)</div><div class="line"><span class="type">Completed</span></div></pre></td></tr></table></figure>
<h3 id="retry"><a href="#retry" class="headerlink" title="retry"></a>retry</h3><p><code>retry</code> 顾名思义，就是在出现异常的时候会再去从头订阅事件序列，妄图通过『从头再来』解决异常。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">example(<span class="string">"retry"</span>) &#123;</div><div class="line">    <span class="keyword">var</span> <span class="built_in">count</span> = <span class="number">1</span> <span class="comment">// bad practice, only for example purposes</span></div><div class="line">    <span class="keyword">let</span> funnyLookingSequence: <span class="type">Observable</span>&lt;<span class="type">Int</span>&gt; = create &#123; observer <span class="keyword">in</span></div><div class="line">        <span class="keyword">let</span> error = <span class="type">NSError</span>(domain: <span class="string">"Test"</span>, code: <span class="number">0</span>, userInfo: <span class="literal">nil</span>)</div><div class="line">        observer.on(.<span class="type">Next</span>(<span class="number">0</span>))</div><div class="line">        observer.on(.<span class="type">Next</span>(<span class="number">1</span>))</div><div class="line">        <span class="keyword">if</span> <span class="built_in">count</span> &lt; <span class="number">2</span> &#123;</div><div class="line">            observer.on(.<span class="type">Error</span>(error))</div><div class="line">            <span class="built_in">count</span>++</div><div class="line">        &#125;</div><div class="line">        observer.on(.<span class="type">Next</span>(<span class="number">2</span>))</div><div class="line">        observer.on(.<span class="type">Completed</span>)</div><div class="line">        <span class="keyword">return</span> <span class="type">NopDisposable</span>.instance</div><div class="line">    &#125;</div><div class="line">    funnyLookingSequence</div><div class="line">        .retry()</div><div class="line">        .subscribe &#123;</div><div class="line">            <span class="built_in">print</span>($<span class="number">0</span>)</div><div class="line">        &#125;</div><div class="line">&#125;</div><div class="line">--- retry example ---</div><div class="line"><span class="type">Next</span>(<span class="number">0</span>)</div><div class="line"><span class="type">Next</span>(<span class="number">1</span>)</div><div class="line"><span class="type">Next</span>(<span class="number">0</span>)</div><div class="line"><span class="type">Next</span>(<span class="number">1</span>)</div><div class="line"><span class="type">Next</span>(<span class="number">2</span>)</div><div class="line"><span class="type">Completed</span></div></pre></td></tr></table></figure>
<h2 id="Utility"><a href="#Utility" class="headerlink" title="Utility"></a>Utility</h2><p>这里列举了针对事件序列的一些方法。</p>
<h3 id="subscribe"><a href="#subscribe" class="headerlink" title="subscribe"></a>subscribe</h3><p><code>subscribe</code> 在前面已经接触过了，有新的事件就会触发。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">example(<span class="string">"subscribe"</span>) &#123;</div><div class="line">    <span class="keyword">let</span> sequenceOfInts = <span class="type">PublishSubject</span>&lt;<span class="type">Int</span>&gt;()</div><div class="line">    sequenceOfInts</div><div class="line">        .subscribe &#123;</div><div class="line">            <span class="built_in">print</span>($<span class="number">0</span>)</div><div class="line">        &#125;</div><div class="line">    sequenceOfInts.on(.<span class="type">Next</span>(<span class="number">1</span>))</div><div class="line">    sequenceOfInts.on(.<span class="type">Completed</span>)</div><div class="line">&#125;</div><div class="line">--- subscribe example ---</div><div class="line"><span class="type">Next</span>(<span class="number">1</span>)</div><div class="line"><span class="type">Completed</span></div></pre></td></tr></table></figure>
<h3 id="subscribeNext"><a href="#subscribeNext" class="headerlink" title="subscribeNext"></a>subscribeNext</h3><p><code>subscribeNext</code> 也是订阅，但是只订阅 <code>.Next</code> 事件。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">example(<span class="string">"subscribeNext"</span>) &#123;</div><div class="line">    <span class="keyword">let</span> sequenceOfInts = <span class="type">PublishSubject</span>&lt;<span class="type">Int</span>&gt;()</div><div class="line">    sequenceOfInts</div><div class="line">        .subscribeNext &#123;</div><div class="line">            <span class="built_in">print</span>($<span class="number">0</span>)</div><div class="line">        &#125;</div><div class="line">    sequenceOfInts.on(.<span class="type">Next</span>(<span class="number">1</span>))</div><div class="line">    sequenceOfInts.on(.<span class="type">Completed</span>)</div><div class="line">&#125;</div><div class="line">--- subscribeNext example ---</div><div class="line"><span class="number">1</span></div></pre></td></tr></table></figure>
<h3 id="subscribeCompleted"><a href="#subscribeCompleted" class="headerlink" title="subscribeCompleted"></a>subscribeCompleted</h3><p><code>subscribeCompleted</code> 是只订阅 <code>.Completed</code> 完成事件。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">example(<span class="string">"subscribeCompleted"</span>) &#123;</div><div class="line">    <span class="keyword">let</span> sequenceOfInts = <span class="type">PublishSubject</span>&lt;<span class="type">Int</span>&gt;()</div><div class="line">    sequenceOfInts</div><div class="line">        .subscribeCompleted &#123;</div><div class="line">            <span class="built_in">print</span>(<span class="string">"It's completed"</span>)</div><div class="line">        &#125;</div><div class="line">    sequenceOfInts.on(.<span class="type">Next</span>(<span class="number">1</span>))</div><div class="line">    sequenceOfInts.on(.<span class="type">Completed</span>)</div><div class="line">&#125;</div><div class="line">--- subscribeCompleted example ---</div><div class="line"><span class="type">It's</span> completed</div></pre></td></tr></table></figure>
<h3 id="subscribeError"><a href="#subscribeError" class="headerlink" title="subscribeError"></a>subscribeError</h3><p><code>subscribeError</code> 只订阅 <code>.Error</code> 失败事件。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">example(<span class="string">"subscribeError"</span>) &#123;</div><div class="line">    <span class="keyword">let</span> sequenceOfInts = <span class="type">PublishSubject</span>&lt;<span class="type">Int</span>&gt;()</div><div class="line">    sequenceOfInts</div><div class="line">        .subscribeError &#123; error <span class="keyword">in</span></div><div class="line">            <span class="built_in">print</span>(error)</div><div class="line">        &#125;</div><div class="line">    sequenceOfInts.on(.<span class="type">Next</span>(<span class="number">1</span>))</div><div class="line">    sequenceOfInts.on(.<span class="type">Error</span>(<span class="type">NSError</span>(domain: <span class="string">"Examples"</span>, code: -<span class="number">1</span>, userInfo: <span class="literal">nil</span>)))</div><div class="line">&#125;</div><div class="line">--- subscribeError example ---</div><div class="line"><span class="type">Error</span> <span class="type">Domain</span>=<span class="type">Examples</span> <span class="type">Code</span>=-<span class="number">1</span> <span class="string">"The operation couldn’t be completed. (Examples error -1.)"</span></div></pre></td></tr></table></figure>
<h3 id="doOn"><a href="#doOn" class="headerlink" title="doOn"></a>doOn</h3><p><code>doOn</code> 可以监听事件，并且在事件发生之前调用。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">example(<span class="string">"doOn"</span>) &#123;</div><div class="line">    <span class="keyword">let</span> sequenceOfInts = <span class="type">PublishSubject</span>&lt;<span class="type">Int</span>&gt;()</div><div class="line">    sequenceOfInts</div><div class="line">        .doOn &#123;</div><div class="line">            <span class="built_in">print</span>(<span class="string">"Intercepted event <span class="subst">\($<span class="number">0</span>)</span>"</span>)</div><div class="line">        &#125;</div><div class="line">        .subscribe &#123;</div><div class="line">            <span class="built_in">print</span>($<span class="number">0</span>)</div><div class="line">        &#125;</div><div class="line">    sequenceOfInts.on(.<span class="type">Next</span>(<span class="number">1</span>))</div><div class="line">    sequenceOfInts.on(.<span class="type">Completed</span>)</div><div class="line">&#125;</div><div class="line">--- doOn example ---</div><div class="line"><span class="type">Intercepted</span> event <span class="type">Next</span>(<span class="number">1</span>)</div><div class="line"><span class="type">Next</span>(<span class="number">1</span>)</div><div class="line"><span class="type">Intercepted</span> event <span class="type">Completed</span></div><div class="line"><span class="type">Completed</span></div></pre></td></tr></table></figure>
<h2 id="Conditional"><a href="#Conditional" class="headerlink" title="Conditional"></a>Conditional</h2><p>我们可以对多个事件序列做一些复杂的逻辑判断。</p>
<h3 id="takeUntil"><a href="#takeUntil" class="headerlink" title="takeUntil"></a>takeUntil</h3><p><code>takeUntil</code> 其实就是 <code>take</code> ，它会在终于等到那个事件之后触发 <code>.Completed</code> 事件。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">example(<span class="string">"takeUntil"</span>) &#123;</div><div class="line">    <span class="keyword">let</span> originalSequence = <span class="type">PublishSubject</span>&lt;<span class="type">Int</span>&gt;()</div><div class="line">    <span class="keyword">let</span> whenThisSendsNextWorldStops = <span class="type">PublishSubject</span>&lt;<span class="type">Int</span>&gt;()</div><div class="line">    originalSequence</div><div class="line">        .takeUntil(whenThisSendsNextWorldStops)</div><div class="line">        .subscribe &#123;</div><div class="line">            <span class="built_in">print</span>($<span class="number">0</span>)</div><div class="line">        &#125;</div><div class="line">    originalSequence.on(.<span class="type">Next</span>(<span class="number">1</span>))</div><div class="line">    originalSequence.on(.<span class="type">Next</span>(<span class="number">2</span>))</div><div class="line">    whenThisSendsNextWorldStops.on(.<span class="type">Next</span>(<span class="number">1</span>))</div><div class="line">    originalSequence.on(.<span class="type">Next</span>(<span class="number">3</span>))</div><div class="line">&#125;</div><div class="line">--- takeUntil example ---</div><div class="line"><span class="type">Next</span>(<span class="number">1</span>)</div><div class="line"><span class="type">Next</span>(<span class="number">2</span>)</div><div class="line"><span class="type">Completed</span></div></pre></td></tr></table></figure>
<h3 id="takeWhile"><a href="#takeWhile" class="headerlink" title="takeWhile"></a>takeWhile</h3><p><code>takeWhile</code> 则是可以通过状态语句判断是否继续 <code>take</code> 。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">example(<span class="string">"takeWhile"</span>) &#123;</div><div class="line">    <span class="keyword">let</span> sequence = <span class="type">PublishSubject</span>&lt;<span class="type">Int</span>&gt;()</div><div class="line">    sequence</div><div class="line">        .takeWhile &#123; int <span class="keyword">in</span></div><div class="line">            int &lt; <span class="number">2</span></div><div class="line">        &#125;</div><div class="line">        .subscribe &#123;</div><div class="line">            <span class="built_in">print</span>($<span class="number">0</span>)</div><div class="line">        &#125;</div><div class="line">    sequence.on(.<span class="type">Next</span>(<span class="number">1</span>))</div><div class="line">    sequence.on(.<span class="type">Next</span>(<span class="number">2</span>))</div><div class="line">    sequence.on(.<span class="type">Next</span>(<span class="number">3</span>))</div><div class="line">&#125;</div><div class="line">--- takeWhile example ---</div><div class="line"><span class="type">Next</span>(<span class="number">1</span>)</div><div class="line"><span class="type">Completed</span></div></pre></td></tr></table></figure>
<h2 id="Aggregate"><a href="#Aggregate" class="headerlink" title="Aggregate"></a>Aggregate</h2><p>我们可以对事件序列做一些集合运算。</p>
<h3 id="concat"><a href="#concat" class="headerlink" title="concat"></a>concat</h3><p><code>concat</code> 可以把多个事件序列合并起来。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">example(<span class="string">"concat"</span>) &#123;</div><div class="line">    <span class="keyword">let</span> var1 = <span class="type">BehaviorSubject</span>(value: <span class="number">0</span>)</div><div class="line">    <span class="keyword">let</span> var2 = <span class="type">BehaviorSubject</span>(value: <span class="number">200</span>)</div><div class="line">    <span class="comment">// var3 is like an Observable&lt;Observable&lt;Int&gt;&gt;</span></div><div class="line">    <span class="keyword">let</span> var3 = <span class="type">BehaviorSubject</span>(value: var1)</div><div class="line">    <span class="keyword">let</span> d = var3</div><div class="line">        .concat()</div><div class="line">        .subscribe &#123;</div><div class="line">            <span class="built_in">print</span>($<span class="number">0</span>)</div><div class="line">        &#125;</div><div class="line">    var1.on(.<span class="type">Next</span>(<span class="number">1</span>))</div><div class="line">    var1.on(.<span class="type">Next</span>(<span class="number">2</span>))</div><div class="line">    var3.on(.<span class="type">Next</span>(var2))</div><div class="line">    var2.on(.<span class="type">Next</span>(<span class="number">201</span>))</div><div class="line">    var1.on(.<span class="type">Next</span>(<span class="number">3</span>))</div><div class="line">    var1.on(.<span class="type">Completed</span>)</div><div class="line">    var2.on(.<span class="type">Next</span>(<span class="number">202</span>))</div><div class="line">&#125;</div><div class="line">--- concat example ---</div><div class="line"><span class="type">Next</span>(<span class="number">0</span>)</div><div class="line"><span class="type">Next</span>(<span class="number">1</span>)</div><div class="line"><span class="type">Next</span>(<span class="number">2</span>)</div><div class="line"><span class="type">Next</span>(<span class="number">3</span>)</div><div class="line"><span class="type">Next</span>(<span class="number">201</span>)</div><div class="line"><span class="type">Next</span>(<span class="number">202</span>)</div></pre></td></tr></table></figure>
<h3 id="reduce"><a href="#reduce" class="headerlink" title="reduce"></a>reduce</h3><p>这里的 <code>reduce</code> 和 <code>CollectionType</code> 中的 <code>reduce</code> 是一个意思，都是指通过对一系列数据的运算最后生成一个结果。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">example(<span class="string">"reduce"</span>) &#123;</div><div class="line">    sequenceOf(<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>)</div><div class="line">        .<span class="built_in">reduce</span>(<span class="number">0</span>, +)</div><div class="line">        .subscribe &#123;</div><div class="line">            <span class="built_in">print</span>($<span class="number">0</span>)</div><div class="line">        &#125;</div><div class="line">&#125;</div><div class="line">--- <span class="built_in">reduce</span> example ---</div><div class="line"><span class="type">Next</span>(<span class="number">45</span>)</div><div class="line"><span class="type">Completed</span></div></pre></td></tr></table></figure>
<h2 id="Connectable"><a href="#Connectable" class="headerlink" title="Connectable"></a>Connectable</h2><p>坑待填，Xcode 里这个操场跑不起来了。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;记录RxSwift在使用过程中的一些常用语法。&lt;/p&gt;
    
    </summary>
    
      <category term="iOS" scheme="https://madordie.github.io/categories/iOS/"/>
    
    
      <category term="响应式编程" scheme="https://madordie.github.io/tags/%E5%93%8D%E5%BA%94%E5%BC%8F%E7%BC%96%E7%A8%8B/"/>
    
      <category term="RxSwift" scheme="https://madordie.github.io/tags/RxSwift/"/>
    
  </entry>
  
  <entry>
    <title>sonarqube-note</title>
    <link href="https://madordie.github.io/sonarqube-note/"/>
    <id>https://madordie.github.io/sonarqube-note/</id>
    <published>2017-02-07T02:16:58.000Z</published>
    <updated>2017-08-14T02:15:12.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><p>Get Started in Two Minutes</p>
<ol>
<li>Download and unzip the SonarQube distribution (let’s say in “C:\sonarqube” or “/etc/sonarqube”)</li>
<li><p>Start the SonarQube server:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"># On Windows, execute:</div><div class="line">C:\sonarqube\bin\windows-x86-xx\StartSonar.bat</div><div class="line"> </div><div class="line"># On other operating system, execute:</div><div class="line">/etc/sonarqube/bin/[OS]/sonar.sh console</div></pre></td></tr></table></figure>
</li>
<li><p>Download and unzip the SonarQube Scanner (let’s say in “C:\sonar-scanner” or “/etc/sonar-scanner”)</p>
</li>
<li>Download and unzip some project samples (let’s say in “C:\sonar-scanning-examples” or “/etc/sonar-scanning-examples”)</li>
<li><p>Analyze a project:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"># On Windows:</div><div class="line">cd C:\sonar-scanning-examples\sonarqube-scanner</div><div class="line">C:\sonar-scanner\bin\sonar-scanner.bat</div><div class="line"> </div><div class="line"># On other operating system:</div><div class="line">cd /etc/sonar-scanning-examples/sonarqube-scanner</div><div class="line">/etc/sonar-scanner/bin/sonar-scanner</div></pre></td></tr></table></figure>
</li>
<li><p>Browse the results at <a href="http://localhost:9000" target="_blank" rel="external">http://localhost:9000</a> (default System administrator credentials are admin/admin)</p>
</li>
</ol>
<h3 id="文档"><a href="#文档" class="headerlink" title="文档"></a>文档</h3><ul>
<li><a href="https://docs.sonarqube.org/display/HOME/SonarQube+Platform" target="_blank" rel="external">docs.sonarqube.org</a></li>
<li></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css&quot;&gt;&lt;h3 id=&quot;步骤&quot;&gt;&lt;a href=&quot;#步骤&quot; class=&quot;headerli
    
    </summary>
    
      <category term="工具" scheme="https://madordie.github.io/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="构建" scheme="https://madordie.github.io/tags/%E6%9E%84%E5%BB%BA/"/>
    
      <category term="Sonarqube" scheme="https://madordie.github.io/tags/Sonarqube/"/>
    
  </entry>
  
  <entry>
    <title>「转」真实世界中的 Swift 性能优化</title>
    <link href="https://madordie.github.io/real-world-swift-performance/"/>
    <id>https://madordie.github.io/real-world-swift-performance/</id>
    <published>2017-01-17T11:14:57.000Z</published>
    <updated>2017-08-14T02:06:37.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>原文链接：<a href="https://realm.io/cn/news/real-world-swift-performance/" target="_blank" rel="external">真实世界中的 Swift 性能优化</a></p>
<a id="more"></a>
<hr>
<p>有太多的因素会导致您的应用变得缓慢。在本次讲演中，我们将自底向上地来探索应用的性能优化。来看一看在真实世界中进行数据解析、数据映射和数据存储的时候，Swift 的特性（协议、泛型、结构体和类）是如何影响应用性能的，我们将确定影响性能提升的瓶颈所在，并体验 Swift 带来的「迅捷」体验。</p>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>今天我打算同大家谈论 Swift 性能优化方面的内容。当我们构建软件的时候，特别是移动软件，由于人们的精力、时间有限，人们往往更喜欢有一个流畅的用户体验，而不是等着您的应用在那加载。如果应用运行速度过慢，并且不能给用户带来他们所想要的结果的话，那么这会让人们感到不爽。因此，让您的代码能够快速运行是无比重要的一件事。</p>
<p>那么有什么因素会导致代码运行缓慢呢？当您在编写代码并选择架构的时候，深刻认识到这些架构所带来的影响是非常重要的。我将首先谈一谈：如何理解内联、动态调度与静态调度之间的权衡，以及相关结构是如何分配内存的，还有怎样选择最适合的架构。</p>
<h2 id="内存分配"><a href="#内存分配" class="headerlink" title="内存分配"></a>内存分配</h2><p>对象的内存分配 (allocation) 和内存释放 (deallocation) 是代码中最大的开销之一，同时通常也是不可避免的。Swift 会自行分配和释放内存，此外它存在两种类型的分配方式。</p>
<p>第一个是基于栈 (stack-based) 的内存分配。Swift 会尽可能选择在栈上分配内存。栈是一种非常简单的数据结构；数据从栈的底部推入 (push)，从栈的顶部弹出 (pop)。由于我们只能够修改栈的末端，因此我们可以通过维护一个指向栈末端的指针来实现这种数据结构，并且在其中进行内存的分配和释放只需要重新分配该整数即可。</p>
<p>第二个是基于堆 (heap-based) 的内存分配。这使得内存分配将具备更加动态的生命周期，但是这需要更为复杂的数据结构。要在堆上进行内存分配的话，您需要锁定堆当中的一个空闲块 (free block)，其大小能够容纳您的对象。因此，我们需要找到未使用的块，然后在其中分配内存。当我们需要释放内存的时候，我们就必须搜索何处能够重新插入该内存块。这个操作很缓慢。主要是为了线程安全，我们必须要对这些东西进行锁定和同步。</p>
<h2 id="引用计数"><a href="#引用计数" class="headerlink" title="引用计数"></a>引用计数</h2><p>我们还有引用计数 (reference counting) 的概念，这个操作相对不怎么耗费性能，但是由于使用次数很多，因此它带来的性能影响仍然是很大的。引用计数是 Objective-C 和 Swift 中用于确定何时该释放对象的安全机制。目前，Swift 当中的引用计数是强制自动管理的，这意味着它很容易被开发者们所忽略。然而，当您打开 Instrument 查看何处影响了代码运行的速度的时候，您会发现 20,000 多次的 Swift 持有 (retain) 和释放 (release)，这些操作占用了 90% 的代码运行时间！<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">perform</span><span class="params">(with object: Object)</span></span> &#123;</div><div class="line">    object.doAThing()</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这是因为如果有这样一个函数接收了一个对象作为参数，并且执行了这个对象的 doAThing() 方法，编译器会自动插入对象持有和释放操作，以确保在这个方法的生命周期当中，这个对象不会被回收掉。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">perform</span><span class="params">(with object: Object)</span></span> &#123;</div><div class="line">    __swift_retain(object)</div><div class="line">    object.doAThing()</div><div class="line">    __swift_release(object)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这些对象持有和释放操作是原子操作 (atomic operations)，所以它们运转缓慢就很正常了。或者，是因为我们不知道如何让它们能够运行得更快一些。</p>
<h2 id="调度与对象"><a href="#调度与对象" class="headerlink" title="调度与对象"></a>调度与对象</h2><p>此外还有调度 (dispatch) 的概念。Swift 拥有三种类型的调度方式。Swift 会尽可能将函数内联 (inline)，这样的话使用这个函数将不会有额外的性能开销。这个函数可以直接调用。静态调度 (static dispatch) 本质上是通过 V-table 进行的查找和跳转，这个操作会花费一纳秒的时间。然后动态调度 (dynamic dispatch) 将会花费大概五纳秒的时间，如果您只有几个这样的方法调用的话，这实际上并不会带来多大的问题，问题是当您在一个嵌套循环或者执行上千次操作当中使用了动态调度的话，那么它所带来的性能耗费将成百上千地累积起来，最终影响应用性能。</p>
<p>Swift 同样也有两种类型的对象。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Index</span> </span>&#123;</div><div class="line">    <span class="keyword">let</span> section: <span class="type">Int</span></div><div class="line">    <span class="keyword">let</span> item: <span class="type">Int</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> i = <span class="type">Index</span>(section: <span class="number">1</span>,</div><div class="line">                item: <span class="number">1</span>)</div></pre></td></tr></table></figure></p>
<p>这是一个类，类当中的数据都会在堆上分配内存。您可以在此处看到，这里我们创建了一个名为 Index 的类。其中包含了两个属性，一个 section 和一个 item。当我们创建了这个对象的时候，堆上便创建了一个指向此 Index 的指针，因此在堆上便存放了这个 section 和 item 的数据和空间。</p>
<p>如果我们对其建立引用，就会发现我们现在有两个指向堆上相同区域的指针了，它们之间是共享内存的。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Index</span> </span>&#123;</div><div class="line">    <span class="keyword">let</span> section: <span class="type">Int</span></div><div class="line">    <span class="keyword">let</span> item: <span class="type">Int</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> i = <span class="type">Index</span>(section: <span class="number">1</span>,</div><div class="line">                item: <span class="number">1</span>)</div><div class="line"></div><div class="line"><span class="keyword">let</span> i2 = i</div></pre></td></tr></table></figure></p>
<p>这个时候，Swift 会自动插入对象持有操作。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Index</span> </span>&#123;</div><div class="line">    <span class="keyword">let</span> section: <span class="type">Int</span></div><div class="line">    <span class="keyword">let</span> item: <span class="type">Int</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> i = <span class="type">Index</span>(section: <span class="number">1</span>,</div><div class="line">                item: <span class="number">1</span>)</div><div class="line"></div><div class="line">__swift_retain(i)</div><div class="line"><span class="keyword">let</span> i2 = i</div></pre></td></tr></table></figure></p>
<h2 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h2><p>很多人都会说：要编写性能优异的 Swift 代码，最简单的方式就是使用结构体了，结构体通常是一个很好的结构，因为结构体会存储在栈上，并且通常会使用静态调度或者内联调度。</p>
<p>存储在栈上的 Swift 结构体将占用三个 Word 大小。如果您的结构体当中的数据数量低于三种的话，那么结构体的值会自动在栈上内联。Word 是 CPU 当中内置整数的大小，它是 CPU 所工作的区块。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Index</span> </span>&#123;</div><div class="line">    <span class="keyword">let</span> section: <span class="type">Int</span></div><div class="line">    <span class="keyword">let</span> item: <span class="type">Int</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> i = <span class="type">Index</span>(section: <span class="number">1</span>, item: <span class="number">1</span>)</div></pre></td></tr></table></figure></p>
<p>在这里您可以看到，当我们创建这个结构体的时候，带有 section 和 item 值得 Index 结构体将会直接下放到栈当中，这个时候不会有额外的内存分配发生。那么如果我们在别处将其赋值到另一个变量的时候，会发生什么呢？<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Index</span> </span>&#123;</div><div class="line">    <span class="keyword">let</span> section: <span class="type">Int</span></div><div class="line">    <span class="keyword">let</span> item: <span class="type">Int</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> i = <span class="type">Index</span>(section: <span class="number">1</span>, item: <span class="number">1</span>)</div><div class="line"><span class="keyword">let</span> i2 = i</div></pre></td></tr></table></figure></p>
<p>如果我们将 i 赋给 i2，这会将我们存储在栈当中的值直接再次复制一遍，这个时候并不会出现引用的情况。这就是所谓的「值类型」。</p>
<p>那么如果结构体当中存放了引用类型的话又会怎样呢？持有内联指针的结构体。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">User</span> </span>&#123;</div><div class="line">    <span class="keyword">let</span> name: <span class="type">String</span></div><div class="line">    <span class="keyword">let</span> id: <span class="type">String</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> u = <span class="type">User</span>(name: <span class="string">"Joe"</span>, id: <span class="string">"1234"</span>)</div></pre></td></tr></table></figure></p>
<p>当我们将其赋值给别的变量的时候，我们就持有了共享两个结构体的相同指针，因此我们必须要对这两个指针进行持有操作，而不是在对象上执行单独的持有操作。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">User</span> </span>&#123;</div><div class="line">    <span class="keyword">let</span> name: <span class="type">String</span></div><div class="line">    <span class="keyword">let</span> id: <span class="type">String</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> u = <span class="type">User</span>(name: <span class="string">"Joe"</span>,</div><div class="line">             id: <span class="string">"1234"</span>)</div><div class="line">__swift_retain(u.name._textStorage)</div><div class="line">__swift_retain(u.id._textStorage)</div><div class="line"><span class="keyword">let</span> u2 = u</div></pre></td></tr></table></figure></p>
<p>如果其中包含了类的话，那么性能耗费会更大。</p>
<h2 id="抽象类型"><a href="#抽象类型" class="headerlink" title="抽象类型"></a>抽象类型</h2><p>正如我们此前所述，Swift 提供了许多不同的抽象类型 (abstraction)，从而允许我们自行决定代码该如何运行，以及决定代码的性能特性。现在我们来看一看抽象类型是如何在实际环境当中使用的。这里有一段很简单的代码：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Circle</span> </span>&#123;</div><div class="line">    <span class="keyword">let</span> radius: <span class="type">Double</span></div><div class="line">    <span class="keyword">let</span> center: <span class="type">Point</span></div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">draw</span><span class="params">()</span></span> &#123;&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> circles = (<span class="number">1</span>..&lt;<span class="number">100_000_000</span>).<span class="built_in">map</span> &#123; <span class="number">_</span> <span class="keyword">in</span> <span class="type">Circle</span>(...) &#125;</div><div class="line"></div><div class="line"><span class="keyword">for</span> circle <span class="keyword">in</span> circles &#123;</div><div class="line">    circle.draw()</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这里有一个带有 radius 和 center 属性的 Circle 结构体。它将占用三个 Word 大小的空间，并存储在栈上。我们创建了一亿个 Circle，然后我们遍历这些 Circle 并调用这个函数。在我的电脑上，这段操作在发布模式下耗费了 0.3 秒的时间。那么当需求发生变更的时候，会发生什么事呢？</p>
<p>我们不仅需要绘圆，还需要能够处理多种类型的形状。让我们假设我们还需要绘线。我非常喜欢面向协议编程，因为它允许我在不使用继承的情况下实现多态性，并且它允许我们只需要考虑这个「抽象类型」即可。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">protocol Drawable &#123;</div><div class="line">    func draw()</div><div class="line">&#125;</div><div class="line"></div><div class="line">struct Circle: Drawable &#123;</div><div class="line">    let radius: Double</div><div class="line">    let center: Point</div><div class="line">    func draw() &#123;&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">let drawables: [Drawable] = (1..&lt;100_000_000).map &#123; _ in Circle(...) &#125;</div><div class="line"></div><div class="line">for drawable in drawables &#123;</div><div class="line">    drawable.draw()</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>我们需要做的，就是将这个 draw 方法析取到协议当中，然后将数组的引用类型变更为这个协议，这样做导致这段代码花费了 4.0 秒的时间来运行。速率减慢了 1300%，这是为什么呢？</p>
<p>这是因为此前的代码可以被静态调度，从而在没有任何堆应用建立的情况下仍能够执行。这就是协议是如何实现的。</p>
<p>例如，如大家所见，这里是我们此前的 Circle 结构体。在这个 for 循环当中，Swift 编译器所做的就是前往 V-table 进行查找，或者直接将 draw 函数内联。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">struct Circle &#123;</div><div class="line">    let radius: Double</div><div class="line">    let center: Point</div><div class="line">    func draw() &#123;&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">var circles = (1..&lt;100_000_000).map &#123; _ in Circle(...) &#125;</div><div class="line"></div><div class="line">for circle in circles &#123;</div><div class="line">    circle.draw()</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当我们用协议来替代的时候，此时它并不知道这个对象是结构体还是类。因为这里可能是任何一个实现此协议的类型。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">protocol Drawable &#123;</div><div class="line">    func draw()</div><div class="line">&#125;</div><div class="line"></div><div class="line">struct Circle: Drawable &#123;</div><div class="line">    let radius: Double</div><div class="line">    let center: Point</div><div class="line"></div><div class="line">    func draw() &#123;&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">var drawables: [Drawable] = (1..&lt;100_000_000).map &#123; _ in return Circle(...) &#125;</div><div class="line"></div><div class="line">for drawable in drawables &#123;</div><div class="line">    drawable.draw()</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>那么我们该如何去调度这个 draw 函数呢？答案就位于协议记录表 (protocol witness table，也称为虚函数表) 当中。它其中存放了您应用当中每个实现协议的对象名，并且在底层实现当中，这个表本质上充当了这些类型的别名。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">protocol Drawable &#123;</div><div class="line">    func draw()</div><div class="line">&#125;</div><div class="line"></div><div class="line">struct Circle: Drawable &#123;</div><div class="line">    let radius: Double</div><div class="line">    let center: Point</div><div class="line"></div><div class="line">    func draw() &#123;&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">var drawables: [Drawable] = (1..&lt;100_000_000).map &#123; _ in</div><div class="line">    return Circle(...)</div><div class="line">&#125;</div><div class="line"></div><div class="line">for drawable in drawables &#123;</div><div class="line">    drawable.draw()</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在这里的代码当中，我们该如何获取协议记录表呢？答案就是从这个既有容器 (existential container) 当中获取，这个容器目前拥有一个三个字大小的结构体，并且存放在其内部的值缓冲区当中，此外还与协议记录表建立了引用关系。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">struct Circle: Drawable &#123;</div><div class="line">    let radius: Double</div><div class="line">    let center: Point</div><div class="line"></div><div class="line">    func draw() &#123;&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里 Circle 类型存放在了三个字大小的缓冲区当中，并且不会被单独引用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">struct Line: Drawable &#123;</div><div class="line">    let origin: Point</div><div class="line">    let end: Point</div><div class="line"></div><div class="line">    func draw() &#123;&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>举个例子，对于我们的 Line 类型来说，它其中包含了四个字的存储空间，因为它拥有两个点类型。这个 Line 结构体需要超过四个字以上的存储空间。我们该如何处理它呢？这会对性能有影响么？好吧，它的确会：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">protocol Drawable &#123;</div><div class="line">    func draw()</div><div class="line">&#125;</div><div class="line"></div><div class="line">struct Line: Drawable &#123;</div><div class="line">    let origin: Point</div><div class="line">    let end: Point</div><div class="line">    func draw() &#123;&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">let drawables: [Drawable] = (1..&lt;100_000_000).map &#123; _ in Line(...) &#125;</div><div class="line"></div><div class="line">for drawable in drawables &#123;</div><div class="line">    drawable.draw()</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这需要花费 45 秒钟的时间来运行。为什么这里要花这么久的时间呢，发生了什么事呢？</p>
<p>绝大部分的时间都花费在对结构体进行内存分配上了，因为现在它们无法存放在只有三个字大小的缓冲区当中了。因此这些结构会在堆上进行内存分配，此外这也与协议有一点关系。由于既有容器只能够存储三个字大小的结构体，或者也可以与对象建立引用关系，我们同样需要某种名为值记录表 (value witness table)。这就是我们用来处理任意值的东西。</p>
<p>因此在这里，编译器将创建一个值记录表，对每个���缓冲区、内敛结构体来说，都有三个字大小的缓冲区，然后它将负责对值或者类进行内存分配、拷贝、销毁和内存释放等操作。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">func draw(drawable: Drawable) &#123;</div><div class="line">    drawable.draw()</div><div class="line">&#125;</div><div class="line"></div><div class="line">let value: Drawable = Line()</div><div class="line">draw(local: value)</div><div class="line"></div><div class="line">// Generates</div><div class="line">func draw(value: ECTDrawable) &#123;</div><div class="line">    var drawable: ECTDrawable = ECTDrawable()</div><div class="line">    let vwt = value.vwt</div><div class="line">    let pwt = value.pwt</div><div class="line">    drawable.vwt = value.vwt</div><div class="line">    drawable.pwt = value.pwt</div><div class="line">    vwt.allocateBuffAndCopyValue(&amp;drawable, value)</div><div class="line">    pwt.draw(vwt.projectBuffer(&amp;drawable)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里是一个例子，这就是这个过程的中间产物。如果我们只有一个 draw 函数，那么它将会接受我们创建的 Line 作为参数，因此我们将它传递给这个 draw 函数即可。</p>
<p>实际情况时，它将这个 Drawable 协议传递到既有容器当中，然后在函数内部再次进行创建。这会对值和协议记录表进行赋值，然后分配一个新的缓冲区，然后将其他结构、类或者类似对象的值拷贝进这个缓冲区当中。然后就使用协议记录表当中的 draw 函数，把真实的 Drable 对象传递给这个函数。</p>
<p>您可以看到，值记录表和协议记录表将会存放在栈上，而 Line 将会被存放在堆上，从而最后将线绘制出来。</p>
<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>对我们进行数据建模的方式进行简单的更改将会对性能造成巨大的影响。让我们来看一看该如何来避免这些情况的发生。</p>
<p>首先让我们来说一说泛型。大家可能会说了，我给各位展示了协议会导致性能的下降，那么我们为什么还要使用泛型呢？答案在于：泛型允许我们做什么。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">struct Stack&lt;T: Type&gt; &#123;</div><div class="line">...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>假设我们这里有一个带有泛型 T 的 Stack 结构体，它受到一个协议类型的约束。编译器所要做的，就是将这个 T 提换成相应的协议，或者替换为我们传入的具体类型。这些操作会一直沿着函数链 (function chain) 执行，并且编译器会创建直接对此类型进行操作的专用版本。</p>
<p>这样我们就无需再使用值记录表或者协议记录表了，并且还移除了既有容器，这可能是一个非常好的解决方式，这使得我们仍然能够写出真正快速运行的泛型代码，并且还具备 Swift 所提供的良好多态性。这就是所谓的静态多态性 (static polymorphism)。</p>
<p>您还可以通过使用枚举来改进数据模型，而不是从服务器中获取大量的字符串。例如，假设您正在构建一个社交应用，您需要对账户建立状态的管理，以前您可能会使用字符串来进行控制。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">enum AccountStatus: String, RawRepresentable &#123;</div><div class="line">case .banned, .verified, incomplete</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果我们改用枚举的话，那么我们就无需进行内存分配了，当我们传递这个类型的时候，我们只是将枚举值进行传递，这是一个加快代码运行速度的好方法，同时也可以为整个应用程序提供更安全、更可读的代码。</p>
<p>此外，使用 u-模型或者演示者 (Presenter) 或者不同的抽象类型的形式，来构建特定类型的模型也是非常有用的，这使得我们能够精简掉应用当中许多不必要的部分。</p>
<p>好的，我的讲演到此结束，内容很短，感谢诸位的参与！</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;原文链接：&lt;a href=&quot;https://realm.io/cn/news/real-world-swift-performance/&quot;&gt;真实世界中的 Swift 性能优化&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="iOS" scheme="https://madordie.github.io/categories/iOS/"/>
    
    
      <category term="优化" scheme="https://madordie.github.io/tags/%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>Swift 编译时性能优化笔记</title>
    <link href="https://madordie.github.io/swift-build-times/"/>
    <id>https://madordie.github.io/swift-build-times/</id>
    <published>2017-01-17T05:47:17.000Z</published>
    <updated>2017-08-14T02:06:43.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>Xcode在编译Swift代码的时候速度会越来越慢，就此查找原因，并列出自己的优化思路。</p>
<a id="more"></a>
<h3 id="Xcode8-2"><a href="#Xcode8-2" class="headerlink" title="Xcode8.2"></a>Xcode8.2</h3><p>添加<code>User-Defind</code>新的<code>SWIFT_WHOLE_MODULE_OPTIMIZATION = YES</code>可以过滤为修改framework。</p>
<h3 id="针对运算符-的优化"><a href="#针对运算符-的优化" class="headerlink" title="针对运算符??的优化"></a>针对运算符<code>??</code>的优化</h3><p>在使用<code>??</code>时，并不是所有的都需要优化，包裹在循环中的<code>??</code>会比较耗时比较厉害，目前不知道为啥，估计编译的时候需要检查的此时比较多吧😂。</p>
<h4 id="尝试显式解包"><a href="#尝试显式解包" class="headerlink" title="尝试显式解包"></a>尝试显式解包</h4><p><strong>思路</strong>：<code>??</code>编译慢，就不用<code>??</code>，直接使用<code>if else</code><br><strong>实施</strong>: 由于工程中使用的<code>??</code>比较多，所以比较修改起来比较麻烦。但是可以解决问题。真不行写方法转化调用喽。。</p>
<h4 id="错误的尝试了重载运算符-方式"><a href="#错误的尝试了重载运算符-方式" class="headerlink" title="错误的尝试了重载运算符??方式"></a>错误的尝试了重载运算符<code>??</code>方式</h4><p><strong>思路</strong>: <code>??</code>运算符编译耗时较多，直觉是<code>??</code>实现有复杂的操作,重新按照显式解包的方案进行实现。<br><strong>实施</strong>: </p>
<ul>
<li>分析<code>??</code>的使用场景，左侧为T?,右侧为T，返回值T</li>
<li>重载函数名定义<code>public func ?? &lt;T&gt;(left: T?, right: T) -&gt; T</code></li>
<li>实现</li>
<li>编译</li>
<li>error：<code>Ambiguous use of operator &#39;??&#39;</code></li>
<li>思考：这丫的在重载运算符的时候不能使用泛型吧。。</li>
<li>更改函数为<code>public func ?? &lt;Any&gt;(left: Any?, right: Any) -&gt; Any</code></li>
<li>PL. OK了，可是问题来了，系统的<code>??</code>是可以返回对应的类型，可是这样重载之后返回一个<code>Any</code>，代码中如果出现<code>let str = str1 ?? &quot;&quot;</code>则str类型就变为<code>Any</code>而不是<code>String</code>。<strong>巨坑</strong></li>
<li>顾不了那么多了，真不行一个一个跑。于是先修改一个较为严重的<code>String</code>类型。</li>
<li>尝试编译，结果时间惊人的没有变化。。依旧居高不下</li>
<li>以失败告终。。</li>
</ul>
<p><strong>总结</strong>: 这个<code>??</code>耗时较多并不是因为<code>??</code>的实现有问题，<strong>猜测</strong>是在为<code>??</code>准备左右参数的时候需要进行一层层的解包确定类型，再加上<code>??</code>可能有重载版本，进行类型匹配的时候比较耗时。</p>
<h4 id="尝试扩展方法进行优化"><a href="#尝试扩展方法进行优化" class="headerlink" title="尝试扩展方法进行优化"></a>尝试扩展方法进行优化</h4><p><strong>思路</strong>: 既然运算符会导致编译慢，那么就尝试使用方法直接进行转换。<br><strong>实现</strong>: 代码如下：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Operator</span> </span>&#123;</div><div class="line">    <span class="comment">///  ==&gt; ??</span></div><div class="line">    <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> `<span class="title">try</span>`&lt;T&gt;<span class="params">(<span class="number">_</span> origin: T?, <span class="number">_</span> then: T)</span></span> -&gt; <span class="type">T</span> &#123;</div><div class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> value = origin <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">return</span> then</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> value</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>测试发现上述方法可以优化时间。</p>
<hr>
<h3 id="以下原文出自：关于-Swift-编译时性能优化的一些思考"><a href="#以下原文出自：关于-Swift-编译时性能优化的一些思考" class="headerlink" title="以下原文出自：关于 Swift 编译时性能优化的一些思考"></a>以下原文出自：<a href="https://github.com/yllziv/gold-miner/blob/1bfbb3deefd27138097415422bec2bb7e98e9715/TODO/regarding-swift-build-time-optimizations.md" target="_blank" rel="external">关于 Swift 编译时性能优化的一些思考</a></h3><hr>
<blockquote>
<ul>
<li>原文链接 : <a href="https://medium.com/@RobertGummesson/regarding-swift-build-time-optimizations-fc92cdd91e31#.w81y3zhjr" target="_blank" rel="external">Regarding Swift build time optimizations</a></li>
<li>原文作者 : <a href="https://medium.com/@RobertGummesson" target="_blank" rel="external">Robert Gummesson</a></li>
<li>译文出自 : <a href="https://github.com/xitu/gold-miner" target="_blank" rel="external">掘金翻译计划</a></li>
<li>译者 : <a href="http://www.yanglonglong.com" target="_blank" rel="external">杨龙龙</a></li>
<li>校对者: <a href="https://github.com/shenAlexy" target="_blank" rel="external">申冠华</a>, <a href="https://github.com/Jack-Kingdom" target="_blank" rel="external">Jack King</a></li>
</ul>
</blockquote>
<p><img src="http://ww3.sinaimg.cn/large/005SiNxygw1f3p3jimjllj31jk0dwqft.jpg" alt=""></p>
<h4 id="关于-Swift-编译时性能优化的一些思考"><a href="#关于-Swift-编译时性能优化的一些思考" class="headerlink" title="关于 Swift 编译时性能优化的一些思考"></a>关于 Swift 编译时性能优化的一些思考</h4><p>上周，我读了 <a href="https://medium.com/@nickoneill" target="_blank" rel="external">@nickoneill</a> 一篇优秀的帖子 <a href="https://medium.com/swift-programming/speeding-up-slow-swift-build-times-922feeba5780#.k0pngnkns" target="_blank" rel="external">Speeding Up Slow Swift Build Times</a> 之后，我发现用一个略不同以往的角度去读Swift代码，并不是很难。</p>
<p>一行之前很简洁的代码，现在却出现了新的问题——它是否应该重构为9行代码来达到更快的编译速度？ (<em>nil coalescing 运算符就是一个例子</em>)孰轻孰重？简洁的代码还是对编译器友好的代码？ 我觉得，它取决于项目的大小和开发者的想法。</p>
<h4 id="但请等等…-这里有一个Xcode插件"><a href="#但请等等…-这里有一个Xcode插件" class="headerlink" title="但请等等… 这里有一个Xcode插件"></a>但请等等… 这里有一个Xcode插件</h4><p>在讲一些例子之前，我首先想到了通过手工提取日志信息是非常耗时的事情。通过命令行工具实现会相对容易一些，但是我把它往前推进了一步：集成为<a href="https://github.com/RobertGummesson/BuildTimeAnalyzer-for-Xcode" target="_blank" rel="external">Xcode插件</a>。</p>
<p><img src="http://ww1.sinaimg.cn/large/005SiNxygw1f3p3hhivppj30m809lwis.jpg" alt=""></p>
<p>在这个例子中，最初的目的仅仅是识别并修复代码中最耗时的地方，但是现在我觉得它成为了一个必须要迭代的过程。这样我才可以更加高效地构建代码，并且防止在项目中出现耗时的函数。</p>
<h4 id="不少惊喜"><a href="#不少惊喜" class="headerlink" title="不少惊喜"></a>不少惊喜</h4><p>我经常在不同的 Git 分支中跳转，并且等待一个暖慢的项目编译简直是在浪费我的生命。因此我思考了很长时间，一个玩具项目（大约两万行 Swift 代码）会编译如此长的时间。</p>
<p>当我知道是什么原因导致它如此慢之后，我不得不承认我震惊了，一行代码居然需要几秒的编译时间。</p>
<p>让我们来看几个例子。</p>
<h4 id="Nil-合并运算符"><a href="#Nil-合并运算符" class="headerlink" title="Nil 合并运算符"></a>Nil 合并运算符</h4><p>编译器肯定不喜欢这里的第一种方法。在展开下面两处简写的代码之后，构建时间减少了 <strong>99.4%</strong>。</p>
<pre><code>// 构建时间： 5238.3ms
return CGSize(width: size.width + (rightView?.bounds.width ?? 0) + (leftView?.bounds.width ?? 0) + 22, height: bounds.height)

// 构建时间： 32.4ms
var padding: CGFloat = 22
if let rightView = rightView {
    padding += rightView.bounds.width
}

if let leftView = leftView {
    padding += leftView.bounds.width
}
return CGSizeMake(size.width + padding, bounds.height)
</code></pre><h4 id="ArrayOfStuff-Stuff"><a href="#ArrayOfStuff-Stuff" class="headerlink" title="ArrayOfStuff + [Stuff]"></a>ArrayOfStuff + [Stuff]</h4><p>这个看起来像下面这样：</p>
<pre><code>return ArrayOfStuff + [Stuff]  
// 而不是  
ArrayOfStuff.append(stuff)  
return ArrayOfStuff
</code></pre><p>我经常这么做，并且它影响了每次构建的时间。下面是最糟糕的一个例子，改写后构建时间可以减少 <strong>97.9%</strong>。</p>
<pre><code>// 构建时间： 1250.3ms
let systemOptions = [ 7, 14, 30, -1 ]
let systemNames = (0...2).map{ String(format: localizedFormat, systemOptions[$0]) } + [NSLocalizedString(&quot;everything&quot;, comment: &quot;&quot;)]
// Some code in-between 
labelNames = Array(systemNames[0..&lt;count]) + [systemNames.last!]

// 构建时间： 25.5ms
let systemOptions = [ 7, 14, 30, -1 ]
var systemNames = systemOptions.dropLast().map{ String(format: localizedFormat, $0) }
systemNames.append(NSLocalizedString(&quot;everything&quot;, comment: &quot;&quot;))
// Some code in-between
labelNames = Array(systemNames[0..&lt;count])
labelNames.append(systemNames.last!)
</code></pre><h4 id="三元运算符"><a href="#三元运算符" class="headerlink" title="三元运算符"></a>三元运算符</h4><p>仅仅是通过替换三元运算符为 if else 语句就能减少 <strong>92.9%</strong> 的构建时间。如果使用一个for循环替换 <em>map</em> 函数，它又能减少另一个 75%（但是我的眼睛可就受不了咯😉）。</p>
<pre><code>// 构建时间： 239.0ms
let labelNames = type == 0 ? (1...5).map{type0ToString($0)} : (0...2).map{type1ToString($0)}

// 构建时间： 16.9ms
var labelNames: [String]
if type == 0 {
    labelNames = (1...5).map{type0ToString($0)}
} else {
    labelNames = (0...2).map{type1ToString($0)}
}
</code></pre><h4 id="转换-CGFloat-到-CGFloat"><a href="#转换-CGFloat-到-CGFloat" class="headerlink" title="转换 CGFloat 到 CGFloat"></a>转换 CGFloat 到 CGFloat</h4><p>这里我所说的并不一定正确。变量已经使用了 CGFloat 并且有一些括号也是多余的。在清理了这些冗余之后，构建时间能减少 <strong>99.9%</strong>。</p>
<pre><code>// 构建时间： 3431.7 ms
return CGFloat(M_PI) * (CGFloat((hour + hourDelta + CGFloat(minute + minuteDelta) / 60) * 5) - 15) * unit / 180

// 构建时间： 3.0ms
return CGFloat(M_PI) * ((hour + hourDelta + (minute + minuteDelta) / 60) * 5 - 15) * unit / 180
</code></pre><h4 id="Round"><a href="#Round" class="headerlink" title="Round()"></a>Round()</h4><p>这个一个非常奇怪的例子，下面的例子中变量是一个局部变量与实例变量的混合。这个问题可能不是四舍五入本身，而是结合代码的方法。去掉四舍五入的方法大概能减少 <strong>97.6%</strong> 的构建时间。</p>
<pre><code>// 构建时间： 1433.7ms
let expansion = a — b — c + round(d * 0.66) + e
// 构建时间： 34.7ms
let expansion = a — b — c + d * 0.66 + e
</code></pre><p>注意：所有的测试都在 MacBook Air (13-inch, Mid 2013)中进行。</p>
<h4 id="尝试它"><a href="#尝试它" class="headerlink" title="尝试它"></a>尝试它</h4><p>无论你是否面临过构建时间太长的问题，编写对编译器友好的代码都是非常有用的。我确定你自己会在其中找到一些惊喜。作为参考，这里有完整的代码，在我的工程中可以5秒内完成编译…</p>
<pre><code>import UIKit

class CMExpandingTextField: UITextField {

    func textFieldEditingChanged() {
        invalidateIntrinsicContentSize()
    }

    override func intrinsicContentSize() -&gt; CGSize {
        if isFirstResponder(), let text = text {
            let size = text.sizeWithAttributes(typingAttributes)
            return CGSize(width: size.width + (rightView?.bounds.width ?? 0) + (leftView?.bounds.width ?? 0) + 22, height: bounds.height)
        }
        return super.intrinsicContentSize()
    }
}
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Xcode在编译Swift代码的时候速度会越来越慢，就此查找原因，并列出自己的优化思路。&lt;/p&gt;
    
    </summary>
    
      <category term="iOS" scheme="https://madordie.github.io/categories/iOS/"/>
    
    
      <category term="优化" scheme="https://madordie.github.io/tags/%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>Fastlane自动化笔记</title>
    <link href="https://madordie.github.io/fastlane-note/"/>
    <id>https://madordie.github.io/fastlane-note/</id>
    <published>2017-01-04T10:14:07.000Z</published>
    <updated>2017-08-14T02:20:27.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>之前在搭建Jenkins的时候，由于看到Fastlane的配置好复杂，那么多，而当时的需求就是自动打包。。所以没有用，现在想来好气！今天翻到InfoQ的一个文章，又详细的了解了Fastlane之后，觉得此大法甚好，解决很多痛点！决定搞通这一切！<br>回看之前的<a href="https://madordie.github.io/build-ipa-sh">build-ipa-sh.md</a>确实比较僵硬。自动化还是很棒的。</p>
<a id="more"></a>
<h1 id="基本知识"><a href="#基本知识" class="headerlink" title="基本知识"></a>基本知识</h1><p>  (<a href="http://icyleaf.com" target="_blank" rel="external">@icyleaf</a>)在<a href="https://icyleaf.com/2016/07/intro-fastlane-automation-for-ios-and-android/" target="_blank" rel="external">Fastlane - iOS 和 Android 的自动化构建工具</a>中说到：</p>
<blockquote>
<p>Fastlane 提供的流程的众多工具都是可以独立存在和使用（提供 cli 命令），也可以统一由 fastlane 来控制。它在使用中提出了两个概念：</p>
<pre><code>- action: Fastlane 的插件，截至当前内置 165 个至多，不过每个动作的颗粒度大小不一。查看详情
- lane: Fastlane 的任务（或者可以理解为命令），一个可以包含多个 lanes，通过 fastlane cli 传入制定的 lane 来执行。
</code></pre></blockquote>
<p>  自我感觉这句话这个对理解和使用很重要！</p>
<h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1><p>  Fastlane已被Fabric收购，所以按照其安装也很随意(<a href="https://fabric.io/features/distribution" target="_blank" rel="external">戳我配置</a>)。<br>  对于打包，</p>
<h1 id="文章"><a href="#文章" class="headerlink" title="文章"></a>文章</h1><ul>
<li><a href="http://icyleaf.com/2016/07/fastlane-in-action/" target="_blank" rel="external">深入浅出 Fastlane 一看你就懂</a></li>
<li><a href="http://blog.fir.im/fir_im_weekly160505" target="_blank" rel="external">fir.im weekly - 「 持续集成 」实践教程合集</a></li>
<li><a href="https://everettjf.github.io/2015/09/08/ios-ci-with-fastlane" target="_blank" rel="external">使用fastlane实现iOS持续集成</a></li>
<li><a href="https://docs.fastlane.tools" target="_blank" rel="external">fastlane docs</a></li>
<li><a href="https://github.com/fastlane/fastlane" target="_blank" rel="external">fastlane GitHub</a></li>
<li><a href="http://www.infoq.com/cn/articles/actual-combat-of-fastlane-part01" target="_blank" rel="external">Fastlane实战（一）：移动开发自动化之道</a></li>
<li><a href="http://www.infoq.com/cn/articles/actual-combat-of-fastlane-part02" target="_blank" rel="external">Fastlane实战（二）：Action和Plugin机制</a></li>
<li><a href="http://www.infoq.com/cn/articles/actual-combat-of-fastlane-part03" target="_blank" rel="external">Fastlane实战（三）：Fastlane在Android平台的应用</a></li>
<li><a href="http://www.infoq.com/cn/articles/fastlane-automatic-testing" target="_blank" rel="external">Fastlane实战（四）：自动化测试篇</a></li>
<li><a href="http://www.infoq.com/cn/articles/fastlane-pro-tips" target="_blank" rel="external">Fastlane实战（五）：高级用法</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;之前在搭建Jenkins的时候，由于看到Fastlane的配置好复杂，那么多，而当时的需求就是自动打包。。所以没有用，现在想来好气！今天翻到InfoQ的一个文章，又详细的了解了Fastlane之后，觉得此大法甚好，解决很多痛点！决定搞通这一切！&lt;br&gt;回看之前的&lt;a href=&quot;https://madordie.github.io/build-ipa-sh&quot;&gt;build-ipa-sh.md&lt;/a&gt;确实比较僵硬。自动化还是很棒的。&lt;/p&gt;
    
    </summary>
    
      <category term="iOS" scheme="https://madordie.github.io/categories/iOS/"/>
    
    
      <category term="构建" scheme="https://madordie.github.io/tags/%E6%9E%84%E5%BB%BA/"/>
    
      <category term="Fastlane" scheme="https://madordie.github.io/tags/Fastlane/"/>
    
  </entry>
  
  <entry>
    <title>如何实现AppStore查看更多的方法</title>
    <link href="https://madordie.github.io/uitextkit-ellipsis-sth-at-the-end/"/>
    <id>https://madordie.github.io/uitextkit-ellipsis-sth-at-the-end/</id>
    <published>2016-12-23T08:37:37.000Z</published>
    <updated>2017-08-14T02:15:57.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>看到AppStore的<code>更多</code>效果，做的不错哎，本文尝试采用<code>exclusionPaths</code>进行实现。不过有瑕疵。。来年用追加的方式在实现一下。感觉追加的方式比较简单。，</p>
<a id="more"></a>
<h1 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h1><p><img src="http://7xvzwi.com1.z0.glb.clouddn.com/UITextKit-AppStore-more-scene.gif://7xvzwi.com1.z0.glb.clouddn.com/leanote_new_logo.png" alt="效果图"></p>
<h1 id="简要说明"><a href="#简要说明" class="headerlink" title="简要说明"></a>简要说明</h1><p>  App Store中的查看更多动画是不是很给力？可是做起来确不知道如何下手？这里我提供一种UITextKit的方法来简单的实现一下。</p>
<p>  为了让例子简单，我就直接写了个more，那个view是自定义的，随便添加的，和本身的文本展示的并没有什么关系。</p>
<p>  为了让最后的那个moreView更加好用，增加了已经展开显示全部是否隐藏的控制。</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><p>  先看下Demo中调用吧：<br>  <figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> info = <span class="type">KTJExclusionLabel</span>()</div><div class="line">info.exclusionView = more</div><div class="line">info.isAutoHidenExclusionView = isAutoHiden.isOn</div><div class="line">info.numberOfLines = <span class="type">Int</span>.<span class="keyword">init</span>(line.text ?? <span class="string">""</span>) ?? <span class="number">0</span></div><div class="line">info.sizeToFit()</div></pre></td></tr></table></figure></p>
<p>  然后KTJExclusionLabel的实现：<br>  <figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">//  KTJExclusionLabel.swift</span></div><div class="line"><span class="comment">//  UITextKit-AppStore-more</span></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">//  Created by 孙继刚 on 2016/12/24.</span></div><div class="line"><span class="comment">//  Copyright © 2016年 madordie. All rights reserved.</span></div><div class="line"><span class="comment">//</span></div><div class="line"></div><div class="line"><span class="keyword">import</span> UIKit</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">KTJExclusionLabel</span>: <span class="title">UITextView</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">/// 行数</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">var</span> numberOfLines: <span class="type">Int</span> &#123;</div><div class="line">        <span class="keyword">set</span> &#123;</div><div class="line">            textContainer.maximumNumberOfLines = newValue</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">get</span> &#123;</div><div class="line">            <span class="keyword">return</span> textContainer.maximumNumberOfLines</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">var</span> isAutoHidenExclusionView: <span class="type">Bool</span> = <span class="literal">false</span></div><div class="line"></div><div class="line">    <span class="comment">/// 避让的view</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">weak</span> <span class="keyword">var</span> exclusionView: <span class="type">UIView</span>? &#123;</div><div class="line">        <span class="keyword">didSet</span> &#123;</div><div class="line">            setNeedsLayout()</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">override</span> <span class="keyword">init</span>(frame: <span class="type">CGRect</span>, textContainer: <span class="type">NSTextContainer</span>?) &#123;</div><div class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>(frame: frame, textContainer: textContainer)</div><div class="line">        setup()</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">required</span> <span class="keyword">init</span>?(coder aDecoder: <span class="type">NSCoder</span>) &#123;</div><div class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>(coder: aDecoder)</div><div class="line">        setup()</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">setup</span><span class="params">()</span></span> &#123;</div><div class="line">        isEditable = <span class="literal">true</span></div><div class="line">        textContainer.lineBreakMode = .byTruncatingTail</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">sizeToFit</span><span class="params">()</span></span> &#123;</div><div class="line">        <span class="comment">//  对其API还不熟悉，还没有找到如何一次判断出是否已经展示完全。。找到后再更</span></div><div class="line"></div><div class="line">        <span class="keyword">let</span> originLines = numberOfLines</div><div class="line">        numberOfLines = <span class="number">0</span></div><div class="line">        <span class="keyword">let</span> maxHeight = resizeThatFits(frame.size).height</div><div class="line">        numberOfLines = originLines</div><div class="line">        frame.size = resizeThatFits(frame.size)</div><div class="line"></div><div class="line">        exclusionView?.isHidden = <span class="literal">false</span></div><div class="line">        <span class="keyword">if</span> frame.height == maxHeight &#123;</div><div class="line">            frame.size = resizeThatFits(frame.size, isOver: <span class="literal">true</span>)</div><div class="line">            <span class="keyword">if</span> isAutoHidenExclusionView &#123;</div><div class="line">                exclusionView?.isHidden = <span class="literal">true</span></div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">resizeThatFits</span><span class="params">(<span class="number">_</span> size: CGSize, isOver: Bool = <span class="literal">false</span>)</span></span> -&gt; <span class="type">CGSize</span> &#123;</div><div class="line">        <span class="keyword">var</span> frame = <span class="type">CGRect</span>.zero</div><div class="line">        frame.size = size</div><div class="line"></div><div class="line">        textContainer.exclusionPaths.removeAll()</div><div class="line"></div><div class="line">        <span class="keyword">var</span> ovalPaths = [<span class="type">UIBezierPath</span>]()</div><div class="line">        <span class="keyword">if</span> <span class="keyword">let</span> exclusionView = exclusionView &#123;</div><div class="line">            <span class="keyword">var</span> lastLineFrame = <span class="type">CGRect</span>.zero</div><div class="line">            <span class="keyword">var</span> lineIdx = <span class="number">0</span></div><div class="line">            <span class="keyword">var</span> lastFrame = <span class="type">CGRect</span>.zero</div><div class="line">            layoutManager.enumerateLineFragments(forGlyphRange: <span class="type">NSMakeRange</span>(<span class="number">0</span>, text.characters.<span class="built_in">count</span>)) &#123; (rect1, rect2, textContainer, range, pointer) <span class="keyword">in</span></div><div class="line">                <span class="keyword">if</span> lineIdx &lt; textContainer.maximumNumberOfLines &#123;</div><div class="line">                    lastLineFrame = rect2</div><div class="line">                &#125;</div><div class="line">                lineIdx += <span class="number">1</span></div><div class="line">                lastFrame = rect2</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="keyword">if</span> lastLineFrame == <span class="type">CGRect</span>.zero &#123;</div><div class="line">                lastLineFrame = lastFrame</div><div class="line">            &#125;</div><div class="line">            <span class="comment">//  矫正</span></div><div class="line">            lastLineFrame.origin.x += textContainerInset.<span class="keyword">left</span></div><div class="line">            lastLineFrame.origin.y += textContainerInset.top</div><div class="line"></div><div class="line">            <span class="comment">//  为末尾算出最大的frame</span></div><div class="line">            lastLineFrame.origin.x = lastLineFrame.maxX</div><div class="line">            lastLineFrame.origin.y = lastLineFrame.minY</div><div class="line">            lastLineFrame.size.width = frame.width - lastLineFrame.minX</div><div class="line">            lastLineFrame.size = exclusionView.sizeThatFits(lastLineFrame.size)</div><div class="line">            <span class="keyword">if</span> lastLineFrame.maxX &gt;= frame.width &#123;</div><div class="line"></div><div class="line">                <span class="keyword">if</span> isOver == <span class="literal">false</span> &#123;</div><div class="line">                    lastLineFrame.origin.x -= lastLineFrame.maxX - frame.width + <span class="built_in">max</span>(textContainerInset.bottom, textContainerInset.<span class="keyword">right</span>)</div><div class="line">                &#125; <span class="keyword">else</span> &#123;</div><div class="line">                    lastLineFrame.origin.x = lastFrame.minX + textContainerInset.<span class="keyword">left</span> + <span class="number">5</span></div><div class="line">                    lastLineFrame.origin.y += lastFrame.height</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            exclusionView.frame = convert(lastLineFrame, to: exclusionView.superview)</div><div class="line"></div><div class="line">            <span class="keyword">var</span> ovalFrame = convert(exclusionView.bounds, from: exclusionView)</div><div class="line">            ovalFrame.origin.x += <span class="number">5</span> + textContainerInset.<span class="keyword">left</span></div><div class="line">            ovalPaths.append(<span class="type">UIBezierPath</span>(rect: ovalFrame))</div><div class="line"></div><div class="line">            <span class="keyword">if</span> isOver, isAutoHidenExclusionView &#123;</div><div class="line">                frame.size.height = lastFrame.maxY + textContainerInset.bottom</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                frame.size.height = ovalFrame.maxY + textContainerInset.bottom</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            frame.size = <span class="keyword">super</span>.sizeThatFits(size)</div><div class="line">        &#125;</div><div class="line">        textContainer.exclusionPaths = ovalPaths</div><div class="line"></div><div class="line">        <span class="keyword">return</span> <span class="type">CGSize</span>(width: frame.maxX, height: frame.maxY)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>  代码只是简单的做了一个DEMO，并没有仔细的调试，如果使用的话可能看需要根据自己的需求进行简单的调试吧。比如说偏移量、布局之类的。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;看到AppStore的&lt;code&gt;更多&lt;/code&gt;效果，做的不错哎，本文尝试采用&lt;code&gt;exclusionPaths&lt;/code&gt;进行实现。不过有瑕疵。。来年用追加的方式在实现一下。感觉追加的方式比较简单。，&lt;/p&gt;
    
    </summary>
    
      <category term="iOS" scheme="https://madordie.github.io/categories/iOS/"/>
    
    
      <category term="效果" scheme="https://madordie.github.io/tags/%E6%95%88%E6%9E%9C/"/>
    
  </entry>
  
  <entry>
    <title>优雅的使用SwiftLint</title>
    <link href="https://madordie.github.io/elegant-to-use-swiftlint/"/>
    <id>https://madordie.github.io/elegant-to-use-swiftlint/</id>
    <published>2016-12-23T03:59:57.000Z</published>
    <updated>2017-08-14T02:20:22.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>接入了SwiftLine，修改2000+的warning、300+error的一点笔记心得。</p>
<a id="more"></a>
<h1 id="SwiftLint"><a href="#SwiftLint" class="headerlink" title="SwiftLint"></a>SwiftLint</h1><blockquote>
<h2 id="SwiftLint-1"><a href="#SwiftLint-1" class="headerlink" title="SwiftLint"></a><a href="https://github.com/realm/SwiftLint" target="_blank" rel="external">SwiftLint</a></h2><p>A tool to enforce Swift style and conventions, loosely based on GitHub’s Swift Style Guide.<br>  SwiftLint hooks into Clang and SourceKit to use the AST representation of your source files for more accurate results.<br>  SwiftLint 是一个用于强制检查 Swift 代码风格和规定的一个工具，基本上以 GitHub’s Swift 代码风格指南为基础。<br>  SwiftLint Hook 了 Clang 和 SourceKit 从而能够使用 AST 来表示源代码文件的更多精确结果。</p>
</blockquote>
<h2 id="对原有代码格式化"><a href="#对原有代码格式化" class="headerlink" title="对原有代码格式化"></a>对原有代码格式化</h2><h3 id="自动格式化"><a href="#自动格式化" class="headerlink" title="自动格式化"></a>自动格式化</h3>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">swiftlint autocorrect</div></pre></td></tr></table></figure>
<h3 id="TrailingWhitespaceRule"><a href="#TrailingWhitespaceRule" class="headerlink" title="TrailingWhitespaceRule"></a>TrailingWhitespaceRule</h3><h4 id="现象"><a href="#现象" class="headerlink" title="现象"></a>现象</h4><blockquote>
<p>xxx.swift:34: warning: Trailing Whitespace Violation: Lines should not have trailing whitespace. (trailing_whitespace)</p>
</blockquote>
<p>  规则实现：<a href="https://github.com/realm/SwiftLint/blob/master/Source/SwiftLintFramework/Rules/TrailingWhitespaceRule.swift" target="_blank" rel="external">TrailingWhitespaceRule.swift</a></p>
<h4 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h4><p>  Xcode中的”空白行”。其实并不空白，含有空的字符。最明显的表现为git提交的时候会有明显的黄色警告。</p>
<h4 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h4><p>  Xcode中有选项可以直接控制，具体路径为<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Xcode </div><div class="line">-&gt; Preferences</div><div class="line">-&gt; Text Editing</div><div class="line">-&gt; While editing</div><div class="line">-&gt; [V] Including whitespace-only lines</div></pre></td></tr></table></figure></p>
<h3 id="ColonRule"><a href="#ColonRule" class="headerlink" title="ColonRule"></a>ColonRule</h3><h4 id="现象-1"><a href="#现象-1" class="headerlink" title="现象"></a>现象</h4><blockquote>
<p>xxx.swift:13:71: warning: Colon Violation: Colons should be next to the identifier when specifying a type. (colon)</p>
</blockquote>
<h4 id="原因-1"><a href="#原因-1" class="headerlink" title="原因"></a>原因</h4><p>  变量方法的 <code>:</code> 的右边应该有一个空格才能识别出来，且左侧不能留空格。所以写代码的时候随手写上还是比较好的。。<br>  栗子：<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">//  OK:</div><div class="line">var responseData: [String : Any]? = nil // 返回结果，请求之前为nil</div><div class="line"></div><div class="line">//  warning: 第一个&apos;:&apos;处左侧有空格</div><div class="line">var responseData : [String : Any]? = nil // 返回结果，请求之前为nil</div><div class="line"></div><div class="line">//  warning: 第一个&apos;:&apos;处右侧无空格</div><div class="line">var responseData:[String : Any]? = nil // 返回结果，请求之前为nil</div></pre></td></tr></table></figure></p>
<h4 id="解决办法-1"><a href="#解决办法-1" class="headerlink" title="解决办法"></a>解决办法</h4><p>  规范书写</p>
<h3 id="LineLengthRule"><a href="#LineLengthRule" class="headerlink" title="LineLengthRule"></a>LineLengthRule</h3><h4 id="现象-2"><a href="#现象-2" class="headerlink" title="现象"></a>现象</h4><blockquote>
<p>xxx.swift:90: warning: Line Length Violation: Line should be 100 characters or less: currently 101 characters (line_length)</p>
</blockquote>
<h4 id="原因-2"><a href="#原因-2" class="headerlink" title="原因"></a>原因</h4><p>  行数超了呗。。</p>
<h4 id="解决办法-2"><a href="#解决办法-2" class="headerlink" title="解决办法"></a>解决办法</h4><ul>
<li>方法名字写的简单易懂</li>
</ul>
<h3 id="ControlStatementRule"><a href="#ControlStatementRule" class="headerlink" title="ControlStatementRule"></a>ControlStatementRule</h3><h4 id="现象-3"><a href="#现象-3" class="headerlink" title="现象"></a>现象</h4><blockquote>
<p>xxx.swift:169:21: warning: Control Statement Violation: if,for,while,do statements shouldn’t wrap their conditionals in parentheses. (control_statement)</p>
</blockquote>
<p>  规则实现<a href="https://github.com/realm/SwiftLint/blob/master/Source/SwiftLintFramework/Rules/ControlStatementRule.swift" target="_blank" rel="external">ControlStatementRule</a></p>
<h4 id="原因-3"><a href="#原因-3" class="headerlink" title="原因"></a>原因</h4><p>  swift中<code>if,for,while,do</code> 语句不应该用<code>()</code></p>
<h3 id="UnusedClosureParameterRule"><a href="#UnusedClosureParameterRule" class="headerlink" title="UnusedClosureParameterRule"></a>UnusedClosureParameterRule</h3><h4 id="现象-4"><a href="#现象-4" class="headerlink" title="现象"></a>现象</h4><blockquote>
<p>xxx.swift:103:62: warning: Unused Closure Parameter Violation: Unused parameter “response” in a closure should be replaced with _. (unused_closure_parameter)</p>
</blockquote>
<p>  规则实现<a href="https://github.com/realm/SwiftLint/blob/master/Source/SwiftLintFramework/Rules/UnusedClosureParameterRule.swift" target="_blank" rel="external">UnusedClosureParameterRule</a></p>
<h4 id="原因-4"><a href="#原因-4" class="headerlink" title="原因"></a>原因</h4><p>  <code>response</code> 没有使用，建议替换为 <code>_</code>。</p>
<h3 id="CyclomaticComplexityRule"><a href="#CyclomaticComplexityRule" class="headerlink" title="CyclomaticComplexityRule"></a>CyclomaticComplexityRule</h3><h4 id="现象-5"><a href="#现象-5" class="headerlink" title="现象"></a>现象</h4><blockquote>
<p>xxx.swift:69:5: warning: Cyclomatic Complexity Violation: Function should have complexity 10 or less: currently complexity equals 14 (cyclomatic_complexity)</p>
</blockquote>
<p>  规则实现<a href="https://github.com/realm/SwiftLint/blob/master/Source/SwiftLintFramework/Rules/CyclomaticComplexityRule.swift" target="_blank" rel="external">CyclomaticComplexityRule</a></p>
<h4 id="原因-5"><a href="#原因-5" class="headerlink" title="原因"></a>原因</h4><p>  😂，他说你这函数写的太复杂了。看实现是说不能有过多的<code>if {}</code></p>
<h3 id="OpeningBraceRule"><a href="#OpeningBraceRule" class="headerlink" title="OpeningBraceRule"></a>OpeningBraceRule</h3><h4 id="现象-6"><a href="#现象-6" class="headerlink" title="现象"></a>现象</h4><blockquote>
<p>xxx.swift:221:34: warning: Opening Brace Spacing Violation: Opening braces should be preceded by a single space and on the same line as the declaration. (opening_brace)</p>
</blockquote>
<p>  规则实现<a href="https://github.com/realm/SwiftLint/blob/master/Source/SwiftLintFramework/Rules/OpeningBraceRule.swift" target="_blank" rel="external">OpeningBraceRule</a></p>
<h4 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h4><p>  <code>{}</code>的前面要有空格隔开</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;接入了SwiftLine，修改2000+的warning、300+error的一点笔记心得。&lt;/p&gt;
    
    </summary>
    
      <category term="iOS" scheme="https://madordie.github.io/categories/iOS/"/>
    
    
      <category term="构建" scheme="https://madordie.github.io/tags/%E6%9E%84%E5%BB%BA/"/>
    
      <category term="SwiftLint" scheme="https://madordie.github.io/tags/SwiftLint/"/>
    
  </entry>
  
  <entry>
    <title>科学上网之搬瓦工ss搭建笔记</title>
    <link href="https://madordie.github.io/bandwagonhost-note/"/>
    <id>https://madordie.github.io/bandwagonhost-note/</id>
    <published>2016-12-19T12:37:11.000Z</published>
    <updated>2017-08-14T01:58:11.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>原来吧，用用goagent、Lantern、XX-Net，确实，这玩意只能Google出来结果，但是有的站点打不开才是最骚的。。<br>同事搞了个搬瓦工挺便宜，于是乎就也搞了一个。不过强迫症犯了，尝试了各种SS版本以及各种优化，目的是找个流畅点的版本进行<strong>科学上网</strong>。</p>
<a id="more"></a>
<h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><ul>
<li>红线越不得！红线越不得！红线越不得！重要的事情说3遍。</li>
<li>参看第一条</li>
<li>参看第一条</li>
<li><p>参看第一条</p>
<p>2017 07 18 say goog bay !</p>
</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;原来吧，用用goagent、Lantern、XX-Net，确实，这玩意只能Google出来结果，但是有的站点打不开才是最骚的。。&lt;br&gt;同事搞了个搬瓦工挺便宜，于是乎就也搞了一个。不过强迫症犯了，尝试了各种SS版本以及各种优化，目的是找个流畅点的版本进行&lt;strong&gt;科学上网&lt;/strong&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="工具" scheme="https://madordie.github.io/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="ss" scheme="https://madordie.github.io/tags/ss/"/>
    
  </entry>
  
</feed>
