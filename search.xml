<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[gitment自动初始化]]></title>
    <url>%2Fpost%2Fblog-gitment-auto-setup%2F</url>
    <content type="text"><![CDATA[一个ruby脚本解放你双手啪啪啪的敲键盘三分钟～ PS. ruby新手，轻拍。。 三是虚指。。 起因之前看到人家的私站都是用的GitHub做的评论系统。。很想要，但是人家没有用pages这样的玩意。。 今天看到味精大佬的RSS跪了，然后看到人家用的是GitHub的评论。。顿时觉得想要，23333 然后看了一哈 是这个：gitment 配置这个我就不说了，作者有写中文文档，看一眼就明白了。 列一下我的使用NexT主题的配置： 123456789101112131415# Gitment# Introduction: https://imsun.net/posts/gitment-introduction/gitment: enable: true mint: true # RECOMMEND, A mint on Gitment, to support count, language and proxy_gateway count: true # Show comments count in post meta area lazy: false # Comments lazy loading with a button cleanly: false # Hide 'Powered by ...' on footer, and more language: # Force language, or auto switch by theme github_user: xxxxxx # MUST HAVE, Your Github ID github_repo: xxxxxx # MUST HAVE, The repo you use to store Gitment comments client_id: xxxxxx # MUST HAVE, Github client id for the Gitment client_secret: xxxxxx # EITHER this or proxy_gateway, Github access secret token for the Gitment proxy_gateway: # Address of api proxy, See: https://github.com/aimingoo/intersect redirect_protocol: # Protocol of redirect_uri with force_redirect_protocol when mint enabled 自动初始化关于作者的初始化评论框方案讨论还在讨论中。。。 但是我要用。。等是不可能等的了。 看到自动初始化 Gitalk 和 Gitment 评论的脚本想着刚好我的也是自动发布、备份，这不是刚好嘛。。 但是存在多次执行就会多次创建的问题。这不是我想要的。 第一版：让脚本可以多次执行GitHub提供较为完善的API，用我这水水的rb水平，大致可以完善如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263# from : https://draveness.me/git-comments-initialize# 另外，token已放在.git-token文件下，防止泄漏。。username = "madordie" # GitHub 用户名token = `cat .git-token` # GitHub Tokenrepo_name = "madordie.github.io" # 存放 issuessitemap_url = "https://madordie.github.io/sitemap.xml" # sitemapkind = "gitment" # "Gitalk" or "gitment"require 'open-uri'require 'faraday'require 'active_support'require 'active_support/core_ext'require 'sitemap-parser'puts "正在检索URL"sitemap = SitemapParser.new sitemap_urlurls = sitemap.to_aputs "检索到文章共#&#123;urls.count&#125;个"conn = Faraday.new(:url =&gt; "https://api.github.com") do |conn| conn.basic_auth(username, token) conn.headers['Accept'] = "application/vnd.github.symmetra-preview+json" conn.adapter Faraday.default_adapterendcommenteds = Array.new` if [ ! -f .commenteds ]; then touch .commenteds fi`File.open(".commenteds", "r") do |file| file.each_line do |line| commenteds.push line endendurls.each_with_index do |url, index| if commenteds.include?("#&#123;url&#125;\n") == false response = conn.get "/search/issues?q=label:#&#123;url&#125;+state:open+repo:#&#123;username&#125;/#&#123;repo_name&#125;" if JSON.parse(response.body)['total_count'] &gt; 0 `echo #&#123;url&#125; &gt;&gt; .commenteds` else puts "正在创建: #&#123;url&#125;" title = open(url).read.scan(/&lt;title&gt;(.*?)&lt;\/title&gt;/).first.first.force_encoding('UTF-8') response = conn.post("/repos/#&#123;username&#125;/#&#123;repo_name&#125;/issues") do |req| req.body = &#123; body: url, labels: [kind, url], title: title &#125;.to_json end if JSON.parse(response.body)['number'] &gt; 0 `echo #&#123;url&#125; &gt;&gt; .commenteds` puts "\t↳ 已创建成功" else puts "\t↳ #&#123;response.body&#125;" end end endend 脚本OK，还需要安装一些库用这个就行： 1sudo gem install faraday activesupport sitemap-parser 正常情况都会安装成功，那么跑一下脚本吧： 1ruby comment.rb 第一次运行请求多，稍微等一会。表急。。 跑完之后如果你的链接总长度都是 &lt;= 50 字符，那么真嗨，这就行了。 但是如果以后有可能 &gt; 50，或者不确定以后会不会写一个链接贼长的文章，那么你可能还要往下再看一下。。 第二版：让脚本兼容文章链接很长长长关于这个的讨论很多，在issues中搜一下大约这样：Error: Validation Failed。 这个Error: Validation Failed就是label太长。 关于这个问题在API: Create a label并未提及。 但是在任何一个仓库下，按照Issues -&gt; New label的时候，输入的Label name是有限制的，输入超过50个自符之后便无法再接收输入。就酱，没找到什么文档。。 看了这个Validation Failed ID长度问题建议之后觉得，MD5一下吧那就。。 为了选择一个KEY去MD5，顺便解决一下同一个页面，带锚点#more会初始化一条新的issue这个问题， 所以KEY使用关于hexo博客单篇文章初始化两次的问题中提出的window.location.pathname吧，但是关于/的讨论，我这里貌似并没有看到，我的都是有的😂。。如果看到的话再更，或者保险期间，先按照这种方案更新一下。 将上面的做完，现在的rb应该长这个样子: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364# from : https://draveness.me/git-comments-initialize# 另外，token已放在.git-token文件下，防止泄漏。。username = "madordie" # GitHub 用户名token = `cat .git-token` # GitHub Tokenrepo_name = "madordie.github.io" # 存放 issuessitemap_url = "https://madordie.github.io/sitemap.xml" # sitemapkind = "gitment" # "Gitalk" or "gitment"require 'open-uri'require 'faraday'require 'active_support'require 'active_support/core_ext'require 'sitemap-parser'require 'digest'puts "正在检索URL"sitemap = SitemapParser.new sitemap_urlurls = sitemap.to_aputs "检索到文章共#&#123;urls.count&#125;个"conn = Faraday.new(:url =&gt; "https://api.github.com") do |conn| conn.basic_auth(username, token) conn.headers['Accept'] = "application/vnd.github.symmetra-preview+json" conn.adapter Faraday.default_adapterendcommenteds = Array.new` if [ ! -f .commenteds ]; then touch .commenteds fi`File.open(".commenteds", "r") do |file| file.each_line do |line| commenteds.push line endendurls.each_with_index do |url, index| if commenteds.include?("#&#123;url&#125;\n") == false url_key = Digest::MD5.hexdigest(URI.parse(url).path) response = conn.get "/search/issues?q=label:#&#123;url_key&#125;+state:open+repo:#&#123;username&#125;/#&#123;repo_name&#125;" if JSON.parse(response.body)['total_count'] &gt; 0 `echo #&#123;url&#125; &gt;&gt; .commenteds` else puts "正在创建: #&#123;url&#125;" title = open(url).read.scan(/&lt;title&gt;(.*?)&lt;\/title&gt;/).first.first.force_encoding('UTF-8') response = conn.post("/repos/#&#123;username&#125;/#&#123;repo_name&#125;/issues") do |req| req.body = &#123; body: url, labels: [kind, url_key], title: title &#125;.to_json end if JSON.parse(response.body)['number'] &gt; 0 `echo #&#123;url&#125; &gt;&gt; .commenteds` puts "\t↳ 已创建成功" else puts "\t↳ #&#123;response.body&#125;" end end endend 同时别忘了修改对应的网页。。我这里使用的是NexT（我已经记不得这是哪个版本了 抱歉。。） 需要修改/themes/next/layout/_third-party/comments/gitment.swig文件，由于JS不支持MD5,所以还需要引入一个JS，于是乎大约这样： 1234567891011121314151617 &#123;% if theme.gitment.mint %&#125; &#123;% set CommentsClass = &quot;Gitmint&quot; %&#125; &lt;link rel=&quot;stylesheet&quot; href=&quot;https://aimingoo.github.io/gitmint/style/default.css&quot;&gt; &lt;script src=&quot;https://aimingoo.github.io/gitmint/dist/gitmint.browser.js&quot;&gt;&lt;/script&gt;+ &lt;script src=&quot;https://cdn.bootcss.com/blueimp-md5/2.10.0/js/md5.min.js&quot;&gt;&lt;/script&gt; &#123;% else %&#125; &#123;% set CommentsClass = &quot;Gitment&quot; %&#125; &lt;link rel=&quot;stylesheet&quot; href=&quot;https://imsun.github.io/gitment/style/default.css&quot;&gt; &lt;script src=&quot;https://imsun.github.io/gitment/dist/gitment.browser.js&quot;&gt;&lt;/script&gt;+ &lt;script src=&quot;https://cdn.bootcss.com/blueimp-md5/2.10.0/js/md5.min.js&quot;&gt;&lt;/script&gt; &#123;% endif %&#125;... var gitment = new &#123;&#123;CommentsClass&#125;&#125;(&#123;- id: document.location.href,+ id: md5(window.location.pathname), owner: &apos;&#123;&#123; theme.gitment.github_user &#125;&#125;&apos;, repo: &apos;&#123;&#123; theme.gitment.github_repo &#125;&#125;&apos;, 至于这个MD5的引入，我是随便搜的一个。。这个if theme.gitment.mint我并不知道在哪里配置的，所以俩都加上吧。 执行一下脚本吧，应该齐活了。 最后 文中提到的关于链接/飘忽不定的事情我没碰到，我是直接取的sitemap，貌似每个网站都带了 文中的引用啥的我都标记了链接，如有漏掉、不明白，麻烦告诉我一哈，我去补一下 我只是个小小的iOS，对ruby、js懂得不多，rb写的不好的地方轻拍 哦对了，这脚本全部在这里：comment.rb。同时，这个脚本我又放在了自动发布的shell脚本里面，同样shell写的很水。。放在了这里：deploy.sh，而且是很早之前就写了的。。 如果还有什么问题，可以拉出来讨论一哈 ;)]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>gitment</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UIFont字体信息]]></title>
    <url>%2Fpost%2Fuifont-infos%2F</url>
    <content type="text"><![CDATA[iOS系统下字体信息。 环境信息 iOS12.0(16A5357b) iPhone6 代码123456789101112131415161718192021222324252627282930let label = UILabel()label.text = "这是啥"let format: (UIFont) -&gt; [String: Any] = &#123; (font) in label.font = font label.sizeToFit() return ["font.familyName": font.familyName, "font.fontName": font.fontName, "font.pointSize": font.pointSize, "font.ascender": font.ascender, "font.descender": font.descender, "font.capHeight": font.capHeight, "font.xHeight": font.xHeight, "font.lineHeight": font.lineHeight, "font.leading": font.leading, "label.sizeToFit": label.frame.height]&#125;var json: [String: [[String: Any]]] = [:]for family in UIFont.familyNames &#123; for name in UIFont.fontNames(forFamilyName: family) &#123; var list: [[String: Any]] = [] for size in 5...60 &#123; guard let font = UIFont.init(name: name, size: CGFloat(size)) else &#123; continue &#125; list.append(format(font)) &#125; json["\(family) -&gt; \(name)"] = list &#125;&#125;print(String(data:(try? JSONSerialization.data(withJSONObject: json, options: .prettyPrinted)) ?? Data(), encoding: .utf8)!) 长长的数据12 然而数据太多加载不出来。。]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>UIFont</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[从一个常见的崩溃开始]]></title>
    <url>%2Fpost%2Fdebug-sth-from-crash%2F</url>
    <content type="text"><![CDATA[昨天下班时候一朋友碰到一个下面的崩溃，但是全局断点却无法断到指定位置。鉴于不信邪的态度，决定尝试一番。然后将此事记录如下文。 1234*** Terminating app due to uncaught exception &apos;NSInvalidArgumentException&apos;, reason: &apos;-[__NSCFConstantString hasPrefix:]: nil argument&apos;*** First throw call stack:(0x18521ed8c .....)libc++abi.dylib: terminating with uncaught exception of type NSException 崩溃表现那老哥说他的APP运行之后，什么都不做，等待10s之后就会闪退，闪退的最重要信息是上面，栈结构上没有函数信息，只有地址。 打开全局断点，也无法直接断到指定的函数，这个信息我留了一张图，大致如下：(已脱敏) 先简单的分析一下 崩溃原因很明确:-[__NSCFConstantString hasPrefix:]: nil argument。 __NSCFConstantString为NSString类簇里面的一个类，常见的类似的还有很多。 - (BOOL)hasPrefix:(NSString *)str;中nil argument，也就是str为nil。 First throw call stack下方均为地址，说明此函数应该在一个.a/.framework中。 APP运行之后，什么都不做，等待10s之后就会闪退说明此崩溃为异步调用，至于是不是定时调用，这个真不好说。 由于我技术有限，别的好像提炼不出有用信息了。。 复现一下崩溃先来个简单的代码，验证一下 - (BOOL)hasPrefix:(NSString *)str;中nil argument，也就是str为nil。 123456#import &lt;Foundation/Foundation.h&gt;int main(int argc, char *argv[]) &#123; @autoreleasepool &#123; NSLog(@"%@", @([@"" hasPrefix:nil])); &#125;&#125; 运行一下，结果很意料之中，得出如下： 12345678910111213141516Untitled.m:4:29: warning: null passed to a callee that requires a non-null argument [-Wnonnull] NSLog(@"%@", @([@"" hasPrefix:nil])); ^ ~~~1 warning generated.Terminated due to signal: ABORT TRAP (6)2018-07-25 10:44:50.569 Untitled[53770:899141] *** Terminating app due to uncaught exception 'NSInvalidArgumentException', reason: '-[__NSCFConstantString hasPrefix:]: nil argument'*** First throw call stack:( 0 CoreFoundation 0x00007fff30aae2db __exceptionPreprocess + 171 1 libobjc.A.dylib 0x00007fff57c58c76 objc_exception_throw + 48 2 CoreFoundation 0x00007fff30b3fd7d +[NSException raise:format:] + 205 3 CoreFoundation 0x00007fff30a01840 -[__NSCFString hasPrefix:] + 96 4 Untitled 0x000000010787fd60 main + 64 5 libdyld.dylib 0x00007fff58872015 start + 1)libc++abi.dylib: terminating with uncaught exception of type NSException 经过1 warning generated之后，果断崩溃了，还有明确的崩溃时候栈结构。 好，问题确定了就是这个1 warning generated造成的。改下就完事咯～～ 寻找问题尝试解除warning远程进去之后我震惊了，warning: 999+。先快速找到问题，要什么自行车。。 Xcode中全局搜索hasPrefix关键字，带变量的全部加上断点。 run一下，问题依旧如此。。正如上面说的一样： First throw call stack下方均为地址，说明此函数应该在一个.a/.framework中。 GO DIE… PS. 关于hasPrefix函数的OC声明、swift声明均为完整字符串，所以安心全局搜索就能找到代码中已存在的hasPrefix函数 顺便搜了一下该项目不包含第三方.a, 但是.framework不少。。有CocoaPods集成有直接拖进来的。。 尝试Method Swizzling一下这玩意既然在别人的framework中，那就更新一下咯，但是全部更新并不可取。。 framework的更新可能导致一些不可预估的可变因素。比如说API修改、内部逻辑变更导致外部使用不兼容、某些开发者喜欢直接修改framework、等。 所以先确定是哪个framework。 Method Swizzling。将其-[__NSCFConstantString hasPrefix:]: nil argument直接过滤nil，岂不美滋滋～～ 好了先测试一下：1234567891011121314151617181920212223242526272829303132333435#import &lt;Foundation/Foundation.h&gt;#import &lt;objc/runtime.h&gt;@interface MySafeString : NSObject@end@implementation MySafeString+ (void)load &#123; Class originalClass = NSClassFromString(@"__NSCFConstantString"); Class swizzledClass = [self class]; SEL originalSelector = @selector(hasPrefix:); SEL swizzledSelector = @selector(safe_hasPrefix:); Method originalMethod = class_getInstanceMethod(originalClass, originalSelector); Method swizzledMethod = class_getInstanceMethod(swizzledClass, swizzledSelector); IMP originalIMP = method_getImplementation(originalMethod); IMP swizzledIMP = method_getImplementation(swizzledMethod); const char *originalType = method_getTypeEncoding(originalMethod); const char *swizzledType = method_getTypeEncoding(swizzledMethod); class_replaceMethod(originalClass,swizzledSelector,originalIMP,originalType); class_replaceMethod(originalClass,originalSelector,swizzledIMP,swizzledType);&#125;- (BOOL)safe_hasPrefix:(NSString *)str &#123; if (str == nil) &#123; return YES; &#125; else &#123; return [self safe_hasPrefix:str]; &#125;&#125;@endint main(int argc, char *argv[]) &#123; @autoreleasepool &#123; NSLog(@"%@", @([@"" hasPrefix:nil])); &#125;&#125; 输出： 12345Untitled.m:33:29: warning: null passed to a callee that requires a non-null argument [-Wnonnull] NSLog(@"%@", @([@"" hasPrefix:nil])); ^ ~~~1 warnings generated.2018-07-25 11:32:20.634 Untitled[54520:926937] 1 不崩溃了，赶紧粘过去，并在- (BOOL)safe_hasPrefix:(NSString *)str中的return YES;打上断点。 内心得到了极大的满足～ 美滋滋～～～ 2分钟后。 断点停了，向- (BOOL)safe_hasPrefix:(NSString *)str的str传nil的调用者是[MOBFErrorReportService writeHTTPErrorMsg:error:]。 将MOBFErrorReportService放入Google看到第二个就是这个[MOBFDevice duid] - BUG提交- Mob官方论坛。文中指出SDK 版本: ShareSDKVersion-3.5.1。 好了看一下ShareSDK这个库。emmm 这个库是拖拽进去的。老哥说这项目接手之后没更新过这个库。 事已至此，确定是ShareSDK的问题。 更新之，问题解决～ 真心的美滋滋～～ PS. 上文中关于类簇的 Method Swizzling，详见Method Swizzling的各种姿势。 寻找的过程部分特写上面的逻辑并不是一气呵成，而是由于粗心也走了部分弯路，特列出来引以为戒。 看到全局断点真的走不到时由于代码是公司代码，也没有demo,所以布吉岛为啥确实断点不会走。。。 MMP 看到了First throw call stack之后第一反应是，这些地址应该可以还原到对应的位置。 然后想到了逆向里面的骚操作。顿时想逆向分析一下。。。 但由于看了一下.app中的可执行文件有 40M ,算了算了，IDA载入的有点慢，这要好久才能分析完。。 想了想天要下雨，媳妇和娃都在外面。果断放弃分析一波的冲动，来Method Swizzling会更快。 看走眼的 Method Swizzling之前看过这个Method Swizzling的各种姿势文章，印象深刻。 由于 Method Swizzling 风险不那么容易控制，所以并没用类簇相关的。 一顿cmd c / cmd v之后改了类名就扔了过去。当时大约这个样子： 12345678- (BOOL)safe_hasPrefix:(NSString *)str &#123; if (str == nil) &#123; return YES; &#125; else &#123; // 此处会发生循环调用，是错误的示例 return [(NSString *)self hasPrefix:str]; &#125;&#125; 正如我刚在上面的备注一样。 脑袋一热，这类簇会不会有别的坑，然后过分的自信忽略了safe_前缀，并写了个C的前缀比较： 123456789101112131415161718- (BOOL)safe_hasPrefix:(NSString *)str &#123; if (str == nil) &#123; return NO; &#125; else if (((NSString *)self).length &lt; str.length) &#123; return NO; &#125; else &#123; // 此处逻辑并未经过很多的测试用例测试，只是临时修补。实际方案应该直接调用safe_hasPrefix const char *str1 = [str cStringUsingEncoding:NSUTF8StringEncoding]; const char *str2 = [(NSString *)self cStringUsingEncoding:NSUTF8StringEncoding]; for (NSInteger idx = str.length; idx &gt;= 0; idx--) &#123; if (str1[idx] != str2[idx]) &#123; return NO; &#125; &#125; return YES; &#125;&#125; 一番梭哈之后，定位到了问题。 但是今天复盘的时候想到这个类簇的IMP正常的操作也不可能出现循环调用。。。。 然后发现昨天的一番梭哈真的是弱智。。惭愧惭愧。。。 写在最后 解决问题的方案在于知识面的宽度。（一直为我没有通过First throw call stack直接定位而害羞） 着急下班的时候别写太多逻辑，容易漏。要么别着急，要么万分小心。 集成第三方SDK别瞎胡闹，使用代码直接集成(除非万不得已)。尽量使用CocoaPods这样的工具。 代码中的 warning 记得消一下。成天999+ 容易漏掉关键信息。 开发的第三方SDK一定要注意测试覆盖率。 swift大法好。swift不用!绝对不会有机会出现func hasPrefix(_ str: String) -&gt; Bool中参数str传空的可能 :)]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>DEBUG</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[sketech模块同步插件]]></title>
    <url>%2Fpost%2Fsync-sketchplugin%2F</url>
    <content type="text"><![CDATA[Sketch 模块同步插件通过该插件可以将sketch中的画板转换为data然后上传至服务器，并能通过插件将服务器的data下载至本地还原为之前的画板。 核心功能功能的实现都是通过Sketch.app的API实现 其核心功能就俩： 将画板编码 解码为画板 核心代码由于功能并不复杂，但是sketch并没有完整的API文档，所以只能摸索着来，最后总结一下用到的API，只有下面的几个重要函数。 但是要找到这些API并不是随手一个Google可以得到，现将其列出，方便你能随手Google一下就得到：） 另外，下面几部分的代码都通过CocoaScript的语法，所以可以直接应用到插件中。 为了能更好的理解和使用相关API，我尽量详细。 将画板编码本节会将所有已经选中的层所对应的画板转换为json字符串。 ps. 层包含sketch能够呈现的所有组件，包括但不限于：文本、矩形、图片、画板。 如果选中的层没有画板，将会被忽略。 123456789101112131415161718192021222324252627282930313233var selection = context.selection, artboards = [];for (var i = 0; i &lt; selection.count(); i++) &#123; try &#123; // 取出选中的所有画板 var artboard = selection[i].parentArtboard(); if (artboards.indexOf(artboard) == -1) &#123; // 过滤重复的画板 artboards.push(artboard); &#125; &#125; catch (error) &#123;&#125;&#125;if (artboards.length == 0) &#123; // 并无选中的任何画板 return;&#125;// 此时 artboards 数组， 即为当前选中的所有画板var selectionStrings = [];artboards.forEach(artboard =&gt; &#123; try &#123; // 将画板转为JSON字符串，并保存在 selectionStrings 数组中 selectionStrings.push(MSJSONDataArchiver.archiveStringWithRootObject_error_(artboard.immutableModelObject(), nil)); &#125; catch (error) &#123;&#125;&#125;);// 将selectionStrings数组转为数组JSON字符串var selectionsString = '[' + selectionStrings.join(',') + ']';// 此时selectionsString字符串即为当前选中的所有画板的json数组字符串形式。 解码为画板接上一节的selectionsString。 先将selectionsString转为page的json数据，然后解析为一个新的page，并居中展示。 123456789101112131415161718var selectionsString = res.layers, pageUUID = NSUUID.UUID().UUIDString(), // 用page的JSON包裹selectionsString，同时生成一个新的UUID pageString = '&#123;"_class":"page","do_objectID":"' + pageUUID + '","layers":' + selectionsString + '&#125;', data = NSString.alloc().initWithString(pageString).dataUsingEncoding_(4), // 将JSON解码 unarchive = MSJSONDataUnarchiver.unarchiveObjectWithData(data), // 生成新的page newPage = MSPage.alloc().initWithImmutableModelObject(unarchive), // 插入一个新的page page = MSDocument.currentDocument().addBlankPage();// 将生成的page所有的layers转移到新的page里面page.addLayers(newPage.layers());// 为page设置哥名字page.setName(res.project);// page剧中MSDocument.currentDocument().contentDrawView().centerLayersInCanvas();MSDocument.currentDocument().pageTreeLayoutDidChange(); 其他代码关于别的后端操作啊 什么的我认为并不是核心代码。那代码谁都会写。。毕竟我写这个的时候只有2周的摸索经验😂，还是不聊这个了。 sync-npm 插件相关的目录，采用skpm构建 sync-server 插件对应的服务端代码，采用Node-js构建 目前还存在的问题 如果是带图片的画板，并且较多的时候，selectionsString会很大，传输速度有点慢。。 UI交互有点吃藕。。最好开发一套macOS的UI，但是我还是只菜鸡。。 项目的代码我只是简简单单的连学带写2周做出来的。。写的不是一般的渣，见谅。。 你可能需要的参考资料 Sketch的头文件：Sketch-Headers，可以省去自己class-dump的麻烦. 插件开发神器：skpm 用来调试很不错：Sketch DevTools 官方开发文档：Sketch Developer 插件开发社区：Sketch Developers 插件使用的语言：CocoaScript，但是并不仅限这一种哟 推荐搜索引擎: Google，别问我为什么用Google不用百度，我是不会告诉你sketch插件开发本来资料就少，国内更少的。。 源码老规矩：madordie/sync-sketch-plugin]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>Sketchplugin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于日志打印和过滤的那点破事]]></title>
    <url>%2Fpost%2Freverse-ios-socat-watch-filter%2F</url>
    <content type="text"><![CDATA[前两天，重启电脑突然发现我的iOS8设备无法连接到MacOS了。。 MMP，也就是说没有办法使用Xcode调试、之前使用的日志查看也没有办法继续。。 具体报错如下：Xcode&lt;Version 9.4 (9F1027a)&gt;报错如下: (我安装过Xcode10 beta1) iTunes报错如下：1iTunes 无法连接 iPhone “iPhone”，因为收到来自此设备的无效响应。 Apple Configurator2报错如下：1已收到设备上的意外响应。 还是 先来聊一下日志打印的几种方案吧。 手机可以连接到MacOS这种情况是最常见的，就是能在Xcode下Debug…. 方案一：Console.app(控制台)这是MacOS自带的日志神器～ 效果顶呱呱👍👍👍，截图如下： 具体用法我就不说了。。。毕竟都是中文😂 方案二：LogGurumadordie/LogGuru 也不错，很久之前fork自FIRHQ/LogGuru，增加了直接过滤的功能，要不然速度真的很慢。。 只要插入USB，即可显示日志，还是不错滴。。 方案三: 其他的还有很多方案，比如说命令行啊、其他的工具啊，我就不说了，我觉得 Console.app(控制台) 就够了😂 手机无法链接进MacOS也就是最开始说的报错的情况下，可以连接进MacOS的方案均无法使用。苦逼，只能让iOS打印日志了。。 下面都是 越狱环境 下的。。不越狱还有人用iOS8么😂 先来看个文档：The iPhone Wiki/System Log,这里提供了很多方案，也非常全面，值得一试。 苦逼的事情是我手上的iOS8.4.1无法使用syslogd to /var/log/syslog插件，尝试使用On-device with saving to a file via a Python script的方案去解决也并不如意。。 开始用On-device with socat（ 在iosre中也有一个类似的文章：iOS查看日志利器 —— socat），说的都是相当的详细。 socat的坑stop没有用如iOS查看日志利器 —— socat所说： 输入watch查看，输入stop停止（不过停止貌似没用，也不知道为啥，知道的请告诉我） 这个真的是没有用，所以watch功能就很鸡肋。。 没有办法实时过滤文中提到了很多过滤条件，但是一旦开启过滤，就没有办法显示实时日志。。也就是说无法和watch共存。。。 换个姿势使用socatsocat的日志都在终端上，不着色不说还有上面的两个很影响使用的问题。。。于是乎，为了增加过滤功能，需要通过管道将输出接入另外的命令如：grep等。 socat命令需要手动输入watch才能显示出实时命令，这个让管道并不能直接使用。这里需要借助expect命令。 好了所有的点都通了，大致步骤如下： 在mac上安装expect1brew install expect 在mac的～/.bash_profile配置此处假设你的设备已经按照iOS逆向-设备ssh免密登录配置好了： 12345678function ios-socat() &#123; expect -c " spawn ssh i5s \"socat - UNIX-CONNECT:/var/run/lockdown/syslog.sock\" expect &#123; \"&gt; \" &#123;send \"watch\n\";&#125; &#125; interact"&#125; ios-socat 函数名，在命令行可以直接输入函数名调用该函数 i5s 在~/.ssh/config中配置的名字 如果没有配置ssh免密呢需要这样： 123456789function ios-socat() &#123; expect -c " spawn ssh -p22 root@ios's_ip \"socat - UNIX-CONNECT:/var/run/lockdown/syslog.sock\" expect &#123; \"*password: \" &#123;send \"mypassword\n\";&#125; \"&gt; \" &#123;send \"watch\n\";&#125; &#125; interact"&#125; -p22 端口号，22是默认不用写，但是其他的需要写。 ios&#39;s_ip iOS设备的ip。 mypassword iOS设备密码 这个我没测。。大致如此，我对expect的语法也不是很熟 最后别忘了让~/.bash_profile生效：1source ~/.bash_profile 然后只需要在命令行输入ios-socat就可以看到蹭蹭蹭的日志打印咯。。至于用什么管道啊都不是问题。 比如：只显示包含iosre关键字的日志 1ios-socat | grep iosre 晋级用法 我的iOS设备通过iproxy来进行端口映射。具体用法移步Google 通过ios-socat &gt; ~/Desktop/ios.log 然后下载LogTail，剩下的摸索一下咯 最后 我还不清楚究竟什么原因导致了收到来自此设备的无效响应错误，布吉岛系统修改了什么。我尝试重新安装iTunes、Xcode都无效（据说陌陌的开发为这个无法调试直接将系统降级是可以的😂）。。有老铁懂得指点下～～ 目前虽然上面都可以用，但是看个日志并不能满足我的野心，最后在移动硬盘里做了一个10.12的系统😂，用了Console.app…]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>逆向</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS逆向-创建Cydia源]]></title>
    <url>%2Fpost%2Freverse-ios-creat-cydia-sources%2F</url>
    <content type="text"><![CDATA[搭建自己的cydia源。 环境 Ubuntu 16.04 LTS 安装工具dpkg-dev123$ apt-get update$ apt-get install dpkg-dev$ dpkg-scanpackages --help nginx1apt-get install nginx 开工准备deb此处目录为/opt/cydia/debs，可以为别的，但是建议你也这样做:)。 生成依赖更新插件需要重新执行哟。。 123$ cd /opt/cydia$ dpkg-scanpackages -m ./debs /dev/null &gt; Packages$ bzip2 Packages 添加sources.list1$ echo "deb file:///opt/cydia ./debs/" &gt;&gt; /etc/apt/sources.list ps. 注意路径信息 更新一下1$ apt-get update 扔出去123$ cd /var/www/html$ ln -s /opt/cydia cydia$ /etc/init.d/nginx start 参考 http://www.saurik.com/id/7 https://bbs.feng.com/read-htm-tid-8052646.html]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>逆向</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[描述文件获取UDID]]></title>
    <url>%2Fpost%2Fios-tool-configurator-get-udid%2F</url>
    <content type="text"><![CDATA[UDID对，就是在iTunes等工具上看到的UDID.. 工具及文档嗯，Apple出的为数不多的mac app:Apple Configurator 2 这个工具是有中文文档的：Apple Configurator 2 官方文档 当然还有比较暴力的直接写xml: Apple的相关文档 通过Safari浏览器获取iOS设备UDID(设备唯一标识符) 为iOS的mobileconfig文件进行签名]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>tool</tag>
        <tag>UDID</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「转」一张思维导图，让正则表达式不再难懂]]></title>
    <url>%2Fpost%2Freprinted-regular-mind-map%2F</url>
    <content type="text"><![CDATA[字符 普通字符：字母、数字、汉字、下划线，匹配与之相同的一个字符 简单转义字符：\n（换行）,\t（制表）,\（\本身）和 \^…（\^等有特殊作用的符号如要匹配自己的话要用转义） 标准字符集合注意区分大小写，大写是相反的意思，匹配相反是不匹配 \d 任意一个数字，0~9 \w 任意一个字母、数字、汉字或下划线，A~Z、a~z、0~9、_和任意一个汉字 \s 任意空白符，包括空格、制表符、换行符 . 小数点可以匹配任意一个字符，换行除外（如果要匹配包括”\n”在内的所有字符，一般用[\s\S]） 自定义字符集合[ ]方括号匹配方式，能够匹配方括号中的任意一个字符,^表示取反 [ab5@] 匹配”a”或”b”或”5”或”@” [^abc] 匹配a、b、c之外的任意字符 [f-k] 匹配“f”到”k”之间的字符 [^A-F0-3] 匹配“A”-“F”,”0”-“3”之外的任意一个字符 量词(Quantifier)修饰前面的一个表达式，如果要修饰多个表达式，就用( )把表达式包起来 {n} 表达式重复n次​ {m,n} 表达式至少重复m次，最多重复n次 贪婪模式 （默认）匹配符合的最长的字符串 非贪婪模式 （在量词后面加 ? 例：{m,n}? ) 匹配符合的最短的字符串 {m,} 表达式至少重复m次 ？ 匹配表达式0或1次，相当于{0,1} + 表达式至少出现一次，相当于{1,} * 表达式不出现或出现任意次，相当于{0,} 字符边界零宽：匹配的不是字符而是位置，符合某种条件的位置 ^ 与字符串开始的地方匹配 $ 与字符串结束的地方匹配 \b 匹配一个单词的边界，当前位置前面的字符和后面的字符不全是\w 预搜索（零宽断言、环视）零宽：匹配的不是字符而是位置，符合某种条件的位置 (?=exp) 断言自身出现的位置的后面能匹配表达式exp (?!exp) 断言自身出现的位置的后面不能匹配表达式exp (?&lt;=exp) 断言自身出现的位置的前面能匹配表达式exp (?&lt;!exp) 断言自身出现的位置的前面不能匹配表达式exp 匹配模式对文本的处理方式 IGNORECASE 忽略大小写模式 匹配时忽略大小写 默认是区分大小写的 SINGLELINE 单行模式 整个文本看作一个字符串，只有一个开头一个结尾 使小数点”.”可以匹配包含换行符(\n)在内的任意字符 MULTILINE 多行模式 每行都是一个字符串 在多行模式下，如果需要仅匹配字符串开始和结束位置，可以使用\A和\Z 选择符和分组分支结构、捕获组合非捕获组 | 分支结构​ 左右表达式之间“或”关系，匹配左边或右边 ( ) 捕获组 （1）、在被修饰匹配次数的时候，括号中的表达式可以作为整体被修饰 （2）、取匹配结果的时候，括号中的表达式匹配到的内容可以被单独得到 （3）、每一对括号会分配一个编号，使用（）的捕获根据左括号的顺序从1开始自动编号。捕获编号为零的第一个捕获是整个正则表达式模式匹配的文本 反向引用：通过反向引用，可以对分组已捕获的字符串进行引用。 (?:Expression) 非捕获组 一些表达式中，不得不使用（），但又不需要保存（）中子表达式匹配的内容，这时可以用非捕获组来抵消（）带来的副作用。 原文：一张思维导图，让正则表达式不再难懂]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>正则表达式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用CollectionView简化代码，专注于业务和UI]]></title>
    <url>%2Fpost%2Fios-tool-collectionview-simplify-business%2F</url>
    <content type="text"><![CDATA[UITableView作为高级控件被开发者广泛使用，同样的，UICollectionView由于其NB的布局也被广泛使用。但是后者在使用的时候大多数都属于自定义的比较多，前者则相对普通，list基本上都用。 在业务需求中，常规布局，大多数都是采用UITableView进行的，但是有痛点： 当使在APP内用过一次瀑布流之后，设计师会突然的让你在正常的list中底部追加瀑布流。。虽然是在底部追加，但是要从UITableView迁移到UICollectionView UITableViewDelegate、UITableViewDataSource 恐怕每处使用都要写繁琐的相同的代码吧～ 很多人也会对其进行高度缓存啊神马的优化策略 不知不觉这些代码堆在一起已经将UIViewController堆的相当的高 然后呢，我们现在使用一个CollectionView将这些操作包装一下，达到这样一个流程: 自定义Cell、CellModel 12345678910111213141516class LabelCell: UICollectionViewCell &#123; let info = UILabel() ... override func sizeThatFits(_ size: CGSize) -&gt; CGSize &#123; ... return CGSize(width: size.width, height: info.frame.maxY + info.frame.minY) &#125;&#125;extension LabelCell &#123; class Model: ListItemDefaultProtocol &#123; var info: String? func fillModel(view: LabelCell) &#123; view.info.text = info &#125; &#125;&#125; 请求、处理数据格式化为LabelCell.Model这样的类 处理好的数据交给CollectionView 1list.sections = model.format(...) 休息一会，完工了～ 然后，来看看Collection里面都做了什么操作 CollectionView为了达到上面效果中的第三步，我们需要自定义一个CollectionView来处理刷新数据、设置代理、设置数据源、注册cell、等操作。 需要说明的是，此处使用CHTCollectionViewWaterfallLayout来处理瀑布流。 创建一个CollectionViewSection的类/结构体来保存section信息。比如说：sectionInset、minimumColumnSpacing、minimumInteritemSpacing、columnCount、等 在CollectionView中设置一个var sections = [KTJCollectionViewSection]()用于保存sections 实现UICollectionViewDataSource、 UICollectionViewDelegate。此处省略约1千字… ListItemDefaultProtocol：绑定Cell和Model上面省略约1千字中有一个并没有说：CollectionViewSection的header、items、footer如何实现。😂 好了，此处这三个均采用协议ListItemDefaultProtocol来实现。（PS：大家都喜欢用父类，但父类只有一个，为了兼容和冲突，这里协议是最好不过的～，特别是swift中的协议） 协议需要给出这么几个信息： reuseIdentifier 用来复用的重用标识符 cellClass 用来注册用的类名 func fillModel(item: AnyObject) 用来给cell填充model的方法 那么这个协议就出来了：12345protocol KTJListItemProtocol &#123; var identifa: String &#123; get &#125; var registClass: AnyClass &#123; get &#125; func fillModel(item: AnyObject)&#125; 在swift协议支持默认实现，于是乎，就可以再写一个:12345678910111213protocol ListItemDefaultProtocol: KTJListItemProtocol &#123; associatedtype ItemType: UIView func fillModel(view: ItemType)&#125;extension ListItemDefaultProtocol &#123; var identifa: String &#123; return NSStringFromClass(ItemType.self)&#125; var registClass: AnyClass &#123; return ItemType.self &#125; func fillModel(item: AnyObject) &#123; if let reusableView = item as? ItemType &#123; fillModel(view: reusableView) &#125; &#125;&#125; 然后，就可以愉快的玩耍了～～ 最后Cell中的的代码效果就是这个样子。再加上数据填充是不是很简单了呢～～ 以后如何开发真的如同前面的例子一样，只需要这么几步绕不过去的： 处理接口吐出来的数据。 创建新的UI样式，并做好接口数据中间件。 点击事件在处理数据的时候预先埋好，所有的数据、逻辑和UI数据一起被传递，不需要多次类型判断。 统一使用CollectionView还有一个好处：不管前面谁写的一个UI，都能拉过来用。不用做中间层去从TableViewCell转CollectionViewCell。 开发只需要关心业务，业务。安安心心做一个写业务的程序员吧～ 关于Cell的跳转处理乍一看，完美了。不过还有一个巨烦的跳转处理。。。不过，莫怕 跳转，有这么几种： 支持路由的URL跳转，这个是最简单的，也是最爽的 只能复杂的进行创建类、赋值、push啊神马的 由于我们将数据全部处理好后扔给了cellmodel，而跳转、打点所需要的参数均在此处为最全的，我们可以将回调作为数据一起传递。。 嗯, 事件需要传递的对象大约这个样子：12345678910struct Jmp &#123; /// 支持URL跳转的URL let url: String? /// 打点事件名 let event: String? /// 打点参数 let attr: [AnyHashable: Any]? /// 不支持URL的直接回调 let eventCallback: (() -&gt; Void)?&#125; 然后cell对应的另一个类是这样的：123456789101112class KTJJmp: NSObject &#123; var info: Jmp? let action = #selector(topVCJmp) @objc func topVCJmp() &#123; ... // 打点 KTJURLJump.jumpToViewOnTopVC(jmp: info) info?.eventCallback?() &#125; func tap() -&gt; UITapGestureRecognizer &#123; return UITapGestureRecognizer(target: self, action: #selector(topVCJmp)) &#125;&#125; 两个类共同作用就是：12345678910111213class JmpCell: UICollectionViewCell &#123; let jmp = JmpCellModel() func setup() &#123; ... jmpBtn.addTarget(jmp, action: jmp.action, for: .touchUpInside) &#125;&#125;class JmpCellModel: ListItemDefaultProtocol &#123; var jmp: Jmp? func fillModel(view: JmpCell) &#123; view.jmp.info = jmp &#125;&#125; 至于这个JmpCellModel.jmp怎么生成，这里就不说了。 关于算高那点事算高位置的选择我也曾纠结过frame的代码应该写在哪里。。有写在初始化的，有单独写一个方法的，还有写在func sizeThatFits(:) -&gt; CGSize 由于当年对UITableView-FDTemplateLayoutCell中毒较深，所以沿用了最后一种方案。 算高使用的view的选择在算高的时候，首先需要明确的是：高度是数据和当前最大宽度共同决定的，所以在算高的时候需要拿着数据、view然后才能去算高（PS：至于那些拿着数据硬算出一个高度的代码，此处不发表看法😂，早晚会后悔的） 然后就是UITableView、UICollectionView的算高是通过一个单独的代理去获取的，并不提供view去计算。。这就是矛盾的地方。 虽然UITableView、UICollectionView在算高的地方不提供View,但是有一个dequeueReusableCell....的方法可以获取到缓存池中的Cell呀 如果你这样做了，那么你将会付出惨重的代码。这个方案我在博客园2015.03.17的“iOS 优化性能之TableView”中已经说了： dequeueReusableCellWithIdentifier:此函数的调用要注意以下几点： i.此函数的返回值是做为tableView:cellForRowAtIndexPath:的返回值的。这样保证拿出来的完整还给TableView。 ii.如果此函数的返回值不是为了给tableView:cellForRowAtIndexPath:做返回值，那么你要注意这是在一个拿取别人稀缺资源的操作，需要注意珍惜这个返回值，能不浪费就不要浪费。 iii.对于AL自动适应的TableView取Cell时候要注意保存。个人建议封装TableView，然后用来计算高度的Cell保存在TableView中。对于多种类型的Cell，则可以使用复用标识符作为Key的字典来存储。这样能够有效节约dequeueReusableCellWithIdentifier:调用次数。 UICollectionView也是如此。所以使用dequeueReusableCell....方法是很不靠谱的。 在UITableView-FDTemplateLayoutCell中使用了字典保存缓存算高的View，也是比较赞的。 但是现在有了CollectionView，我们可以不用OC的objc_setAssociatedObject(,,,)去处理而直接使用了NSCache去处理就行了～ 如果看了CollectionView就会发现，ListItemProtocol还有一个get方法var newItem: AnyObject { get }这个是用来算高的。 在CollectionView.swift关于高度的代理设置中可以看到相关获取和设置。 算高的时候变局的控制高度的计算现在已经可以正常计算，但是对于columnCount &gt; 1的时候，牵扯到间隙的计算需要注意一次啊。毕竟CHTCollectionViewWaterfallLayout功能更强大。 相关代码在CollectionView.swift的func collectionView(:,layout:,sizeForItemAt:) -&gt; CGSize函数中。 关于代理那点事丫的，需求总是比想的多，但是办法也比问题多。 对于CollectionView来说，代理都设置成了self，这样会导致有时候需要UIScrollViewDelegate干些事情的时候总是不那么自由。。。实乃新痛点，不过有办法。 下面是几种方案： KVO直接KVO到self.contentOffset，这样一了百了。写什么代理，要什么自行车！（PS：swift提供闭包的代理，也是很好用的） 如果不会，请自行Google。ObjC-中国：KVC 和 KVO，我只能帮你到这里 Rx系很抱歉，你不能用self.rx.contentOffset。原因是CHTCollectionViewWaterfallLayout中有这么一行断言： 1NSAssert([self.delegate conformsToProtocol:@protocol(CHTCollectionViewDelegateWaterfallLayout)], @"UICollectionView's delegate should conform to CHTCollectionViewDelegateWaterfallLayout protocol"); 但是，你可以使用Rx里面的KVO呀～也是贼方便 RAC系抱歉，我不会。原因在此准备食用RAC(ReactiveCocoa)的顾虑 代理传递当然也可以使用代理进行传递出去。大致这个样子： 123456789protocol CollectionViewDelegate: NSObjectProtocol &#123; func collectionView(_ collectionView: UICollectionView, didSelectItemAt indexPath: IndexPath)&#125;class CollectionView &#123; weak var allDelegate: CollectionViewDelegate?&#125;func collectionView(_ collectionView: UICollectionView, didSelectItemAt indexPath: IndexPath) &#123; self.allDelegate?.collectionView(self, didSelectItemAt: indexPath)&#125; 这方案没啥聊的。。 OC咋办？这个OC也能用，只不过需要一些手段，比如说：继承、扩展、等 ListItemProtocol就是为了给OC使用留的，还有就是CollectionViewSection使用了类，而不是结构体。 不过具体没有例子，不想写OC代码，太麻烦了。。主要是这种思路:) 填充Cell的数据为什么会在CellModel中？对于Cell来说，Cell是干净的，没有任何继承、协议来限制Cell如何处理。那么Cell就可以接受来自任何模块的各种风格的Cell，这是我想要的减少侵入。 cellModel中定义了Cell所对应的填充数据格式，在第一次写的时候难免会按照业务逻辑起一些业务逻辑的名字，在复用的时候又不能改名字，会对维护和开发加了一定量的复杂度，这不是我想要的。。 于是乎每个CellModel根据自己的需要绑定需要绑定的Cell，去填充Cell所对应的数据就好。只需要侵入cellModel即可。代价最小，受益最大。 PS.对于同一个List，需要注意cell的复用和多个cellModel同时绑定一个cell时，属性的设置。 DemoDemo部分没有写跳转相关内容，但是别的都有了😂 别的好像没了吧～，想起来了再补充咯 偶然看到一个类似的文章 Table View 太複雜？利用 MVVM 和 Protocol 就可以為它重構瘦身！ 昨天(2018.7.24)翻文章的时候看到这个文章，然后将文章和代码捋了一下，发现这才是MVVM吧。觉得不错，贴出来～]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>tool</tag>
        <tag>UICollectionView</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mac10.13 pods 命令错误]]></title>
    <url>%2Fpost%2Fmacos-high-sierra-cocoapods%2F</url>
    <content type="text"><![CDATA[每逢升级大版本总要过搞点事情。 12$ pod env-bash: /usr/local/bin/pod: /System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/bin/ruby: bad interpreter: No such file or directory 不论是pod env、pod update 等等均报上面的错误。 如果Google发现： ruby - CocoaPods not working in macOS High Sierra - Stack Overflow CocoaPods CLI fails in High Sierra due to change of Ruby version #6778 High Sierra: bad interpreter #6898 事情的缘由就是这样。 #6898中道出了简单直接的解决方案： for all others: gem install -n /usr/local/bin cocoapods fixes it 综合起来解决这个问题是这样的： 1234$ gem update --system$ gem uninstall cocoapods$ echo 'gem: --bindir /usr/local/bin' &gt;&gt; ~/.gemrc$ sudo gem install cocoapods 愉快的使用cocoapods吧～]]></content>
      <categories>
        <category>macOS</category>
      </categories>
      <tags>
        <tag>cocoapods</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mac10.13依旧让Xcode支持打开终端]]></title>
    <url>%2Fpost%2Fmac-high-sierra-open-with-external%2F</url>
    <content type="text"><![CDATA[在macOS10.13以前是支持Xcode中直接打开终端的，步骤呢就是下面这样子： 右击工程 Open With External Editor 终端弹出来了。。 如果没有生效，就是你的电脑上装了什么可以打开xx.xcodeproj的应用程序，也就是在Finder下右击可以看到如下样式： 呐～ Xcode为默认，备忘录为默认下面的第一个～～ 对，如果这样的话，那么按照上面3步，得到的结果是：这个文件被莫名其妙的保存在了备忘录～～ 这不是我们要的🤷‍♂️，下面我们通过修改备忘录.app的配置文件来达到我们的效果。 成因macSO10.13加强了备忘录，嗯的确变强了，可是并没有Xcode和终端常用。 备忘录增加了导入的功能，支持了一些文件的打开(只是导入而已。。)，但是并不适合我。于是改一下吧～～ 操作 在应用程序中找到备忘录 显示包内容 找到 我们要修改的plist文件： Contents/Info.plist 做一下备份：复制一下。。 确保 已完成 直接修改Info.plist会提示没有权限，使用sudo vim Info.plist修改 不管你用什么方法，删除下面的这些代码 1234567891011&lt;dict&gt; &lt;key&gt;CFBundleTypeName&lt;/key&gt; &lt;string&gt;General files and folders&lt;/string&gt; &lt;key&gt;CFBundleTypeRole&lt;/key&gt; &lt;string&gt;Viewer&lt;/string&gt; &lt;key&gt;LSItemContentTypes&lt;/key&gt; &lt;array&gt; &lt;string&gt;public.data&lt;/string&gt; &lt;string&gt;public.directory&lt;/string&gt; &lt;/array&gt;&lt;/dict&gt; :wq 重启一下 （目的：重建索引） 至于我做了什么讲道理，用Xcode的都知道吧？这个是注册的app支持的文件类型。 删除之后就可以了，就这么多😂 注意一下操作中的步骤9可以有脚本，但是还是老实重启一下吧，有的脚本会使部分图标失效，巨烦。。还是重启一下比较靠谱。毕竟不着急]]></content>
      <categories>
        <category>macOS</category>
      </categories>
      <tags>
        <tag>Xcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Xcode9编译失败]]></title>
    <url>%2Fpost%2Fdebug-xcode9-build-ipa%2F</url>
    <content type="text"><![CDATA[错误输出 error: exportArchive: “Fangduoduo_ent.app” requires a provisioning profile with the Push Notifications and Associated Domains features. Error Domain=IDEProvisioningErrorDomain Code=9 “”Fangduoduo_ent.app” requires a provisioning profile with the Push Notifications and Associated Domains features.” UserInfo={NSLocalizedDescription=”Fangduoduo_ent.app” requires a provisioning profile with the Push Notifications and Associated Domains features., NSLocalizedRecoverySuggestion=Add a profile to the “provisioningProfiles” dictionary in your Export Options property list.} 错误原因在升级Xcode9正式版之后，Jenkins也就升级了，于是乎用原来的套路打包之后就是上面的错误 5555… 如果使用xcodebuild进行处理，那么这个会发生在选择证书的步骤，错误大致就是这样。 $xcodebuild --help 可以看到一些信息，而且在最后还特意提出了一个“-exportOptionsPlist”参数。具体内容见xcodebuild --help 解决问题才是关键 使用xcode9进行一次archive 选择相关证书啊神马的，保持thinning不变就好 导出 导出目录有一个ExportOptionsPlist.plist，这个就是打包时候需要的plist 脚本构建ipa即为目标变量，具体的参看打包脚本 123456789101112131415161718192021222324252627282930313233rm -rf ./build/*cat &lt;&lt; EOF &gt; ./build/exportOptionsPlist.plist&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd"&gt;&lt;plist version="1.0"&gt;&lt;dict&gt; &lt;key&gt;compileBitcode&lt;/key&gt; &lt;true/&gt; &lt;key&gt;method&lt;/key&gt; &lt;string&gt;enterprise&lt;/string&gt; &lt;key&gt;provisioningProfiles&lt;/key&gt; &lt;dict&gt; &lt;key&gt;ershoufanglzg.fangdd.com&lt;/key&gt; &lt;string&gt;ershoufanglzg_dis&lt;/string&gt; &lt;/dict&gt; &lt;key&gt;signingCertificate&lt;/key&gt; &lt;string&gt;iPhone Distribution&lt;/string&gt; &lt;key&gt;signingStyle&lt;/key&gt; &lt;string&gt;manual&lt;/string&gt; &lt;key&gt;stripSwiftSymbols&lt;/key&gt; &lt;true/&gt; &lt;key&gt;teamID&lt;/key&gt; &lt;string&gt;J3B467DURT&lt;/string&gt; &lt;key&gt;thinning&lt;/key&gt; &lt;string&gt;&amp;lt;none&amp;gt;&lt;/string&gt;&lt;/dict&gt;&lt;/plist&gt;EOFxcodebuild -archivePath "./build/xxx.xcarchive" -workspace Fangduoduo.xcworkspace -sdk iphoneos -scheme "Fangduoduo_ent" -configuration "Release Inhouse" archivexcodebuild -exportArchive -archivePath "./build/xxx.xcarchive" -exportPath "./build/" -exportOptionsPlist ./build/exportOptionsPlist.plistipa=$(pwd)/$(ls ./build/*.ipa) xcodebuild –help Available keys for -exportOptionsPlist: compileBitcode : Bool For non-App Store exports, should Xcode re-compile the app from bitcode? Defaults to YES. embedOnDemandResourcesAssetPacksInBundle : Bool For non-App Store exports, if the app uses On Demand Resources and this is YES, asset packs are embedded in the app bundle so that the app can be tested without a server to host asset packs. Defaults to YES unless onDemandResourcesAssetPacksBaseURL is specified. iCloudContainerEnvironment : String If the app is using CloudKit, this configures the “com.apple.developer.icloud-container-environment” entitlement. Available options vary depending on the type of provisioning profile used, but may include: Development and Production. installerSigningCertificate : String For manual signing only. Provide a certificate name, SHA-1 hash, or automatic selector to use for signing. Automatic selectors allow Xcode to pick the newest installed certificate of a particular type. The available automatic selectors are “Mac Installer Distribution” and “Developer ID Installer”. Defaults to an automatic certificate selector matching the current distribution method. manifest : Dictionary For non-App Store exports, users can download your app over the web by opening your distribution manifest file in a web browser. To generate a distribution manifest, the value of this key should be a dictionary with three sub-keys: appURL, displayImageURL, fullSizeImageURL. The additional sub-key assetPackManifestURL is required when using on-demand resources. method : String Describes how Xcode should export the archive. Available options: app-store, package, ad-hoc, enterprise, development, developer-id, and mac-application. The list of options varies based on the type of archive. Defaults to development. onDemandResourcesAssetPacksBaseURL : String For non-App Store exports, if the app uses On Demand Resources and embedOnDemandResourcesAssetPacksInBundle isn’t YES, this should be a base URL specifying where asset packs are going to be hosted. This configures the app to download asset packs from the specified URL. provisioningProfiles : Dictionary For manual signing only. Specify the provisioning profile to use for each executable in your app. Keys in this dictionary are the bundle identifiers of executables; values are the provisioning profile name or UUID to use. signingCertificate : String For manual signing only. Provide a certificate name, SHA-1 hash, or automatic selector to use for signing. Automatic selectors allow Xcode to pick the newest installed certificate of a particular type. The available automatic selectors are “Mac App Distribution”, “iOS Developer”, “iOS Distribution”, “Developer ID Application”, and “Mac Developer”. Defaults to an automatic certificate selector matching the current distribution method. signingStyle : String The signing style to use when re-signing the app for distribution. Options are manual or automatic. Apps that were automatically signed when archived can be signed manually or automatically during distribution, and default to automatic. Apps that were manually signed when archived must be manually signed during distribtion, so the value of signingStyle is ignored. stripSwiftSymbols : Bool Should symbols be stripped from Swift libraries in your IPA? Defaults to YES. teamID : String The Developer Portal team to use for this export. Defaults to the team used to build the archive. thinning : String For non-App Store exports, should Xcode thin the package for one or more device variants? Available options: (Xcode produces a non-thinned universal app), (Xcode produces a universal app and all available thinned variants), or a model identifier for a specific device (e.g. “iPhone7,1”). Defaults to . uploadBitcode : Bool For App Store exports, should the package include bitcode? Defaults to YES. uploadSymbols : Bool For App Store exports, should the package include symbols? Defaults to YES.]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>构建</tag>
        <tag>DEBUG</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS自动化-Jenkins编译工程]]></title>
    <url>%2Fpost%2Fios-automation-jenkins-build%2F</url>
    <content type="text"><![CDATA[iOS自动化-Jenkins环境搭建 iOS自动化-Jenkins编译工程 介绍Jenkins环境已搭建好，现在我们来开始愉快的为iOS打包吧～ 从这个文章中你将要实现以下功能： 在Jenkins创建工程 build出ipa 将ipa上传至fir 钉钉机器人群通知 将dsym上传至bugly 脚本环境安装这里大多数操作都是用脚本来进行的，不为别的，就为自由和以后～ fastlane此乃自动化神器。文档在此。开源哟～ 此处主要用来编译、打包。 安装方法： 1$ brew cask install fastlane 此神器除了上述功能，还提供很多很多很多很多功能，包括自定义神马的都支持。需要的可以去文档里面翻翻。 在Xcode9 我使用的版本2.14.1打包出问题了。。具体在这里详见Xcode9编译失败。于是呼采用了xcodebuild进行打包 fir.im-clifir.im提供的应用内测托管工具。开源官网。 安装方法： 1$ gem install fir-cli 此工具也提供打包ipa、apk、上传符号表至BugHD、等功能。但是我们在这里选择了fastlane gym 上传加速： 1$ sh -c "$(curl -sSL https://gist.githubusercontent.com/trawor/5dda140dee86836b8e60/raw/turbo-qiniu.sh)" 上传加速代码已经开源至此。 BugHD: 已停止线上免费服务，开始卖私有部署了。 另外，fir 也有Jenkins插件，但是这里选择脚本方式。 插件安装所有的插件可以在系统管理 -&gt; 插件管理中进行安装、卸载、降级、更新、等操作。 确保以下插件已经被安装： 源代码管理：Git Plugin 编译脚本环境变量：Tool Environment Plugin 嗯，开始创建工程，然后配置打包吧！ 工程相关配置左侧的新建(New Item)我就不说了吧～，点击输入项目名字，然后选择第一个构建一个自由风格的软件项目就行啦～～ 此处项目名字暂且成为test。这里只说一些比较重要的，没有活不成的那种配置。别的自己研究一下或者点击右侧❓就能看到介绍。 源码管理此处点击Git，展开之后输入Repository URL即可。 Repository URL输入完毕之后点击别处，Jenkins的Git插件会自动校验该URL是否能够clone下来代码。出现红色就自己根据错误修改一下咯。。 另外此处支持ssh 的方式，大致样式为：ssh://sunjigang@github.com:29418/projects/aaa。 Branches to build 写上你的构建分支～，根据自己需求来，master一般为仓库的默认分支。 构建触发器此处表示该项目的构建触发条件。（可选） 我们这里说一下Poll SCM： 定时检查源码变更。条件是 一定要配置Git这样的源码管理。 例子： H/15 * * * *：每15分钟构建一次 0 2 * * *： 每天2:00构建一次 构建此处为构建的核心😂。当然，我们为了自由，此处全部使用shell脚本。 12345678910111213141516171819202122232425262728293031323334# 工程名workspace='xxx.xcworkspace'# 构建schemescheme='xxx'# 打包类型：app-store, ad-hoc, package, enterprise, development, and developer-id.export_method='enterprise'# fir的token，在fir-&gt;用户-&gt;token 获取fir_token='c5077e0368888b9750ae848b9fe00***'# fir上传短链接，效果为 https://fir.im/xxxfir_url='xxx'# 钉钉机器人tokendingtalk_token='6d09e43ddc62e540be914ff2e901e28b921d55c5ad457f6f3571f9f881287***'# 钉钉机器人发送的内容dingtalk_content="iOSXXX已经上传至 http://fir.im/$&#123;fir_url&#125; ,吧啦吧啦吧啦～"# 构建fastlane gym --workspace $workspace \ --scheme $scheme \ --export_method $export_method \ clean# firipa=$(pwd)/$(ls *.ipa)git log -10 &gt; git.logfir p $ipa -T $fir_token -s $fir_url -c git.log# 钉钉通知curl "https://oapi.dingtalk.com/robot/send?access_token=$&#123;dingtalk_token&#125;" -H 'Content-Type: application/json' -d ' &#123;"msgtype": "text", "text": &#123; "content":$&#123;dingtalk_content&#125; &#125; &#125;' 至此 已经完成了打包、上传fir、钉钉机器人通知。 上述脚本只是配置的例子，可以根据自己需求，自己编写和配置。特别是 .xcworkspace的位置，要找清楚呀 scheme无法找到是因为你在提交代码的时候没有将其设置为shared fastlane gym 支持很多参数，是对xcodebuild的封装，源码及文档在此 上传dSYM至Bugly这个还是有点点复杂的，因为bugly并未提供完整的cli工具链，需要手动跑jar包。不过都是可以完成的。 为了隔离开打包和上传，这里在Jenkins上新建一个项目用来上传dSYM 其中需要衔接的地方就是上面的输出要作为这个的输出。所以需要前后对应位置。 1234567891011121314151617181920212223242526272829303132333435# 路径主要用来提取Info.plist以及dsym文件path='/Users/FDD/.jenkins/workspace/fdd-ios-app/fdd-app-ios/Fangduoduo'# scheme namescheme='Fangduoduo_ent'# ipa bundleIdpackage='xx.xx.com'# bugly idbugly_id='9xxx'# bugly keybugly_key='wHzxcxxx'rm -rf *dSYM*cp $&#123;path&#125;/Fangduoduo/Fangduoduo_ent-Info.plist ./Info.plistcp -rf $&#123;path&#125;/build/*.xcarchive/dSYMs .# ------------ post dsym ------------ #app_infoplist_path='Info.plist'version=$(/usr/libexec/PlistBuddy -c "print CFBundleVersion" $&#123;app_infoplist_path&#125;)java -jar ./bugly/buglySymboliOS.jar \ -i dSYMs/$&#123;scheme&#125;.app.dSYM \ -dsym \ -u \ -id $&#123;bugly_id&#125; \ -key $&#123;bugly_key&#125; \ -package $&#123;package&#125; \ -version $&#123;version&#125; # @bugly jar执行的时候返回状态码有问题。已反馈，但是不见修改。。 # ------------ UUID ------------ #unzip -o ./dSYMs/$&#123;scheme&#125;.app.dSYM.zipxcrun dwarfdump --uuid ./$&#123;scheme&#125; &gt;&gt; ./uuids-$&#123;version&#125;.txt 值得说的是，如果上面的报错，那么检查一下是不是路径什么的写错了。。。 如果还有问题，可以在关于中找到我。]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>构建</tag>
        <tag>Jenkins</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何实现AppStore查看更多的方法]]></title>
    <url>%2Fpost%2Fappstore-truncate%2F</url>
    <content type="text"><![CDATA[UITextView-More使用UITextKit 实现“更多”的折叠效果 主要代码获取最后一行Rect12345678var lastRect = CGRect.zerolayoutManager.enumerateEnclosingRects(forGlyphRange: NSRange(location: 0, length: textStorage.string.characters.count), withinSelectedGlyphRange: NSRange(location: NSNotFound, length: 0), in: textContainer, using: &#123; [weak self] (rect, isStop) inguard let _self = self else &#123; return &#125;var newRect = rectnewRect.origin.y += _self.textContainerInset.toplastRect = newRect&#125;)print(lastRect) 增加 exclusionPaths1textContainer.exclusionPaths = [UIBezierPath.init(rect: rect)] 备注 UITextView默认携带左右边距，通过UITextView.textContainer.lineFragmentPadding获取 UITextView默认携带上下左右边距(UITextView.textContainerInset)，其中左右和lineFragmentPadding相加 此处并没有对TruncateTextView进行过多的设置，主要是因为继承在UITextView下，GIF中的这部分设置放在了ViewController.swift中 此处使用的是frame，可以在UIView.sizeToFit()之后获取到UIView的Size。约束也大抵如此 感谢乐逍遥提供的例子，才找到了open func truncatedGlyphRange(inLineFragmentForGlyphAt glyphIndex: Int) -&gt; NSRange方法😂]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>效果</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS自动化-Jenkins环境搭建]]></title>
    <url>%2Fpost%2Fios-automation-jenkins-configuration%2F</url>
    <content type="text"><![CDATA[iOS自动化-Jenkins环境搭建 iOS自动化-Jenkins编译工程 介绍 JenkinsBuild great things at any scaleThe leading open source automation server, Jenkins provides hundreds of plugins to support building, deploying and automating any project. 如官网所说Build great things at any scale 从这篇文章中你将会实现： 在Mac上多种方案安装并启动jenkins 在局域网中正常访问jenkins 安装当然你首先需要一个macOS的系统，为后来的构建做基础。 Jenkins中可以使用pkg、war的方式运行，当然还有在Installing Jenkins中提供一些安装方式： macOSTo install from the website, using a package: Download the latest package Open the package and follow the instructions Jenkins can also be installed using brew: Install the latest release version1brew install jenkins Install the LTS version1brew install jenkins-lts 这里使用brew，因为很方便：12345678# 安装$ brew update &amp;&amp; brew install jenkins# 更新$ brew update &amp; brew upgrade jenkins# 后台运行 还支持`stop`、`restart`等 (这种方式还是有差别的，下面会说明)$ brew services start jenkins 运行建议先来看一波--help 1$ jenkins --help 下面是常用的几种方案，此处如果第一次安装，建议采用方案一或者方案二，暂时不建议新手使用后台运行的方案～～（会在打包的时候出现证书的问题） 方案一直接运行jenkins命令，可以看到日志输出，但是不能退出命令。 1$ jenkins 经过漫长的初始化，会将 ~/.jenkins目录作为JENKINS_HOME localhost:8080作为默认URL 终端输出Started initialization一行之后就可以正常打开了。 在浏览器打开http://10.12.12.10:8080就可以正常加载啦～ 退出运行：control + C 组合键。 方案二直接open，看不到日志输出，所对应的运行环境和方案一相同。 1$ open /usr/local/opt/jenkins/libexec/jenkins.war 命令结束，稍等片刻(初始化相关目录、环境)，在浏览器打开http://10.12.12.10:8080就可以正常加载啦～ 方案三使用brew直接挂在后台作为服务运行起来 1$ sudo brew services start jenkins brew还提供其他的参数，比如说restart、list、stop 等等。 此方案和上面的运行环境是不一样的，会有些权限的差别。 其他方案使用launchctl、nohup 等其他方案进行的后台运行，同方案三差不多。 需要说的是launchctl是macOS下系统提供的后台运行方案，brew等，均来自于此。 在launchctl后台中需要一个plist，但是brew已经做好了，放置在~/Library/LaunchAgents/homebrew.mxcl.jenkins.plist。需要说的是launchctl是macOS下系统提供的后台运行方案，brew等，均来自于此，具体的配置参数都和launchctl一样的，搜索一下很多。brew为我们已经准备好了一个，直接使用方案三就行。 具体操作可以Google一下，很多的～ 安装完成后的配置在Jenkins初始化完毕为了验证管理员身份，需要将Jenkins机器上的一个字符串输入到http://10.12.12.10:8080中进行验证，具体文件目录在输入的界面就能看到，不要大惊小怪。 之后开始选择安装插件。这里可以选择推荐的～～，也可以自己勾选。为了方便，这里直接选择推荐的方案进行安装。 经过漫长的等待，终于将插件安装完毕，并启动了起来～～ Jenkins权限，嗯，这个很重要，可以去系统管理 -&gt; Configure Global Security 中进行设置。 接下来开始去配置工程吧！传送门：iOS自动化-Jenkins编译工程 可能会碰到的错误Error: Permission denied - ***12$ brew services start jenkinsError: Permission denied - ~/Library/LaunchAgents/homebrew.mxcl.jenkins.plist 这种很明显Permission denied，在命令行前添加sudo，然后输入密码即可。如下： 1$ sudo brew services start jenkins 方案二后的地址哪里来的？这里推荐的安装方案是brew install jenkins 通过下面的方式找到brew安装的位置 1234567891011$ brew services listName Status User Plistbeanstalkd stoppedinfluxdb stoppedjenkins started keith ~/Library/LaunchAgents/homebrew.mxcl.jenkins.plistnginx stoppedsonarqube stoppedFDDdeiMac:~ FDD$ cat ~/Library/LaunchAgents/homebrew.mxcl.jenkins.plist...&lt;string&gt;/usr/local/opt/jenkins/libexec/jenkins.war&lt;/string&gt;... 给Jenkins绑定一个IP讲道理这个不应该在这里聊的😂，不过还是说一下吧。。 一般局域网中都是直接自动获取IP信息的也就是DHCP，但是Jenkins总改IP也不好。。于是绑定一下吧。 在mac 中 系统偏好设置 -&gt; 网络 记录下来当前获取到的IP。 在高级中将使用DHCP修改为使用DHCP(手动设定地址)，然后将上面的地址填进去就好啦～ 当然你也可以指定其他的地址，只要别人没有占用😂，你开心就好～]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>构建</tag>
        <tag>Jenkins</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS逆向-monkeydev工具]]></title>
    <url>%2Fpost%2Freverse-ios-monkeydev%2F</url>
    <content type="text"><![CDATA[MonkeyDev wiki这是一个为越狱和非越狱开发人员准备的工具，主要包括四个模块: Logos Tweak 使用theos提供的logify.pl工具将.xm文件转成.mm文件进行编译，集成了CydiaSubstrate，可以使用MSHookMessageEx和MSHookFunction来Hook OC函数和指定地址。 CaptainHook Tweak 使用CaptainHook提供的头文件进行OC 函数的Hook，以及属性的获取。 Command-line Tool 可以直接创建运行于越狱设备的命令行工具 MonkeyApp 这是自动给第三方应用集成Reveal、Cycript和注入dylib的模块，支持调试dylib和第三方应用，支持Pod给第三放应用集成SDK，只需要准备一个砸壳后的ipa或者app文件即可。 MonkeyDev wiki]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>逆向</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS逆向-class-dump工具]]></title>
    <url>%2Fpost%2Freverse-ios-class-dump%2F</url>
    <content type="text"><![CDATA[安装class-dump去stevenygard.com下载最新的包。 将包中的class-dump可执行文件复制到/opt/class-dump。(我的逆向相关工具均在这下面😂） 在~/.base_profile中添加export PATH=/opt/class-dump:$PATH 运行source ~/.base_profile 最后确认一下安装OK ： 12$ class-dump --vclass-dump 3.5 (64 bit) compiled Nov 16 2013 12:22:33 功能使用一个记录一个吧～ 用来导出ipa/.decrypted头文件此处只能导出未加密的ipa，或者砸过壳的。具体砸壳过程传送门 12345$ ls WeChat.decryptedWeChat.decrypted$ class-dump -H WeChat.decrypted -o ./Headers/$ ls HeadersHeaders 即得头文件目录：Headers]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>逆向</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS逆向-砸壳(cycript/clutch)]]></title>
    <url>%2Fpost%2Freverse-ios-dump-decrypted%2F</url>
    <content type="text"><![CDATA[准备工作 越狱设备 目前有两种砸壳工具，并不肩并肩，一个不行就用另一个呗，俩都不行就Google吧～～ 下面分别对cycript、clutch进行砸壳: 使用cycript进行砸壳准备 Cydia中搜索cycript并安装  步骤制作并上传dumpdecrypted.dylib （已经OK的可忽略制作目前我制作目录暂时在~/Desktop。 1234$ git clone https://github.com/stefanesser/dumpdecrypted.git ~/Desktop$ cd ～／Desktop/dumpdecrypted$ make$ ls dumpdecrypted.dylib 没什么错误的话，即得dumpdecrypted.dylib。 上传将dumpdecrypted.dylib放在越狱设备的/var/root/下 12345$ ls dumpdecrypted.dylib$ scp dumpdecrypted.dylib root@10.12.14.16:/var/root/root@10.12.14.16's password:dumpdecrypted.dylib 100% 193KB 3.0MB/s 00:00$ 登录进越狱设备可以使用ssh root@IP进行登录。 当然也可以使用ssh ipad，这样免密登录登录。 配置传送门 找到可执行文件路径这里以WeChat为例子啦～ 记得先打开呀～～～ ps -e： 显示所有程序grep: 这里是过滤一下。。具体用法Google。所有的程序有点多，我知道名字，所以直接过滤一下。也可忽略 1234567891011$ ps -e | grep WeChat705 ?? 0:02.20 /var/mobile/Containers/Bundle/Application/3AE519BF-2FD2-43FC-A14B-2893190B8E1E/WeChat.app/WeChat707 ttys000 0:00.01 grep WeChat$ cycript -p 705$ cycript -p 705cy# [[NSFileManager defaultManager] URLsForDirectory:NSDocumentDirectory inDomains:NSUserDomainMask][0]#"file:///var/mobile/Containers/Data/Application/54EF9A70-8E3A-4B6D-B7F4-554AB256C48B/Documents/"cy# exit(0)MS:Error: _krncall(mach_vm_read_overwrite(task, data, sizeof(*baton), reinterpret_cast&lt;mach_vm_address_t&gt;(baton), &amp;error)) =4*** _assert(status == 0):../Inject.cpp(143):InjectLibrary$ 此处获得两个目录： /var/mobile/Containers/Bundle/Application/3AE519BF-2FD2-43FC-A14B-2893190B8E1E/WeChat.app/WeChat /var/mobile/Containers/Data/Application/54EF9A70-8E3A-4B6D-B7F4-554AB256C48B/Documents/ 开砸1234567891011121314151617181920212223242526$ cd ~$ cp dumpdecrypted.dylib /var/mobile/Containers/Data/Application/54EF9A70-8E3A-4B6D-B7F4-554AB256C48B/Documents/$ cd /var/mobile/Containers/Data/Application/54EF9A70-8E3A-4B6D-B7F4-554AB256C48B/Documents/$ DYLD_INSERT_LIBRARIES=dumpdecrypted.dylib /var/mobile/Containers/Bundle/Application/3AE519BF-2FD2-43FC-A14B-2893190B8E1E/WeChat.app/WeChatmach-o decryption dumperDISCLAIMER: This tool is only meant for security research purposes, not for application crackers.[+] detected 64bit ARM binary in memory.[+] offset to cryptid found: @0x1000c0ca8(from 0x1000c0000) = ca8[+] Found encrypted data at address 00004000 of length 51200000 bytes - type 1.[+] Opening /private/var/mobile/Containers/Bundle/Application/3AE519BF-2FD2-43FC-A14B-2893190B8E1E/WeChat.app/WeChat for reading.[+] Reading header[+] Detecting header type[+] Executable is a plain MACH-O image[+] Opening WeChat.decrypted for writing.[+] Copying the not encrypted start of the file[+] Dumping the decrypted data into the file[+] Copying the not encrypted remainder of the file[+] Setting the LC_ENCRYPTION_INFO-&gt;cryptid to 0 at offset ca8[+] Closing original file[+] Closing dump file$ ls WeChat.decryptedWeChat.decrypted$ pwd/var/mobile/Containers/Data/Application/54EF9A70-8E3A-4B6D-B7F4-554AB256C48B/Documents 最后得到文件: /var/mobile/Containers/Data/Application/54EF9A70-8E3A-4B6D-B7F4-554AB256C48B/Documents/WeChat.decrypted 将*.decrypted拷贝出来我这里直接使用scp吧～。 123456$ cd /Users/Madordie/Desktop/Madordie/iOS/xxx$ scp root@10.12.14.16:/var/mobile/Containers/Data/Application/54EF9A70-8E3A-4B6D-B7F4-554AB256C48B/Documents/WeChat.decrypted .root@10.12.14.16's password:WeChat.decrypted 100% 61MB 4.7MB/s 00:12$ ls WeChat.decryptedWeChat.decrypted 至此在主机上得到： /Users/Madordie/Desktop/Madordie/iOS/xxx/WeChat.decrypted 总结 为什么将dumpdecrypted.dylib copy 至*/Documents/下？ ：别的目录没有权限～～（dumpdecrypted.dylib: stat() failed with errno=1 ） 使用clutch进行砸壳步骤下载上传clutch(无须重复做)clutch可以从https://github.com/KJCracks/Clutch下载编译。 当然也可以从https://github.com/KJCracks/Clutch/releases直接下载。 目前下载到目录~/Clutch-2.0.4 上传到设备： 1234$ cd ~$ scp Clutch-2.0.4 root@10.12.14.16:/usr/bin/root@10.12.14.16's password:Clutch-2.0.4 100% 1204KB 4.7MB/s 00:00 登录进越狱设备可以使用ssh root@IP进行登录。 当然也可以使用ssh ipad，这样免密登录登录。 配置传送门 修改权限1234$ cd ~$ cd /usr/bin$ mv Clutch-2.0.4 clutch$ chmod +x clutch 砸壳12345678910111213141516$ clutch -iInstalled apps:1: 钉钉 &lt;com.laiwang.DingTalk&gt;2: 韩剧TV-最新热门韩剧大全 &lt;com.baoyun.hanju&gt;3: PG Client - a better client for dribbble &lt;com.az.azdribbble&gt;4: 窝牛－设计装修我们的家 &lt;com.lingduohome.acorn&gt;$ clutch -d 1com.laiwang.DingTalk contains watchOS 2 compatible application. It's not possible to dump watchOS 2 apps with Clutch 2.0.4 at this moment.Zipping DingTalk.appASLR slide: 0x10001c000Dumping &lt;DingTalk&gt; (arm64)Patched cryptid (64bit segment)Writing new checksumDONE: /private/var/mobile/Documents/Dumped/com.laiwang.DingTalk-iOS7.0-(Clutch-2.0.4).ipaFinished dumping com.laiwang.DingTalk in 40.6 seconds$ 生成最终路径: /private/var/mobile/Documents/Dumped/com.laiwang.DingTalk-iOS7.0-(Clutch-2.0.4).ipa 传至本地注意路径中有()这样的字符，需要转义一下。如下： 在本地终端中使用scp拉取： 1234567$ scp root@10.12.14.16:'/private/var/mobile/Documents/Dumped/com.laiwang.DingTalk-iOS7.0-\(Clutch-2.0.4\).ipa' .root@10.12.14.16's password:com.laiwang.DingTalk-iOS7.0-(Clutch-2.0.4).ip 100% 48MB 3.6MB/s 00:13$ ls com.laiwang.DingTalk-iOS7.0-\(Clutch-2.0.4\).ipacom.laiwang.DingTalk-iOS7.0-(Clutch-2.0.4).ipa$ pwd/Users/Madordie/Desktop/Madordie/ios-reverse 至此在主机上得到： /Users/Madordie/Desktop/Madordie/ios-reverse/com.laiwang.DingTalk-iOS7.0-\(Clutch-2.0.4\).ipa 总结 并不是每一个都可以支持这种工具砸壳，失败了用第一种试试。。。 最后目前发现这两种砸壳工具。但是并不是每一个APP都可以使用2种工具。有的只有一个有效，有的两个都有效，还有一种两个都失败的😂]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>逆向</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS逆向-设备ssh免密登录]]></title>
    <url>%2Fpost%2Freverse-ios-ssh%2F</url>
    <content type="text"><![CDATA[前提条件 已越狱设备 越狱设备安装OpenSSH(⚠️记得修改默认的’alpine’登录密码) 电脑和设备同局域网。（我这里设备IP：10.11.12.13，并且设置成静态IP了😂） 步骤生成RSA证书我这里生成的证书为:ipad，可自己需要定义。（注意如果直接回车会覆盖~/.ssh/id_rsa） 执行命令ssh-keygen，如下：12345678910111213141516171819202122232425$ cd ~/.ssh/$ ssh-keygenGenerating public/private rsa key pair.Enter file in which to save the key (/Users/Madordie/.ssh/id_rsa): ipadEnter passphrase (empty for no passphrase):Enter same passphrase again:Your identification has been saved in ipad.Your public key has been saved in ipad.pub.The key fingerprint is:SHA256:GpQBeAf+oqUzWlUhtItDcVyVFz2wd0EcIgD+BZLPK8U Madordie@Bingo.localThe key's randomart image is:+---[RSA 2048]----+| .+*+*++o++.o+. || .+o+o=...oo... || ..o.=+ .o ... || . . = .E. . . || o = o.S. || * ..o. || * .. || o o ||. |+----[SHA256]-----+$ ls ~/.ssh/ipad*/Users/Madordie/.ssh/ipad /Users/Madordie/.ssh/ipad.pub 将公钥推送至越狱设备默认是没有~/.ssh目录的，暂时放置在/var/root下。 1$ scp ~/.ssh/ipad.pub root@10.11.12.13:/var/root scp 默认端口为22 如果需要自定义端口可以在路径前添加-P 端口号参数。 配置本机~/.ssh/config文件使用顺手的工具编辑~/.ssh/config文件。（没有就新建一个啦～ 按照如下格式填写。默认ssh登录端口为22可以不写。123456Host ipad Hostname 10.11.12.13 User root Port 22 PreferredAuthentications publickey IdentityFile ~/.ssh/ipad 配置越狱设备先用ssh root@10.11.12.13登录进设备。刚才我们将ipad.pub通过scp放在了/var/root下。 一般情况下/var/root/.ssh是不存在的，使用命令mkdir -p /var/root/.ssh即可创建。 1$ cat ipad.pub &gt;&gt; /var/root/.ssh/authorized_keys 然后强迫症的可以使用rm -rf ipad.pub删除啦～ 对了，退出ssh登录的设备使用： 123$ exitlogoutConnection to 10.11.12.13 closed. 赶紧测试一下远程登录效果1$ ssh ipad 然后你会发现你已经完成了免密码登录越狱设备。 总结其实这并不是只有越狱iOS设备才能使用的免登录，而是ssh所支持的。用途也很方便～]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>逆向</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自定义数据填充Sketch插件]]></title>
    <url>%2Fpost%2Fformat-sketchplugin%2F</url>
    <content type="text"><![CDATA[先来个README.md format-sketchplugin 为Sketch自动生成自定义填充数据源插件。 使用方法 下载Release上的包，并双击打开 选择要随机填充的文本数据(支持多选，文本数据按照回车进行随机，会默认删除空数据) 选择随机填充的图片文件夹(只支持单选文件夹，选中文件夹内的.png、 .PNG、 .jpg、 .JPG、 .jpeg、 .JPEG、 .gif、 .GIF文件将会被识别并作为数据源) 将插件生成目录拖拽至窗口即完成设置 文本、图片文件夹 可在保存前重复多次选择 点击制作，即可在生成目录看到插件生成 生成说明 文本数据按照文本文件名作为标示 图片文件夹按照图片文件夹名作为标示 保存时，文本数据会读取至插件内 保存时，图片文件夹会复制至插件内(不识别子目录，并只拷贝可识别的素材)]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>Sketchplugin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS11-beta]]></title>
    <url>%2Fpost%2Fios11-beta%2F</url>
    <content type="text"><![CDATA[iOS11 预览版安装体验笔记。 写在前面毕竟beta版，升级需谨慎。目前来看体验上还是有点卡的～～😂 卡顿让我实在无法忍受，并与6.15号重置回iOS10.3.2 。。。 9.13 GM出来了，再安装～～ 适配有先后，iOS11马上就要发了，而iPhoneX还需要等一小段时间。所以iOS11的适配比iPhoneX有更高的优先级～ API失效的automaticallyAdjustsScrollViewInsetsiOS11 版本中 立即失效。 最容易出问题的就是无导航的顶部刷新会莫名其妙的缩不进去～～ 还有就是如果没有使用这个automaticallyAdjustsScrollViewInsets，为了达到那种戳进去的代码直接设置frame.y = 0。这种操作不但会出现导航栏莫名其妙的戳出来，还有UITableView.section.header莫名错位的问题。 API 声明： 1234567@available(iOS 2.0, *)open class UIViewController : UIResponder, ... &#123; ... @available(iOS, introduced: 7.0, deprecated: 11.0) open var automaticallyAdjustsScrollViewInsets: Bool // Defaults to YES ...&#125; 相应的的替换方案： 12345678910@available(iOS 2.0, *)open class UIScrollView : UIView, ... &#123; ... /* Configure the behavior of adjustedContentInset. Default is UIScrollViewContentInsetAdjustmentAutomatic. */ @available(iOS 11.0, *) open var contentInsetAdjustmentBehavior: UIScrollViewContentInsetAdjustmentBehavior ...&#125; decisionHandler(.allow) was called more than once崩溃信息： 123#0 ThreadNSInternalInconsistencyExceptionCompletion handler passed to -[WKWebViewJavascriptBridge webView:decidePolicyForNavigationAction:decisionHandler:] was called more than once 这是WebViewJavascriptBridge在iOS11上的一个Issues#302。 据同事说可以通过如下代码解决：1234if WebViewJavascriptBridgeBase().isWebViewJavascriptBridgeURL(url) &#123; return&#125;decisionHandler(.allow) 测试了一下确实不崩溃了，但是具体的解决方案还要看作者的在Issues#302中的回复。 照片存储时候某些设备必crash崩溃信息: 1232017-09-29 11:36:17.338816+0800 Demo-iOS11-crash-save-photo[636:139456] [access] This app has crashed because it attempted to access privacy-sensitive data without a usage description. The app&apos;s Info.plist must contain an NSPhotoLibraryAddUsageDescription key with a string value explaining to the user how the app uses this data. 是的，这个Demo还有一个crash的提示。但是在大工程中，我并没有看到这样的玩意输出出来。。我做的复现操作较简单： 123456let img = UIImage(named: "278.jpg")let library = ALAssetsLibrary()guard let orientation = ALAssetOrientation(rawValue: img?.imageOrientation.rawValue ?? 0) else &#123; return &#125;library.writeImage(toSavedPhotosAlbum: img?.cgImage, orientation: orientation) &#123; (url, error) in guard error != nil else &#123; print("no crash"); return &#125;&#125; 就这么多代码，不管是打没打Swift Error、All Exceptions都无法定位到上面代码块，这才是最坑的。 上面代码漏了一句关键的代码： 1guard ALAssetsLibrary.authorizationStatus() == .authorized else &#123; return &#125; 需要注意的是上面代码之判断了是否有权限，但是在iOS11上并不会弹出什么授权提示。就算在Info.plist中添加NSPhotoLibraryUsageDescription依旧无济于事。 目前来看，iOS11中只有添加NSPhotoLibraryAddUsageDescription才可以。 navigationItem.titleView 点击区域偏移所设置的View需要实现：12345@implementation DNImageFoldTitleView- (CGSize)intrinsicContentSize &#123; return UILayoutFittingExpandedSize;&#125;@end]]></content>
      <categories>
        <category>iOS</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[「转」Unowned 还是 Weak？生命周期和性能对比]]></title>
    <url>%2Fpost%2Fswiftgg-unowned-or-weak-lifetime-and-performance%2F</url>
    <content type="text"><![CDATA[作者：Umberto Raimondi，原文链接，原文日期：2016-10-27译者：shanks；校对：Crystal Sun；定稿：CMB 每当处理循环引用（retain cycles）时，需要考量对象生命周期来选择unowned或者weak标识符，这已经成为了一个共识。但是有时仍然会心存疑问，在具体的使用中应该选择哪一个，或者退一步讲，保守的只使用 weak 是不是一个好的选择呢？ 本文首先对循环引用的基础知识做一个简要介绍，然后会分析 Swift 源代码的一些片段，讲解 unowned 和 weak 在生命周期和性能上的差异点，希望看完本文以后，在的使用场景中，能使用正确的弱引用类型。 目录: 基础知识 问题来了: unowened 还是 weak? 性能：深度探索 捕获列表处理解析 结论 脚注 从 GitHub 或者 zipped 获取本文相关的 Playground 代码。然后从这里获取闭包案例和 SIL，SILGen 以及 LLVM IR 的输出。 基础知识众所周知，Swift 利用古老并且有效的自动引用计数（ARC, Automatic Reference Counting）来管理内存，带来的后果和在 Objective-C 中使用的情况类似，需要手动使用弱引用来解决循环引用问题。 如果对 ARC 不了解，只需要知道的是，每一个引用类型实例都有一个引用计数与之关联，这个引用计数用来记录这个对象实例正在被变量或常量引用的总次数。当引用计数变为 0 时，实例将会被析构，实例占有的内存和资源都将变得重新可用。 当有两个实例通过某种形式互相引用时，就会形成循环引用（比如：两个类实例都有一个属性指向对方的类实例；双向链表中两个相邻的节点实例等…）, 由于两个实例的引用计数都一直大于 0， 循环引用将会阻止这些实例的析构。 为了解决这个问题，和其他一些有类似问题的语言一样， 在 Swift 中，弱引用 的概念被提了出来，弱引用不会被 ARC 计算，也就是说，当一个弱引用指向一个引用类型实例时，引用计数不会增加。 弱引用不会阻止实例的析构, 只需要记住的是，在任何情况下，弱引用都不会拥有它指向的对象。在正式的场景中不是什么大问题，但是在我们处理这类引用的时候，需要意识到这一点。 在 Swift 中有 2 种 弱 引用形式，unowned 和 weak。 虽然它们的作用类似，但与它们相关实例生命周期的假设会略有不同，并且具有不同的性能特征。 为了举例说明循环引用，这里不使用大家期望看到的类之间的循环引用，而使用闭包的上下文案例，这在 Objective-C 日常开发中处理循环引用时经常会遇到的情况。和类的循环引用类似，通过创建一个强引用指向外部实例，或捕获它，阻止它析构。 在 Objective-C ，按照标准的做法，定义一个弱引用指向闭包外部的实例，然后在闭包内部定义强引用指向这个实例，在闭包执行期间使用它。当然，有必要在使用前检查引用的有效性。 为了更方便的处理循环引用，Swift 引入了一个新的概念，用于简化和更加明显地表达在闭包内部外部变量的捕获：捕获列表（capture list）。使用捕获列表，可以在函数的头部定义和指定那些需要用在内部的外部变量，并且指定引用类型(译者注：这里是指 unowned 和 weak）。 接下来举一些例子，在各种情况下捕获变量的表现。 当不使用捕获列表时，闭包将会创建一个外部变量的强引用： 123456789var i1 = 1, i2 = 1var fStrong = &#123; i1 += 1 i2 += 2&#125;fStrong()print(i1,i2) //Prints 2 and 3 闭包内部对变量的修改将会改变外部原始变量的值，这与预期是一致的。 使用捕获列表，闭包内部会创建一个新的可用常量。如果没有指定常量修饰符，闭包将会简单地拷贝原始值到新的变量中，对于值类型和引用类型都是一样的。 12345678var fCopy = &#123; [i1] in print(i1,i2)&#125;fStrong()print(i1,i2) //打印结果是 2 和 3 fCopy() //打印结果是 1 和 3 在上面的例子中，在调用 fStrong 之前定义函数 fCopy ,在该函数定义的时候，私有常量已经被创建了。正如你所看到的，当调用第二个函数时候，仍然打印 i1 的原始值。 对于外部引用类型的变量，在捕获列表中指定 weak 或 unowned，这个常量将会被初始化为一个弱引用，指向原始值，这种指定的捕获方式就是用来处理循环引用的方式。 12345678910111213141516class aClass&#123; var value = 1&#125;var c1 = aClass()var c2 = aClass()var fSpec = &#123; [unowned c1, weak c2] in c1.value += 1 if let c2 = c2 &#123; c2.value += 1 &#125;&#125;fSpec()print(c1.value,c2.value) //Prints 2 and 2 两个 aClass 捕获实例的不同的定义方式，决定了它们在闭包中不同的使用方式。 unowned 引用使用的场景是，原始实例永远不会为 nil，闭包可以直接使用它，并且直接定义为显式解包可选值。当原始实例被析构后，在闭包中使用这个捕获值将导致崩溃。 如果捕获原始实例在使用过程中可能为 nil ，必须将引用声明为 weak， 并且在使用之前验证这个引用的有效性。 问题来了: unowened 还是 weak?在实际使用中如何选择这两种弱引用类型呢？ 这个问题的答案可以简单由原始对象和引用它的闭包的生命周期来解释。 有两个可能出现的场景： 闭包和捕获对象的生命周期相同，所以对象可以被访问，也就意味着闭包也可以被访问。外部对象和闭包有相同的生命周期(比如：对象和它的父对象的简单返回引用）。在这种情况下，你应该把引用定义为 unowned。 一个经典的案例是: [unowned self], 主要用在闭包中，这种闭包主要在他们的父节点上下文中做一些事情，没有在其他地方被引用或传递，不能作用在父节点之外。 闭包的生命周期和捕获对象的生命周期相互独立，当对象不能再使用时，闭包依然能够被引用。这种情况下，你应该把引用定义为 weak，并且在使用它之前验证一下它是否为 nil（请不要对它进行强制解包). 一个经典的案例是: [weak delegate = self.delegate!]，可以在某些使用闭包的场景中看到，闭包使用的是完全无关（生命周期独立）的代理对象。 当无法确认两个对象之间生命周期的关系时，是否不应该去冒险选择一个无效 unowned 引用？而是保守选择 weak 引用是一个更好的选择？答案是否定的，不仅仅是因为对象生命周期了解是一件必要的事情，而且这两个修饰符在性能特性上也有很大的不同。 弱引用最常见的实现是，每次一个新的引用生成时，都会把每个弱引用和它指向的对象信息存储到一个附加表中。 当没有任何强引用指向一个对象时，Swift 运行时会启动析构过程，但是在这之前，运行时会把所有相关的弱引用置为 nil 。弱引用的这种实现方式我们称之为”零和弱引用”。 这种实现有实际的开销，考虑到需要额外实现的数据结构，需要确保在并发访问情况下，对这个全局引用结构所有操作的正确性。一旦析构过程开始了，在任何环境中，都不允许访问弱引用所指向的对象了。 弱引用（包括 unowned 和一些变体的 weak)在 Swift 使用了更简单和快速的实现机制。 Swift 中的每个对象保持了两个引用计数器，一个是强引用计数器，用来决定 ARC 什么时候可以安全地析构这个对象，另外一个附加的弱引用计数器，用来计算创建了多少个指向这个对象的 unowned 或者 weak 引用，当这个计数器为零时，这个对象将被 析构 。 需要重点理解的是，只有等到所有 unowned 引用被释放后，这个对象才会被真正地析构，然后对象将会保持未解析可访问状态，当析构发生后，对象的内容才会被回收。 每当 unowned 引用被定义时，对应的 unowned 引用计数会进行原子级别地增加(使用原子gcc/llvm操作，进行一系列快速且线程安全的基本操作，例如：增加，减少，比较，交换等)，以保证线程安全。在增加计数之前，会检查强引用计数以确保对象是有效的。 试图访问一个无效的对象，将会导致错误的断言，你的应用在运行时中会报错(这就是为什么这里的 unownd 实现方式叫做 unowned(safe) 实现)为了更好的优化，应用编译时带有 -OFast，unowned 引用不会去验证引用对象的有效性，unowned 引用的行为就会像 Objective-C 中的 __unsafe_unretained 一样。如果引用对象无效，unowned 引用将会指向已经释放垃圾内存（这种实现称之 unowned(unsafe)）。 当一个 unowned 引用被释放后，如果这时没有其他强引用或 unowned 引用指向这个对象，那么最终这个对象将被析构。这就是为什么一个引用对象不能在强引用计数器等于零的情况下，被析构的原因，所有的引用计数器必须能够被访问用来验证 unowned 引用和强引用数量。 Swift 的 weak 引用添加了附加层，间接地把 unowned 引用包裹到了一个可选容器里面，在指向的对象析构之后变成空的情况下，这样处理会更加的清晰。但是需要付出的代价是，附加的机制需要正确地处理可选值。 考虑到以上因素，在对象关系生命周期允许的情况下，优先选择使用 unowned 引用。但是这不是此故事的结局，接下来比较一下两者性能1上的差别。 性能：深度探索在查看 Swift 项目源码验证之前，需要理解 ARC 如何管理这两种引用类型，并且还需要解释 swiftc，LLVM 和 SIL 的相关知识。 接下来试着简要介绍本文所需要的必备知识点，如果想了解更多，将在最后的脚注中找到一些有用的链接。 使用一个图来解释 swiftc 整个编译过程的包含的模块： Swiftc 和 clang 一样构建在 LLVM 上，遵循 clang 编译器相似的编译流程。 在编译过程的第一部分，使用一个特定语言前端进行管理，swift 源代码被解释生成一个抽象语法树(AST)表达2，然后抽象语法树的结果从语义角度进行分析，找出语义错误。 在这个点上，对于其他的基于 LLVM 的编译器来讲，在通过一个附加步骤对源代码进行静态分析后（必要时可以显示错误和警告），接着 IRGen 模块 会把 AST 的内容会转换成一个轻量的和底层的机器无关的表示，我们称之为 LLVM IR(LLVM 中间表示)。 尽管两个模块都需要做一些相同检查，但是这两个模块是区分开的，在两个模块之间也存在许多重复的代码。 IR 是一种静态单赋值形式（SSA-form）一致语言，可以看做注入了 LLVM 的虚拟机下的 RISC 类型汇编语言。基于 SSA 将简化接下来的编译过程，从语言前端提供的中间表达会在 IR 进行多重优化。 需要重点注意的是，IR 其中一个特点是，它具有三种不同的形式：内存表达（内部使用），序列化位代码形式（你已经知道的位代码形式）和可读形式。 最后一种形式非常有用，用来验证 IR 代码的最终结构，这个结构将会传入到整个过程中的最后一步，将会从机器独立的 IR 代码转换成平台相关的表达(比如：x86，ARM 等等)。最后一步将被 LLVM 平台后端执行。 那么 swiftc 和其他基于 LLVM 的编译器有什么不同呢？swiftc 和其他编译器从结构形式上的差别主要体现在一个附加组件，这个附加组件是 SILGen ，在 IRGen 之前，执行代码的监测和优化，生成一个高级的中间表达，我们称之为 SIL （Swift Intermediate Language，Swift 中间语言），最后 SIL 将会转换成 LLVM IR。这一步加强了在单个软件模块上所有具体语言的检查，并且简化了 IRGen。 从 AST 到 IR 的转换分为两个步骤。SILGen 把 AST 源代码转换为原始 SIL ，然后编译器进行 Swift 语法检查（需要时打印错误或者警告信息），优化有效的原始 SIL ，通过一些步骤最后生成标准化 SIL 。如上面的示意图显示那样，标准化 SIL 的最后转化为 LLVM IR。 再次强调，SIL 是一个 SSA 类型语言，使用附加的结构扩展了 Swift 的语法。它依赖 Swift 的类型系统，并且能理解 Swift 的定义，但是需要重点记住的是，当编译一个手写的 SIL 源码（是的，可以手动写 SIL 然后编译它）时，高阶的 Swift 代码或者函数内容将被编译器忽略。 在接下来的章节，我们将分析一个标准化 SIL 的案例，来理解 unowned 和 weak 引用如何被编译器处理。一个包含捕获列表的基本闭包的例子，查看这个例子生成的 SIL 代码，可以看到被编译器添加的所有 ARC 相关的函数调用。 从 GitHub 或者 zipped 获取本文相关的 Playground 代码。然后从这里获取闭包案例和 SIL ，SILGen 以及 LLVM IR 的输出。 捕获列表处理解析接下来看看一个简单的 Swift 的例子，定义两个类变量，然后在一个闭包中对他们进行弱引用的捕获： 12345678910111213141516class aClass&#123; var value = 1&#125;var c1 = aClass()var c2 = aClass()var fSpec = &#123; [unowned c1, weak c2] in c1.value = 42 if let c2o = c2 &#123; c2o.value = 42 &#125;&#125;fSpec() 通过 xcrun swiftc -emit-sil sample.swift 编译 swift 源代码，生成标准化 SIL 代码。原始SIL 可以使用 -emit-silgen 选项来生成。 运行以上命令以后，会发现 swiftc 产生了许多代码。通过查看 swiftc 输出代码的片段，学习一下基本的 SIL 指令，理解整个结构。 在下面代码中需要的地方添加了一些多行注释（编译器也生成了一些单行注释），希望这些注释已经足够说清楚发生了什么： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145/* 此文件包含典型 SIL 代码*/sil_stage canonical /* 只有在 SIL 内部使用的特殊的导入*/import Builtin import Swiftimport SwiftShims/* 三个全局变量的定义，包括 c1，c2 和 闭包 fSpec。 @_Tv4clos2c1CS_6aClass是变量的符号，$aClass 是它的类型（类型前缀为$)。 变量名在这里看起来很乱，但是在后面的代码中将变得更加可读。*/// c1sil_global hidden @_Tv4sample2c1CS_6aClass : $aClass// c2sil_global hidden @_Tv4sample2c2CS_6aClass : $aClass// fSpecsil_global hidden @_Tv4sample5fSpecFT_T_ : $@callee_owned () -&gt; ().../* 层次作用域定义表示原始代码的位置。 每个 SIL 指示将会指向它生成的 `sil_scope`。*/sil_scope 1 &#123; parent @main : $@convention(c) (Int32, UnsafeMutablePointer&lt;Optional&lt;UnsafeMutablePointer&lt;Int8&gt;&gt;&gt;) -&gt; Int32 &#125;sil_scope 2 &#123; loc "sample.swift":14:1 parent 1 &#125;/* 自动生成的 @main 函数包含了我们原始全部作用域的代码。 这里沿用了熟悉的 c main() 函数结构，接收参数个数和参数数组两个输入，这个函数遵循 c 调用约定。 这个函数包含了需要调用闭包的指令。*/// mainsil @main : $@convention(c) (Int32, UnsafeMutablePointer&lt;Optional&lt;UnsafeMutablePointer&lt;Int8&gt;&gt;&gt;) -&gt; Int32 &#123;/* 入口定义头部为 % 符号，后面跟随一个数字 id。 每当一个新的入口定义时（或者函数开头定义函数参数），编译器在入口行尾根据它的值（叫做 users）添加一个注释。 对于其他指令，需要提供 id 号。 在这里，入口 0 将被用来计算入口 4 的内容，入口 1 将被用来创建入口 10 的值。*/// %0 // user: %4// %1 // user: %10/* 每一个函数被分解成一系列的基本指令块，每一个指令块结束于一个终止指令（一个分支或者一个返回）。 这一系列的指令块表示函数所有可能的执行路径。*/bb0(%0 : $Int32, %1 : $UnsafeMutablePointer&lt;Optional&lt;UnsafeMutablePointer&lt;Int8&gt;&gt;&gt;):... /* 每一个 SIL 指令都包含一个引用，指向源代码的位置，包括指令具体从源代码中哪个地方来，属于哪一个作用域。 在后面分析具体的方法会看到这些内容。 */ unowned_retain %27 : $@sil_unowned aClass, loc "sample.swift":9:14, scope 2 // id: %28 store %27 to %2 : $*@sil_unowned aClass, loc "sample.swift":9:14, scope 2 // id: %29 %30 = alloc_box $@sil_weak Optional&lt;aClass&gt;, var, name "c2", loc "sample.swift":9:23, scope 2 // users: %46, %44, %43, %31 %31 = project_box %30 : $@box @sil_weak Optional&lt;aClass&gt;, loc "sample.swift":9:23, scope 2 // user: %35 %32 = load %19 : $*aClass, loc "sample.swift":9:23, scope 2 // users: %34, %33 ...&#125;.../* 下面是一系列自动生成的`aClass`的方法，包括： init/deinit, setter/getter 和其他一些工具方法。 每个方法前的注释是编译器添加的，用来说明代码的具体作用。*//* 隐藏方法只在它们模块中可见。 @convention(方法名)是 Swift 中方法调用默认的约定，在尾部有一个附加的参数指向它自己。*/// aClass.__deallocating_deinitsil hidden @_TFC4clos6aClassD : $@convention(method) (@owned aClass) -&gt; () &#123; ...&#125;/* @guaranteed 参数表示保证在整个周期内调用此方法都有效。*/// aClass.deinitsil hidden @_TFC4clos6aClassd : $@convention(method) (@guaranteed aClass) -&gt; @owned Builtin.NativeObject &#123; ...&#125;/* [transparent] 修饰的方法是内联的小方法*/// aClass.value.gettersil hidden [transparent] @_TFC4clos6aClassg5valueSi : $@convention(method) (@guaranteed aClass) -&gt; Int &#123; ...&#125;// aClass.value.settersil hidden [transparent] @_TFC4clos6aClasss5valueSi : $@convention(method) (Int, @guaranteed aClass) -&gt; () &#123; ...&#125;// aClass.value.materializeForSetsil hidden [transparent] @_TFC4clos6aClassm5valueSi : $@convention(method) (Builtin.RawPointer, @inout Builtin.UnsafeValueBuffer, @guaranteed aClass) -&gt; (Builtin.RawPointer, Optional&lt;Builtin.RawPointer&gt;) &#123; ...&#125;/* @owned 修饰符表示这个对象将被调用者拥有。*/// aClass.init() -&gt; aClasssil hidden @_TFC4clos6aClasscfT_S0_ : $@convention(method) (@owned aClass) -&gt; @owned aClass &#123; ...&#125;// aClass.__allocating_init() -&gt; aClasssil hidden @_TFC4clos6aClassCfT_S0_ : $@convention(method) (@thick aClass.Type) -&gt; @owned aClass &#123; ...&#125;/* 接下面是闭包代码段*/// (closure #1)sil shared @_TF4closU_FT_T_ : $@convention(thin) (@owned @sil_unowned aClass, @owned @box @sil_weak Optional&lt;aClass&gt;) -&gt; () &#123; ... /* 关于闭包的 SIL 代码， 见下文 */ ...&#125;.../* sil_vtable 定义所有关于 aClass 类的虚函数表。 sil_vtable 包含了期望的所有自动生成的方法。*/sil_vtable aClass &#123; #aClass.deinit!deallocator: _TFC4clos6aClassD // aClass.__deallocating_deinit #aClass.value!getter.1: _TFC4clos6aClassg5valueSi // aClass.value.getter #aClass.value!setter.1: _TFC4clos6aClasss5valueSi // aClass.value.setter #aClass.value!materializeForSet.1: _TFC4clos6aClassm5valueSi // aClass.value.materializeForSet #aClass.init!initializer.1: _TFC4clos6aClasscfT_S0_ // aClass.init() -&gt; aClass&#125; 现在回到主函数，看看两个类实例如何被获取到，并如何传递给调用他们的闭包。 在这里，所有标识都被重新整理，使得代码片段更加可读。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071// mainsil @main : $@convention(c) (Int32, UnsafeMutablePointer&lt;Optional&lt;UnsafeMutablePointer&lt;Int8&gt;&gt;&gt;) -&gt; Int32 &#123;// %0 // user: %4// %1 // user: %10bb0(%0 : $Int32, %1 : $UnsafeMutablePointer&lt;Optional&lt;UnsafeMutablePointer&lt;Int8&gt;&gt;&gt;): ... /* 全局变量的引用使用三个入口来放置。 */ %13 = global_addr @clos.c1 : $*aClass, loc "sample.swift":5:5, scope 1 // users: %26, %17 ... %19 = global_addr @clos.c2 : $*aClass, loc "sample.swift":6:5, scope 1 // users: %32, %23 ... %25 = global_addr @clos.fSpec : $*@callee_owned () -&gt; (), loc "sample.swift":8:5, scope 1 // users: %48, %45 /* c1 是 unowned_retained 的。 下面的指令增加变量的 unowned 引用计数。 */ %26 = load %13 : $*aClass, loc "sample.swift":9:14, scope 2 // user: %27 %27 = ref_to_unowned %26 : $aClass to $@sil_unowned aClass, loc "sample.swift":9:14, scope 2 // users: %47, %38, %39, %29, %28 unowned_retain %27 : $@sil_unowned aClass, loc "sample.swift":9:14, scope 2 // id: %28 store %27 to %2 : $*@sil_unowned aClass, loc "sample.swift":9:14, scope 2 // id: %29 /* 对 c2 的处理会更加复杂一些。 alloc_box 创建了一个这个变量的引用数容器，变量将会存在这个容器的堆中。 容器创建以后，将会创建一个可选变量，指向 c2，并且可选变量会存储在容器里。容器会增加所包含值的技术，正如下面看到的一样，一旦容器被迁移，可选值就会被释放。 在这里，c2 的值将被存储在这个可选值中，对象将暂时strong_retained 然后释放。 */ %30 = alloc_box $@sil_weak Optional&lt;aClass&gt;, var, name "c2", loc "sample.swift":9:23, scope 2 // users: %46, %44, %43, %31 %31 = project_box %30 : $@box @sil_weak Optional&lt;aClass&gt;, loc "sample.swift":9:23, scope 2 // user: %35 %32 = load %19 : $*aClass, loc "sample.swift":9:23, scope 2 // users: %34, %33 strong_retain %32 : $aClass, loc "sample.swift":9:23, scope 2 // id: %33 %34 = enum $Optional&lt;aClass&gt;, #Optional.some!enumelt.1, %32 : $aClass, loc "sample.swift":9:23, scope 2 // users: %36, %35 store_weak %34 to [initialization] %31 : $*@sil_weak Optional&lt;aClass&gt;, loc "sample.swift":9:23, scope 2 // id: %35 release_value %34 : $Optional&lt;aClass&gt;, loc "sample.swift":9:23, scope 2 // id: %36 /* 获取到闭包的引用。 */ // function_ref (closure #1) %37 = function_ref @sample.(closure #1) : $@convention(thin) (@owned @sil_unowned aClass, @owned @box @sil_weak Optional&lt;aClass&gt;) -&gt; (), loc "sample.swift":8:13, scope 2 // user: %44 /* c1 将被标记为 tagged，并且变量变为 unowned_retained。 */ strong_retain_unowned %27 : $@sil_unowned aClass, loc "sample.swift":8:13, scope 2 // id: %38 %39 = unowned_to_ref %27 : $@sil_unowned aClass to $aClass, loc "sample.swift":8:13, scope 2 // users: %42, %40 %40 = ref_to_unowned %39 : $aClass to $@sil_unowned aClass, loc "sample.swift":8:13, scope 2 // users: %44, %41 unowned_retain %40 : $@sil_unowned aClass, loc "sample.swift":8:13, scope 2 // id: %41 strong_release %39 : $aClass, loc "sample.swift":8:13, scope 2 // id: %42 /* 包含 c2 的可选值容器是 strong_retained 的。 */ strong_retain %30 : $@box @sil_weak Optional&lt;aClass&gt;, loc "sample.swift":8:13, scope 2 // id: %43 /* 创建一个闭包对象，绑定方法到参数中。 */ %44 = partial_apply %37(%40, %30) : $@convention(thin) (@owned @sil_unowned aClass, @owned @box @sil_weak Optional&lt;aClass&gt;) -&gt; (), loc "sample.swift":8:13, scope 2 // user: %45 store %44 to %25 : $*@callee_owned () -&gt; (), loc "sample.swift":8:13, scope 2 // id: %45 /* 对 c1 和 c2 的容器变量进行释放（使用 对应匹配的 *_release 方法）。 */ strong_release %30 : $@box @sil_weak Optional&lt;aClass&gt;, loc "sample.swift":14:1, scope 2 // id: %46 unowned_release %27 : $@sil_unowned aClass, loc "sample.swift":9:14, scope 2 // id: %47 /* 加载原先存储的闭包对象，增加强引用然后调用它。 */ %48 = load %25 : $*@callee_owned () -&gt; (), loc "sample.swift":17:1, scope 2 // users: %50, %49 strong_retain %48 : $@callee_owned () -&gt; (), loc "sample.swift":17:1, scope 2 // id: %49 %50 = apply %48() : $@callee_owned () -&gt; (), loc "sample.swift":17:7, scope 2 ...&#125; 闭包有一个更加复杂的结构： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566/* 闭包参数被标记为 @sil, 指定参数如何被计数，有一个 unowned 的 aClass 类变量 c2, 和另外一个包含 c2 的可选值容器。*/// (closure #1)sil shared @clos.fSpec: $@convention(thin) (@owned @sil_unowned aClass, @owned @box @sil_weak Optional&lt;aClass&gt;) -&gt; () &#123;// %0 // users: %24, %6, %5, %2// %1 // users: %23, %3/* 下面的函数包含三块，后面两块的执行依赖可选值 c2 具体的值。*/bb0(%0 : $@sil_unowned aClass, %1 : $@box @sil_weak Optional&lt;aClass&gt;):... /* c1 被强计数。 */ strong_retain_unowned %0 : $@sil_unowned aClass, loc "sample.swift":10:5, scope 17 // id: %5 %6 = unowned_to_ref %0 : $@sil_unowned aClass to $aClass, loc "sample.swift":10:5, scope 17 // users: %11, %10, %9 /* 使用内部自带包，传入一个整型字面量到整型结构中，初始化了一个值为 42 的整型值。 这个值将被设置为 c1 的新值，完成以后这个变量将会被释放。 在这里，我们第一次看到 class_method 指令，用于获取 vtable 中的函数引用。 */ %7 = integer_literal $Builtin.Int64, 42, loc "sample.swift":10:16, scope 17 // user: %8 %8 = struct $Int (%7 : $Builtin.Int64), loc "sample.swift":10:16, scope 17 // user: %10 %9 = class_method %6 : $aClass, #aClass.value!setter.1 : (aClass) -&gt; (Int) -&gt; () , $@convention(method) (Int, @guaranteed aClass) -&gt; (), loc "sample.swift":10:14, scope 17 // user: %10 %10 = apply %9(%8, %6) : $@convention(method) (Int, @guaranteed aClass) -&gt; (), loc "sample.swift":10:14, scope 17 strong_release %6 : $aClass, loc "sample.swift":10:16, scope 17 // id: %11 /* 接下来讨论 c2。 获取可选值，然后根据它的内容执行接下来的分支语句。 If the optional has a value the bb2 block will be executed before jumping to bb3, if it doesn't after a brief jump to bb1, the function will proceed to bb3 releasing the retained parameters. */ %12 = load_weak %3 : $*@sil_weak Optional&lt;aClass&gt;, loc "sample.swift":11:18, scope 18 // user: %13 switch_enum %12 : $Optional&lt;aClass&gt;, case #Optional.some!enumelt.1: bb2, default bb1, loc "sample.swift":11:18, scope 18 // id: %13 bb1: // Preds: bb0 /* 跳转到闭包的结尾。 */ br bb3, loc "sample.swift":11:18, scope 16 // id: %14// %15 // users: %21, %20, %19, %16bb2(%15 : $aClass): // Preds: bb0 /* 调用 aClass 的 setter，设置它的值为 42. */ ... %17 = integer_literal $Builtin.Int64, 42, loc "sample.swift":12:21, scope 19 // user: %18 %18 = struct $Int (%17 : $Builtin.Int64), loc "sample.swift":12:21, scope 19 // user: %20 %19 = class_method %15 : $aClass, #aClass.value!setter.1 : (aClass) -&gt; (Int) -&gt; () , $@convention(method) (Int, @guaranteed aClass) -&gt; (), loc "sample.swift":12:19, scope 19 // user: %20 %20 = apply %19(%18, %15) : $@convention(method) (Int, @guaranteed aClass) -&gt; (), loc "sample.swift":12:19, scope 19 strong_release %15 : $aClass, loc "sample.swift":13:5, scope 18 // id: %21 br bb3, loc "sample.swift":13:5, scope 18 // id: %22bb3: // Preds: bb1 bb2 /* 释放所有获取的变量然后返回。 */ strong_release %1 : $@box @sil_weak Optional&lt;aClass&gt;, loc "sample.swift":14:1, scope 17 // id: %23 unowned_release %0 : $@sil_unowned aClass, loc "sample.swift":14:1, scope 17 // id: %24 %25 = tuple (), loc "sample.swift":14:1, scope 17 // user: %26 return %25 : $(), loc "sample.swift":14:1, scope 17 // id: %26&#125; 在这里，忽略掉不同的 ARC 指令带来的性能的差异点，对不同阶段每种类型的捕获变量做一个快速的对比： 动作 Unowned Weak 预先调用 #1 对象进行 unowned_retain 创建一个容器，并且对象进行 strong_retain 操作。创建一个可选值，存入到容器中，然后释放可选值 预先调用 #2 strong_retain_unowned，unowned_retain 和 strong_release strong_retain 闭包执行 strong_retain_unowned，unowned_release load_weak, 打开可选值, strong_release 调用之后 unowned_release strong_release 正如上面看到的 SIL 代码段那样，处理 weak 引用会涉及到更多的工作，因为需要处理引用需要的可选值。 参照官方文档的描述，这里对涉及到的所有 ARC 指令做一个简要的解释： unowned_retain：增加堆对象中的 unowned 引用计数。 strong_retain_unowned ：断言对象的强引用计数大于 0，然后增加这个引用计数。 strong_retain：增加对象的强引用计数。 load_weak：不是真正的 ARC 调用，但是它将增加可选值指向对象的强引用计数。 strong_release：减少对象的强引用计数。如果释放操作把对象强引用计数变为0，对象将被销毁，然后弱引用将被清除。当整个强引用计数和 unowned 引用计数都为0时，对象的内存才会被释放。 unowned_release：减少对象的 unowned 引用计数。当整个强引用计数和 unowned 引用计数都为 0 时，对象的内存才会被释放。 接下来深入到 Swift 运行时看看，这些指令都是如何被实现的，相关的代码文件有：HeapObject.cpp，HeapObject.h，RefCount.h 和 Heap.cpp、 SwiftObject.mm 中的少量定义。容器实现可以在 MetadataImpl.h 找到，但是本文不展开讨论。 这些文件中定义大多数的 ARC 方法都有三种变体，一种是对 Swift 对象的基础实现，另外两种实现是针对非原生 Swift 对象的：桥接对象和未知对象。后面两种变体这里不予讨论。 第一个讨论指令集和 unowned 引用相关。 在 HeapObject.cpp 文件中间可以看到对 unowned_retain 和 unowned_release 的实现方法： 1234567891011121314151617181920212223242526SWIFT_RT_ENTRY_VISIBILITYvoid swift::swift_unownedRetain(HeapObject *object) SWIFT_CC(RegisterPreservingCC_IMPL) &#123; if (!object) return; object-&gt;weakRefCount.increment();&#125;SWIFT_RT_ENTRY_VISIBILITYvoid swift::swift_unownedRelease(HeapObject *object) SWIFT_CC(RegisterPreservingCC_IMPL) &#123; if (!object) return; if (object-&gt;weakRefCount.decrementShouldDeallocate()) &#123; // Only class objects can be weak-retained and weak-released. auto metadata = object-&gt;metadata; assert(metadata-&gt;isClassObject()); auto classMetadata = static_cast&lt;const ClassMetadata*&gt;(metadata); assert(classMetadata-&gt;isTypeMetadata()); SWIFT_RT_ENTRY_CALL(swift_slowDealloc) (object, classMetadata-&gt;getInstanceSize(), classMetadata-&gt;getInstanceAlignMask()); &#125;&#125; swift_unownedRetain 是 unowned_retain 的具体实现，简单地进行 unowned 引用计数的原子增加操作（这里定义为weakRefCount），swift_unownedRelease 更加复杂，原因之前也描述过，当没有其他 unowned 引用存在时，它需要执行对象的析构操作。 但是整体来讲都不复杂，在这里可以看到 doDecrementShouldDeallocate 方法，这个方法在上面代码中被一个命名类似的方法调用了。这个方法没有做太多，swift_slowDealloc 只是释放给定的指针。 到此已经有了一个对象的 unowned 引用，另外一个指令，strong_retain_unowned 用来创建一个强引用： 1234567891011SWIFT_RT_ENTRY_VISIBILITYvoid swift::swift_unownedRetainStrong(HeapObject *object) SWIFT_CC(RegisterPreservingCC_IMPL) &#123; if (!object) return; assert(object-&gt;weakRefCount.getCount() &amp;&amp; "object is not currently weakly retained"); if (! object-&gt;refCount.tryIncrement()) _swift_abortRetainUnowned(object);&#125; 因为弱引用应该指向了这个对象，要使用断言来验证对象是否被弱引用，一旦断言通过，将尝试进行增加强引用计数的操作。一旦对象在进程中已经被释放，尝试将会失败。 所有类似于 tryIncrement 通过某种形式修改引用计数的方法都放到 RefCount.h 中，需要使用原子操作进行这些任务。 接下来讨论下 weak 引用的的实现，正如之前看到的那样，swift_weakLoadStrong 用来获取容器中可选值中强引用的对象。 1234567891011121314151617181920212223242526272829303132HeapObject *swift::swift_weakLoadStrong(WeakReference *ref) &#123; if (ref-&gt;Value == (uintptr_t)nullptr) &#123; return nullptr; &#125; // ref 可能被其他线程访问 auto ptr = __atomic_fetch_or(&amp;ref-&gt;Value, WR_READING, __ATOMIC_RELAXED); while (ptr &amp; WR_READING) &#123; short c = 0; while (__atomic_load_n(&amp;ref-&gt;Value, __ATOMIC_RELAXED) &amp; WR_READING) &#123; if (++c == WR_SPINLIMIT) &#123; std::this_thread::yield(); c -= 1; &#125; &#125; ptr = __atomic_fetch_or(&amp;ref-&gt;Value, WR_READING, __ATOMIC_RELAXED); &#125; auto object = (HeapObject*)(ptr &amp; ~WR_NATIVE); if (object == nullptr) &#123; __atomic_store_n(&amp;ref-&gt;Value, (uintptr_t)nullptr, __ATOMIC_RELAXED); return nullptr; &#125; if (object-&gt;refCount.isDeallocating()) &#123; __atomic_store_n(&amp;ref-&gt;Value, (uintptr_t)nullptr, __ATOMIC_RELAXED); SWIFT_RT_ENTRY_CALL(swift_unownedRelease)(object); return nullptr; &#125; auto result = swift_tryRetain(object); __atomic_store_n(&amp;ref-&gt;Value, ptr, __ATOMIC_RELAXED); return result;&#125; 在这个实现中，获取一个强引用需要更多复杂同步操作，在多线程竞争严重的情况下，会带来性能损耗。 在这里第一次出现的 WeakReference 对象，是一个简单的结构体，包含一个整型值字段指向目标对象，目标对象是使用 HeapObject 类来承载的每一个运行时的 Swift 对象。 在 weak 引用询问当前线程设置的 WR_READING 标识之后，从 WeakReference 容器中获取 Swift 对象，如果对象不再有效，或者在等待获取资源时，它变成可以进行析构，当前的引用会被设置为 null。 如果对象依然有效，获取对象的尝试将会成功。 因此，从这个角度来讲，对 weak 引用的常规操作性能比 unowned 引用的更低（但是主要的问题还是在可选值操作上面）。 结论保守的使用 weak 引用是否明智呢？答案是否定的，无论是从性能的角度还是代码清晰的角度而言。 使用正确的捕获修饰符类型，明确的表明代码中的生命周期特性，当其他人或者你自己在读你的代码时不容易误解。 脚注1、苹果第一次讨论 weak/unowned 争议可以查看这里，之后在 twitter 上 Joe Groff 对此也进行了讨论，并且被 Michael Tsai 总结成文。这篇文章从意图角度出发，提供了完整并且可操作的解释。 2、从维基百科中可以找到关于 AST 的解释，还可以从 Slava Pestov 的这篇文章中看到关于 Swift 编译器中如何实现 AST 的一些细节。 3、关于 SIL 的更多信息，请查看详尽的官方 SIL 指南，还有 2015 LLVM 开发者会议的视频。Lex Chou 写的 SIL 快速指南可以点击这里查看。 4、查看在 Swift 中如何进行名称粉碎（name mangling）的细节，请查看 Lex Chou 的这篇文章。 5、Mike Ash 在他的 Friday Q&amp;A 中的一篇文章中讨论了如何实现 weak 引用的一种实践方法，这种方法与目前 Swift 的方法对比起来有一些过时，但是其中的解释依然值得参考。 本文由 SwiftGG 翻译组翻译，已经获得作者翻译授权，最新文章请访问 http://swift.gg。 文章转自 SwiftGG]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>Unowned与Weak</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[侧滑导航栏消失问题笔记]]></title>
    <url>%2Fpost%2Fpush-pop-navigation-bar-hidden%2F</url>
    <content type="text"><![CDATA[如果前页面和后页面不同，则会出现轻微侧滑时导航栏莫名其妙没了😂 Demo-PushAndPop Demo-PushAndPop[已解决] 隐藏导航栏+改变状态栏样式时出现导航栏莫名其妙没了 问题 当ViewController.swift实现123override var preferredStatusBarStyle: UIStatusBarStyle &#123; return .lightContent&#125; 时，两个ViewController对应的UIStatusBarStyle不同，则会出现如上图。UIStatusBarStyle一致则正常。 解决关键12345class NavigationController: UINavigationController &#123; override var childViewControllerForStatusBarStyle: UIViewController? &#123; return topViewController &#125;&#125; 只需要将childViewControllerForStatusBarStyle设置为UINavigationController.topViewController即可。 另外附上BViewController中相关代码。在切换的两个UIViewController的preferredStatusBarStyle一样时，不需要设置UINavigationController.childViewControllerForStatusBarStyle。12345678910111213141516171819202122232425262728class BViewController: UIViewController &#123; var navigationBarHidden = false override func viewWillAppear(_ animated: Bool) &#123; super.viewWillAppear(animated) guard let navigationController = navigationController else &#123; return &#125; if navigationController.isNavigationBarHidden != navigationBarHidden &#123; navigationController.setNavigationBarHidden(navigationBarHidden, animated: animated) &#125; &#125; override func viewWillDisappear(_ animated: Bool) &#123; super.viewWillDisappear(animated) guard let navigationController = navigationController else &#123; return &#125; guard let last = navigationController.viewControllers.last as? BViewController else &#123; return &#125; if last.navigationBarHidden != navigationBarHidden &#123; navigationController.setNavigationBarHidden(last.navigationBarHidden, animated: animated) &#125; &#125;&#125; 感谢 @木头 viewWillAppear更换为viewDidAppear然后调试，在Demo中测试也可以曲线救国。 @Harry 提供的终极大法～]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>DEBUG</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「转」iOS图片加载速度极限优化—FastImageCache解析]]></title>
    <url>%2Fpost%2Fbang-fastimagecache%2F</url>
    <content type="text"><![CDATA[原文：iOS图片加载速度极限优化—FastImageCache解析 FastImageCache是Path团队开发的一个开源库，用于提升图片的加载和渲染速度，让基于图片的列表滑动起来更顺畅，来看看它是怎么做的。 优化点iOS从磁盘加载一张图片，使用UIImageVIew显示在屏幕上，需要经过以下步骤： 从磁盘拷贝数据到内核缓冲区 从内核缓冲区复制数据到用户空间 生成UIImageView，把图像数据赋值给UIImageView 如果图像数据为未解码的PNG/JPG，解码为位图数据 CATransaction捕获到UIImageView layer树的变化 主线程Runloop提交CATransaction，开始进行图像渲染 6.1 如果数据没有字节对齐，Core Animation会再拷贝一份数据，进行字节对齐。 6.2 GPU处理位图数据，进行渲染。 FastImageCache分别优化了2,4,6.1三个步骤： 使用mmap内存映射，省去了上述第2步数据从内核空间拷贝到用户空间的操作。 缓存解码后的位图数据到磁盘，下次从磁盘读取时省去第4步解码的操作。 生成字节对齐的数据，防止上述第6.1步CoreAnimation在渲染时再拷贝一份数据。 接下来具体介绍这三个优化点以及它的实现。 内存映射平常我们读取磁盘上的一个文件，上层API调用到最后会使用系统方法read()读取数据，内核把磁盘数据读入内核缓冲区，用户再从内核缓冲区读取数据复制到用户内存空间，这里有一次内存拷贝的时间消耗，并且读取后整个文件数据就已经存在于用户内存中，占用了进程的内存空间。 FastImageCache采用了另一种读写文件的方法，就是用mmap把文件映射到用户空间里的虚拟内存，文件中的位置在虚拟内存中有了对应的地址，可以像操作内存一样操作这个文件，相当于已经把整个文件放入内存，但在真正使用到这些数据前却不会消耗物理内存，也不会有读写磁盘的操作，只有真正使用这些数据时，也就是图像准备渲染在屏幕上时，虚拟内存管理系统VMS才根据缺页加载的机制从磁盘加载对应的数据块到物理内存，再进行渲染。这样的文件读写文件方式少了数据从内核缓存到用户空间的拷贝，效率很高。 解码图像一般我们使用的图像是JPG/PNG，这些图像数据不是位图，而是是经过编码压缩后的数据，使用它渲染到屏幕之前需要进行解码转成位图数据，这个解码操作是比较耗时的，并且没有GPU硬解码，只能通过CPU，iOS默认会在主线程对图像进行解码。很多库都解决了图像解码的问题，不过由于解码后的图像太大，一般不会缓存到磁盘，SDWebImage的做法是把解码操作从主线程移到子线程，让耗时的解码操作不占用主线程的时间。 FastImageCache也是在子线程解码图像，不同的是它会缓存解码后的图像到磁盘。因为解码后的图像体积很大，FastImageCache对这些图像数据做了系列缓存管理，详见下文实现部分。另外缓存的图像体积大也是使用内存映射读取文件的原因，小文件使用内存映射无优势，内存拷贝的量少，拷贝后占用用户内存也不高，文件越大内存映射优势越大。 字节对齐Core Animation在图像数据非字节对齐的情况下渲染前会先拷贝一份图像数据，官方文档没有对这次拷贝行为作说明，模拟器和Instrument里有高亮显示“copied images”的功能，但似乎它有bug，即使某张图片没有被高亮显示出渲染时被copy，从调用堆栈上也还是能看到调用了CA::Render::copy_image方法： 那什么是字节对齐呢，按我的理解，为了性能，底层渲染图像时不是一个像素一个像素渲染，而是一块一块渲染，数据是一块块地取，就可能遇到这一块连续的内存数据里结尾的数据不是图像的内容，是内存里其他的数据，可能越界读取导致一些奇怪的东西混入，所以在渲染之前CoreAnimation要把数据拷贝一份进行处理，确保每一块都是图像数据，对于不足一块的数据置空。大致图示：(pixel是图像像素数据，data是内存里其他数据) 块的大小应该是跟CPU cache line有关，ARMv7是32byte，A9是64byte，在A9下CoreAnimation应该是按64byte作为一块数据去读取和渲染，让图像数据对齐64byte就可以避免CoreAnimation再拷贝一份数据进行修补。FastImageCache做的字节对齐就是这个事情。 实现FastImageCache把同个类型和尺寸的图像都放在一个文件里，根据文件偏移取单张图片，类似web的css雪碧图，这里称为ImageTable。这样做主要是为了方便统一管理图片缓存，控制缓存的大小，整个FastImageCache就是在管理一个个ImageTable的数据。整体实现的数据结构如图： 一些补充和说明： ImageTable 一个ImageFormat对应一个ImageTable，ImageFormat指定了ImageTable里图像渲染格式/大小等信息，ImageTable里的图像数据都由ImageFormat规定了统一的尺寸，每张图像大小都是一样的。 一个ImageTable一个实体文件，并有另一个文件保存这个ImageTable的meta信息。 图像使用entityUUID作为唯一标示符，由用户定义，通常是图像url的hash值。ImageTable Meta的indexMap记录了entityUUID-&gt;entryIndex的映射，通过indexMap就可以用图像的entityUUID找到缓存数据在ImageTable对应的位置。 ImageTableEntry ImageTable的实体数据是ImageTableEntry，每个entry有两部分数据，一部分是对齐后的图像数据，另一部分是meta信息，meta保存这张图像的UUID和原图UUID，用于校验图像数据的正确性。 Entry数据是按内存分页大小对齐的，数据大小是内存分页大小的整数倍，这样可以保证虚拟内存缺页加载时使用最少的内存页加载一张图像。 图像数据做了字节对齐处理，CoreAnimation使用时无需再处理拷贝。具体做法是CGBitmapContextCreate创建位图画布时bytesPerRow参数传64倍数。 Chunk ImageTable和实体数据Entry间多了层Chunk，Chunk是逻辑上的数据划分，N个Entry作为一个Chunk，内存映射mmap操作是以chunk为单位的，每一个chunk执行一次mmap把这个chunk的内容映射到虚拟内存。为什么要多一层chunk呢，按我的理解，这样做是为了灵活控制mmap的大小和调用次数，若对整个ImageTable执行mmap，载入虚拟内存的文件过大，若对每个Entry做mmap，调用次数会太多。 缓存管理 用户可以定义整个ImageTable里最大缓存的图像数量，在有新图像需要缓存时，如果缓存没有超过限制，会以chunk为单位扩展文件大小，顺序写下去。如果已超过最大缓存限制，会把最少使用的缓存替换掉，实现方法是每次使用图像都会把UUID插入到MRUEntries数组的开头，MRUEntries按最近使用顺序排列了图像UUID，数组里最后一个图像就是最少使用的。被替换掉的图片下次需要再使用时，再走一次取原图—解压—存储的流程。 使用FastImageCache适合用于tableView里缓存每个cell上同样规格的图像，优点是能极大加快第一次从磁盘加载这些图像的速度。但它有两个明显的缺点：一是占空间大。因为缓存了解码后的位图到磁盘，位图是很大的，宽高100100的图像在2x的高清屏设备下就需要200200*4byte/pixel=156KB，这也是为什么FastImageCache要大费周章限制缓存大小。二是接口不友好，需预定义好缓存的图像尺寸。FastImageCache无法像SDWebImage那样无缝接入UIImageView，使用它需要配置ImageTable，定义好尺寸，手动提供的原图，每种实体图像要定义一个FICEntity模型，使逻辑变复杂。 FastImageCache已经属于极限优化，做图像加载/渲染优化时应该优先考虑一些低代价高回报的优化点，例如CALayer代替UIImageVIew，减少GPU计算（去透明/像素对齐），图像子线程解码，避免Offscreen-Render等。在其他优化都做到位，图像的渲染还是有性能问题的前提下才考虑使用FastImageCache进一步提升首次加载的性能，不过字节对齐的优化倒是可以脱离FastImageCache直接运用在项目上，只需要在解码图像时bitmap画布的bytesPerRow设为64的倍数即可。]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>FastImageCache</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[debug-_SwiftValue-unsignedIntegerValue]]></title>
    <url>%2Fpost%2Fdebug-SwiftValue-unsignedIntegerValue%2F</url>
    <content type="text"><![CDATA[crash:123456let attr = try? NSMutableAttributedString(data: data, options: [NSDocumentTypeDocumentAttribute: NSHTMLTextDocumentType, NSCharacterEncodingDocumentAttribute: String.Encoding.utf8], documentAttributes:nil)// log:2017-04-17 14:04:38.140 [41275:463875] -[_SwiftValue unsignedIntegerValue]: unrecognized selector sent to instance 0x608000256620 WTF! 这个方法启动时不能直接调用，要异步？]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>DEBUG</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RxSwift语法笔记]]></title>
    <url>%2Fpost%2Frx-dictionary%2F</url>
    <content type="text"><![CDATA[记录RxSwift在使用过程中的一些常用语法。 说明按照RxSwift 入坑手册 Part0 - 基础概念格式进行补充。 SupportCode在进入正题之前，先看下项目里的 SupportCode.swift ，主要为 playground 提供了两个便利函数。 一个是 example 函数，专门用来写示例代码的，统一输出 log 便于标记浏览，同时还能保持变量不污染全局： 1234public func example(description: String, action: () -&gt; ()) &#123; print("\n--- \(description) example ---") action()&#125; 另一个是 delay 函数，通过 dispatch_after 用来演示延时的： 12345678public func delay(delay:Double, closure:()-&gt;()) &#123; dispatch_after( dispatch_time( DISPATCH_TIME_NOW, Int64(delay * Double(NSEC_PER_SEC)) ), dispatch_get_main_queue(), closure)&#125; Introduction主要介绍了 Rx 的基础： Observable 。 Observable&lt;Element&gt; 是观察者模式中被观察的对象，相当于一个事件序列 (GeneratorType) ，会向订阅者发送新产生的事件信息。事件信息分为三种： Next(value) 表示新的事件数据。 Completed 表示事件序列的完结。 Error 同样表示完结，但是代表异常导致的完结。（打个岔：协议命名，想起来上午汤哥在微博说的一段话： 另外，我觉得 protocol 名字用形容词会更加语义分明，比如 Swift : Flyable, Killable, Visible。全用名词的话显得比较生硬，比如 Swift : Head, Wings, Ass。 emptyempty 是一个空的序列，它只发送 .Completed 消息。 123456789example("empty") &#123; let emptySequence: Observable&lt;Int&gt; = empty() let subscription = emptySequence .subscribe &#123; event in print(event) &#125;&#125;--- empty example ---Completed nevernever 是没有任何元素、也不会发送任何事件的空序列。 123456789example("never") &#123; let neverSequence: Observable&lt;String&gt; = never() let subscription = neverSequence .subscribe &#123; _ in print("This block is never called.") &#125;&#125;--- never example --- justjust 是只包含一个元素的序列，它会先发送 .Next(value) ，然后发送 .Completed 。 1234567891011example("just") &#123; let singleElementSequence = just(32) let subscription = singleElementSequence .subscribe &#123; event in print(event) &#125;&#125;--- just example ---Next(32)CompletedsequenceOf sequenceOf 可以把一系列元素转换成事件序列。 1234567891011121314example("sequenceOf") &#123; let sequenceOfElements/* : Observable&lt;Int&gt; */ = sequenceOf(0, 1, 2, 3) let subscription = sequenceOfElements .subscribe &#123; event in print(event) &#125;&#125;--- sequenceOf example ---Next(0)Next(1)Next(2)Next(3)Completedfrom from 是通过 asObservable() 方法把 Swift 中的序列 (SequenceType) 转换成事件序列。 1234567891011121314example("from") &#123; let sequenceFromArray = [1, 2, 3, 4, 5].asObservable() let subscription = sequenceFromArray .subscribe &#123; event in print(event) &#125;&#125;--- from example ---Next(1)Next(2)Next(3)Next(4)Next(5)Completed createcreate 可以通过闭包创建序列，通过 .on(e: Event) 添加事件。 12345678910111213141516example("create") &#123; let myJust = &#123; (singleElement: Int) -&gt; Observable&lt;Int&gt; in return create &#123; observer in observer.on(.Next(singleElement)) observer.on(.Completed) return NopDisposable.instance &#125; &#125; let subscription = myJust(5) .subscribe &#123; event in print(event) &#125;&#125;--- create example ---Next(5)Completed failWithfailWith 创建一个没有元素的序列，只会发送失败 (.Error) 事件。 12345678910example("failWith") &#123; let error = NSError(domain: "Test", code: -1, userInfo: nil) let erroredSequence: Observable&lt;Int&gt; = failWith(error) let subscription = erroredSequence .subscribe &#123; event in print(event) &#125;&#125;--- failWith example ---Error(Error Domain=Test Code=-1 "The operation couldn’t be completed. (Test error -1.)") deferreddeferred 会等到有订阅者的时候再通过工厂方法创建 Observable 对象，每个订阅者订阅的对象都是内容相同而完全独立的序列。 123456789101112131415161718192021222324252627282930313233example("deferred") &#123; let deferredSequence: Observable&lt;Int&gt; = deferred &#123; print("creating") return create &#123; observer in print("emmiting") observer.on(.Next(0)) observer.on(.Next(1)) observer.on(.Next(2)) return NopDisposable.instance &#125; &#125; print("go") deferredSequence .subscribe &#123; event in print(event) &#125; deferredSequence .subscribe &#123; event in print(event) &#125;&#125;--- deferred example ---gocreatingemmitingNext(0)Next(1)Next(2)creatingemmitingNext(0)Next(1)Next(2) 为什么需要 defferd 这样一个奇怪的家伙呢？其实这相当于是一种延时加载，因为在添加监听的时候数据未必加载完毕，例如下面这个例子： 123456789101112example("TestDeferred") &#123; var value: String? = nil var subscription: Observable&lt;String?&gt; = just(value) // got value value = "Hello!" subscription.subscribe &#123; event in print(event) &#125;&#125;--- TestDeferred example ---Next(nil)Completed 如果使用 deffered 则可以正常显示想要的数据： 1234567891011121314example("TestDeferred") &#123; var value: String? = nil var subscription: Observable&lt;String?&gt; = deferred &#123; return just(value) &#125; // got value value = "Hello!" subscription.subscribe &#123; event in print(event) &#125;&#125;--- TestDeferred example ---Next(Optional("Hello!"))Completed Subjects接下来是关于 Subject 的内容。 Subject 可以看做是一种代理和桥梁。它既是订阅者又是订阅源，这意味着它既可以订阅其他 Observable 对象，同时又可以对它的订阅者们发送事件。 如果把 Observable 理解成不断输出事件的水管，那 Subject 就是套在上面的水龙头。它既怼着一根不断出水的水管，同时也向外面输送着新鲜水源。如果你直接用水杯接着水管的水，那可能导出来什么王水胶水完全把持不住；如果你在水龙头下面接着水，那你可以随心所欲的调成你想要的水速和水温。 （好吧上面一段文档里没有，是我瞎掰的，如果理解错了还望打脸(￣ε(#￣)☆╰╮(￣▽￣///)) 在开始下面的代码之前，先定义一个辅助函数用于输出数据： 123456func writeSequenceToConsole&lt;O: ObservableType&gt;(name: String, sequence: O) &#123; sequence .subscribe &#123; e in print("Subscription: \(name), event: \(e)") &#125;&#125; PublishSubjectPublishSubject 会发送订阅者从订阅之后的事件序列。 12345678910111213141516example("PublishSubject") &#123; let subject = PublishSubject&lt;String&gt;() writeSequenceToConsole("1", sequence: subject) subject.on(.Next("a")) subject.on(.Next("b")) writeSequenceToConsole("2", sequence: subject) subject.on(.Next("c")) subject.on(.Next("d"))&#125;--- PublishSubject example ---Subscription: 1, event: Next(a)Subscription: 1, event: Next(b)Subscription: 1, event: Next(c)Subscription: 2, event: Next(c)Subscription: 1, event: Next(d)Subscription: 2, event: Next(d) ReplaySubjectReplaySubject 在新的订阅对象订阅的时候会补发所有已经发送过的数据队列， bufferSize 是缓冲区的大小，决定了补发队列的最大值。如果 bufferSize 是1，那么新的订阅者出现的时候就会补发上一个事件，如果是2，则补两个，以此类推。 1234567891011121314151617example("ReplaySubject") &#123; let subject = ReplaySubject&lt;String&gt;.create(bufferSize: 1) writeSequenceToConsole("1", sequence: subject) subject.on(.Next("a")) subject.on(.Next("b")) writeSequenceToConsole("2", sequence: subject) subject.on(.Next("c")) subject.on(.Next("d"))&#125;--- ReplaySubject example ---Subscription: 1, event: Next(a)Subscription: 1, event: Next(b)Subscription: 2, event: Next(b) // 补了一个 bSubscription: 1, event: Next(c)Subscription: 2, event: Next(c)Subscription: 1, event: Next(d)Subscription: 2, event: Next(d) BehaviorSubjectBehaviorSubject 在新的订阅对象订阅的时候会发送最近发送的事件，如果没有则发送一个默认值。 123456789101112131415161718example("BehaviorSubject") &#123; let subject = BehaviorSubject(value: "z") writeSequenceToConsole("1", sequence: subject) subject.on(.Next("a")) subject.on(.Next("b")) writeSequenceToConsole("2", sequence: subject) subject.on(.Next("c")) subject.on(.Completed)&#125;--- BehaviorSubject example ---Subscription: 1, event: Next(z)Subscription: 1, event: Next(a)Subscription: 1, event: Next(b)Subscription: 2, event: Next(b)Subscription: 1, event: Next(c)Subscription: 2, event: Next(c)Subscription: 1, event: CompletedSubscription: 2, event: Completed VariableVariable 是基于 BehaviorSubject 的一层封装，它的优势是：不会被显式终结。即：不会收到 .Completed 和 .Error 这类的终结事件，它会主动在析构的时候发送 .Complete 。 1234567891011121314151617example("Variable") &#123; let variable = Variable("z") writeSequenceToConsole("1", sequence: variable) variable.value = "a" variable.value = "b" writeSequenceToConsole("2", sequence: variable) variable.value = "c"&#125;--- Variable example ---Subscription: 1, event: Next(z)Subscription: 1, event: Next(a)Subscription: 1, event: Next(b)Subscription: 2, event: Next(b)Subscription: 1, event: Next(c)Subscription: 2, event: Next(c)Subscription: 1, event: CompletedSubscription: 2, event: Completed Transform我们可以对序列做一些转换，类似于 Swift 中 CollectionType 的各种转换。在以前的坑中曾经提到过，可以参考：函数式的函数。 mapmap 就是对每个元素都用函数做一次转换，挨个映射一遍。 1234567891011example("map") &#123; let originalSequence = sequenceOf(1,2,3) originalSequence .map &#123; $0 * 2 &#125; .subscribe &#123; print($0) &#125;&#125;--- map example ---Next(2)Next(4)Next(6)Completed flatMapmap 在做转换的时候很容易出现『升维』的情况，即：转变之后，从一个序列变成了一个序列的序列。 什么是『升维』？在集合中我们可以举这样一个例子，我有一个好友列表 [p1, p2, p3]，那么如果要获取我好友的好友的列表，可以这样做： 1myFriends.map &#123; $0.getFriends() &#125; 结果就成了 [[p1-1, p1-2, p1-3], [p2-1], [p3-1, p3-2]] ，这就成了好友的好友列表的列表了。这就是一个『升维』的例子。 （以上内容文档中依旧没有，依旧是我瞎掰的，依旧欢迎有错误当面打脸(￣ε(#￣)☆╰╮(￣▽￣///)) 在 Swift 中，我们可以用 flatMap 过滤掉 map 之后的 nil 结果。在 Rx 中， flatMap 可以把一个序列转换成一组序列，然后再把这一组序列『拍扁』成一个序列。 12345678910111213141516171819202122example("flatMap") &#123; let sequenceInt = sequenceOf(1, 2, 3) let sequenceString = sequenceOf("A", "B", "--") sequenceInt .flatMap &#123; int in sequenceString &#125; .subscribe &#123; print($0) &#125;&#125;--- flatMap example ---Next(A)Next(B)Next(--)Next(A)Next(B)Next(--)Next(A)Next(B)Next(--)Completed scanscan 有点像 reduce ，它会把每次的运算结果累积起来，作为下一次运算的输入值。 123456789101112131415161718example("scan") &#123; let sequenceToSum = sequenceOf(0, 1, 2, 3, 4, 5) sequenceToSum .scan(0) &#123; acum, elem in acum + elem &#125; .subscribe &#123; print($0) &#125;&#125;--- scan example ---Next(0)Next(1)Next(3)Next(6)Next(10)Next(15)Completed Filtering除了上面的各种转换，我们还可以对序列进行过滤。 filterfilter 只会让符合条件的元素通过。 12345678910111213141516example("filter") &#123; let subscription = sequenceOf(0, 1, 2, 3, 4, 5, 6, 7, 8, 9) .filter &#123; $0 % 2 == 0 &#125; .subscribe &#123; print($0) &#125;&#125;--- filter example ---Next(0)Next(2)Next(4)Next(6)Next(8)Completed distinctUntilChangeddistinctUntilChanged 会废弃掉重复的事件。 1234567891011121314example("distinctUntilChanged") &#123; let subscription = sequenceOf(1, 2, 3, 1, 1, 4) .distinctUntilChanged() .subscribe &#123; print($0) &#125;&#125;--- distinctUntilChanged example ---Next(1)Next(2)Next(3)Next(1)Next(4)Completed taketake 只获取序列中的前 n 个事件，在满足数量之后会自动 .Completed 。 123456789101112example("take") &#123; let subscription = sequenceOf(1, 2, 3, 4, 5, 6) .take(3) .subscribe &#123; print($0) &#125;&#125;--- take example ---Next(1)Next(2)Next(3)Completed throttle VS. debouncethrottle 和 debounce 目的都是控制某个时间段内事件序列的速度。但是又有差别： debounce : 空闲控制 空闲时间必须 &gt;= 固定的时间，事件序列才会被放行 throttle : 频率控制 事件序列满足 1/delay 才会被放行 一般的按钮点击、用户输入、等都属于频率控制，应该使用 throttle 。 1234567891011let searchResults = searchBar.rx.text.orEmpty .throttle(0.3, scheduler: MainScheduler.instance) .distinctUntilChanged() .flatMapLatest &#123; query -&gt; Observable&lt;[Repository]&gt; in if query.isEmpty &#123; return .just([]) &#125; return searchGitHub(query) .catchErrorJustReturn([]) &#125; .observeOn(MainScheduler.instance) Combining这部分是关于序列的运算，可以将多个序列源进行组合拼装成一个新的事件序列。 startWithstartWith 会在队列开始之前插入一个事件元素。 12345678910111213example("startWith") &#123; let subscription = sequenceOf(4, 5, 6) .startWith(3) .subscribe &#123; print($0) &#125;&#125;--- startWith example ---Next(3)Next(4)Next(5)Next(6)Completed combineLatest如果存在两条事件队列，需要同时监听，那么每当有新的事件发生的时候，combineLatest 会将每个队列的最新的一个元素进行合并。 123456789101112131415161718example("combineLatest 1") &#123; let intOb1 = PublishSubject&lt;String&gt;() let intOb2 = PublishSubject&lt;Int&gt;() combineLatest(intOb1, intOb2) &#123; "\($0) \($1)" &#125; .subscribe &#123; print($0) &#125; intOb1.on(.Next("A")) intOb2.on(.Next(1)) intOb1.on(.Next("B")) intOb2.on(.Next(2))&#125;--- combineLatest 1 example ---Next(A 1)Next(B 1)Next(B 2) zipzip 人如其名，就是合并两条队列用的，不过它会等到两个队列的元素一一对应地凑齐了之后再合并，正如百折不撓的米斯特菜所提醒的， zip 就像是拉链一样，两根拉链拉着拉着合并到了一根上： 123456789101112131415161718example("zip 1") &#123; let intOb1 = PublishSubject&lt;String&gt;() let intOb2 = PublishSubject&lt;Int&gt;() zip(intOb1, intOb2) &#123; "\($0) \($1)" &#125; .subscribe &#123; print($0) &#125; intOb1.on(.Next("A")) intOb2.on(.Next(1)) intOb1.on(.Next("B")) intOb1.on(.Next("C")) intOb2.on(.Next(2))&#125;--- zip 1 example ---Next(A 1)Next(B 2) mergemerge 就是 merge 啦，把两个队列按照顺序组合在一起。 1234567891011121314151617181920example("merge 1") &#123; let subject1 = PublishSubject&lt;Int&gt;() let subject2 = PublishSubject&lt;Int&gt;() sequenceOf(subject1, subject2) .merge() .subscribeNext &#123; int in print(int) &#125; subject1.on(.Next(1)) subject1.on(.Next(2)) subject2.on(.Next(3)) subject1.on(.Next(4)) subject2.on(.Next(5))&#125;--- merge 1 example ---12345 switch当你的事件序列是一个事件序列的序列 (Observable&lt;Observable&lt;T&gt;&gt;) 的时候，（可以理解成二维序列？），可以使用 switch 将序列的序列平铺成一维，并且在出现新的序列的时候，自动切换到最新的那个序列上。和 merge 相似的是，它也是起到了将多个序列『拍平』成一条序列的作用。 12345678910111213141516171819202122232425262728293031example("switchLatest") &#123; let var1 = Variable(0) let var2 = Variable(200) // var3 is like an Observable&lt;Observable&lt;Int&gt;&gt; let var3 = Variable(var1) let d = var3 .switchLatest() .subscribe &#123; print($0) &#125; var1.value = 1 var1.value = 2 var1.value = 3 var1.value = 4 var3.value = var2 var2.value = 201 var1.value = 5 var3.value = var1 var2.value = 202 var1.value = 6&#125;--- switchLatest example ---Next(0)Next(1)Next(2)Next(3)Next(4)Next(200)Next(201)Next(5)Next(6) 注意，虽然都是『拍平』，但是和 flatmap 是不同的， flatmap 是将一条序列变成另一条序列，而这变换过程会让维度变高，所以需要『拍平』，而 switch 是将本来二维的序列（序列的序列）拍平成了一维的序列。 Error Handling在事件序列中，遇到异常也是很正常的事情，有以下几种处理异常的手段。 catchErrorcatchError 可以捕获异常事件，并且在后面无缝接上另一段事件序列，丝毫没有异常的痕迹。 1234567891011121314151617181920example("catchError 1") &#123; let sequenceThatFails = PublishSubject&lt;Int&gt;() let recoverySequence = sequenceOf(100, 200) sequenceThatFails .catchError &#123; error in return recoverySequence &#125; .subscribe &#123; print($0) &#125; sequenceThatFails.on(.Next(1)) sequenceThatFails.on(.Next(2)) sequenceThatFails.on(.Error(NSError(domain: "Test", code: 0, userInfo: nil)))&#125;--- catchError 1 example ---Next(1)Next(2)Next(100)Next(200)Completed retryretry 顾名思义，就是在出现异常的时候会再去从头订阅事件序列，妄图通过『从头再来』解决异常。 123456789101112131415161718192021222324252627example("retry") &#123; var count = 1 // bad practice, only for example purposes let funnyLookingSequence: Observable&lt;Int&gt; = create &#123; observer in let error = NSError(domain: "Test", code: 0, userInfo: nil) observer.on(.Next(0)) observer.on(.Next(1)) if count &lt; 2 &#123; observer.on(.Error(error)) count++ &#125; observer.on(.Next(2)) observer.on(.Completed) return NopDisposable.instance &#125; funnyLookingSequence .retry() .subscribe &#123; print($0) &#125;&#125;--- retry example ---Next(0)Next(1)Next(0)Next(1)Next(2)Completed Utility这里列举了针对事件序列的一些方法。 subscribesubscribe 在前面已经接触过了，有新的事件就会触发。 123456789101112example("subscribe") &#123; let sequenceOfInts = PublishSubject&lt;Int&gt;() sequenceOfInts .subscribe &#123; print($0) &#125; sequenceOfInts.on(.Next(1)) sequenceOfInts.on(.Completed)&#125;--- subscribe example ---Next(1)Completed subscribeNextsubscribeNext 也是订阅，但是只订阅 .Next 事件。 1234567891011example("subscribeNext") &#123; let sequenceOfInts = PublishSubject&lt;Int&gt;() sequenceOfInts .subscribeNext &#123; print($0) &#125; sequenceOfInts.on(.Next(1)) sequenceOfInts.on(.Completed)&#125;--- subscribeNext example ---1 subscribeCompletedsubscribeCompleted 是只订阅 .Completed 完成事件。 1234567891011example("subscribeCompleted") &#123; let sequenceOfInts = PublishSubject&lt;Int&gt;() sequenceOfInts .subscribeCompleted &#123; print("It's completed") &#125; sequenceOfInts.on(.Next(1)) sequenceOfInts.on(.Completed)&#125;--- subscribeCompleted example ---It's completed subscribeErrorsubscribeError 只订阅 .Error 失败事件。 1234567891011example("subscribeError") &#123; let sequenceOfInts = PublishSubject&lt;Int&gt;() sequenceOfInts .subscribeError &#123; error in print(error) &#125; sequenceOfInts.on(.Next(1)) sequenceOfInts.on(.Error(NSError(domain: "Examples", code: -1, userInfo: nil)))&#125;--- subscribeError example ---Error Domain=Examples Code=-1 "The operation couldn’t be completed. (Examples error -1.)" doOndoOn 可以监听事件，并且在事件发生之前调用。 1234567891011121314151617example("doOn") &#123; let sequenceOfInts = PublishSubject&lt;Int&gt;() sequenceOfInts .doOn &#123; print("Intercepted event \($0)") &#125; .subscribe &#123; print($0) &#125; sequenceOfInts.on(.Next(1)) sequenceOfInts.on(.Completed)&#125;--- doOn example ---Intercepted event Next(1)Next(1)Intercepted event CompletedCompleted Conditional我们可以对多个事件序列做一些复杂的逻辑判断。 takeUntiltakeUntil 其实就是 take ，它会在终于等到那个事件之后触发 .Completed 事件。 1234567891011121314151617example("takeUntil") &#123; let originalSequence = PublishSubject&lt;Int&gt;() let whenThisSendsNextWorldStops = PublishSubject&lt;Int&gt;() originalSequence .takeUntil(whenThisSendsNextWorldStops) .subscribe &#123; print($0) &#125; originalSequence.on(.Next(1)) originalSequence.on(.Next(2)) whenThisSendsNextWorldStops.on(.Next(1)) originalSequence.on(.Next(3))&#125;--- takeUntil example ---Next(1)Next(2)Completed takeWhiletakeWhile 则是可以通过状态语句判断是否继续 take 。 12345678910111213141516example("takeWhile") &#123; let sequence = PublishSubject&lt;Int&gt;() sequence .takeWhile &#123; int in int &lt; 2 &#125; .subscribe &#123; print($0) &#125; sequence.on(.Next(1)) sequence.on(.Next(2)) sequence.on(.Next(3))&#125;--- takeWhile example ---Next(1)Completed Aggregate我们可以对事件序列做一些集合运算。 concatconcat 可以把多个事件序列合并起来。 12345678910111213141516171819202122232425example("concat") &#123; let var1 = BehaviorSubject(value: 0) let var2 = BehaviorSubject(value: 200) // var3 is like an Observable&lt;Observable&lt;Int&gt;&gt; let var3 = BehaviorSubject(value: var1) let d = var3 .concat() .subscribe &#123; print($0) &#125; var1.on(.Next(1)) var1.on(.Next(2)) var3.on(.Next(var2)) var2.on(.Next(201)) var1.on(.Next(3)) var1.on(.Completed) var2.on(.Next(202))&#125;--- concat example ---Next(0)Next(1)Next(2)Next(3)Next(201)Next(202) reduce这里的 reduce 和 CollectionType 中的 reduce 是一个意思，都是指通过对一系列数据的运算最后生成一个结果。 12345678910example("reduce") &#123; sequenceOf(0, 1, 2, 3, 4, 5, 6, 7, 8, 9) .reduce(0, +) .subscribe &#123; print($0) &#125;&#125;--- reduce example ---Next(45)Completed Connectable坑待填，Xcode 里这个操场跑不起来了。]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>响应式编程</tag>
        <tag>RxSwift</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[sonarqube-note]]></title>
    <url>%2Fpost%2Fsonarqube-note%2F</url>
    <content type="text"><![CDATA[步骤Get Started in Two Minutes Download and unzip the SonarQube distribution (let’s say in “C:\sonarqube” or “/etc/sonarqube”) Start the SonarQube server: 12345# On Windows, execute:C:\sonarqube\bin\windows-x86-xx\StartSonar.bat # On other operating system, execute:/etc/sonarqube/bin/[OS]/sonar.sh console Download and unzip the SonarQube Scanner (let’s say in “C:\sonar-scanner” or “/etc/sonar-scanner”) Download and unzip some project samples (let’s say in “C:\sonar-scanning-examples” or “/etc/sonar-scanning-examples”) Analyze a project: 1234567# On Windows:cd C:\sonar-scanning-examples\sonarqube-scannerC:\sonar-scanner\bin\sonar-scanner.bat # On other operating system:cd /etc/sonar-scanning-examples/sonarqube-scanner/etc/sonar-scanner/bin/sonar-scanner Browse the results at http://localhost:9000 (default System administrator credentials are admin/admin) 文档 docs.sonarqube.org]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>构建</tag>
        <tag>Sonarqube</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「转」真实世界中的 Swift 性能优化]]></title>
    <url>%2Fpost%2Freal-world-swift-performance%2F</url>
    <content type="text"><![CDATA[原文链接：真实世界中的 Swift 性能优化 有太多的因素会导致您的应用变得缓慢。在本次讲演中，我们将自底向上地来探索应用的性能优化。来看一看在真实世界中进行数据解析、数据映射和数据存储的时候，Swift 的特性（协议、泛型、结构体和类）是如何影响应用性能的，我们将确定影响性能提升的瓶颈所在，并体验 Swift 带来的「迅捷」体验。 概述今天我打算同大家谈论 Swift 性能优化方面的内容。当我们构建软件的时候，特别是移动软件，由于人们的精力、时间有限，人们往往更喜欢有一个流畅的用户体验，而不是等着您的应用在那加载。如果应用运行速度过慢，并且不能给用户带来他们所想要的结果的话，那么这会让人们感到不爽。因此，让您的代码能够快速运行是无比重要的一件事。 那么有什么因素会导致代码运行缓慢呢？当您在编写代码并选择架构的时候，深刻认识到这些架构所带来的影响是非常重要的。我将首先谈一谈：如何理解内联、动态调度与静态调度之间的权衡，以及相关结构是如何分配内存的，还有怎样选择最适合的架构。 内存分配对象的内存分配 (allocation) 和内存释放 (deallocation) 是代码中最大的开销之一，同时通常也是不可避免的。Swift 会自行分配和释放内存，此外它存在两种类型的分配方式。 第一个是基于栈 (stack-based) 的内存分配。Swift 会尽可能选择在栈上分配内存。栈是一种非常简单的数据结构；数据从栈的底部推入 (push)，从栈的顶部弹出 (pop)。由于我们只能够修改栈的末端，因此我们可以通过维护一个指向栈末端的指针来实现这种数据结构，并且在其中进行内存的分配和释放只需要重新分配该整数即可。 第二个是基于堆 (heap-based) 的内存分配。这使得内存分配将具备更加动态的生命周期，但是这需要更为复杂的数据结构。要在堆上进行内存分配的话，您需要锁定堆当中的一个空闲块 (free block)，其大小能够容纳您的对象。因此，我们需要找到未使用的块，然后在其中分配内存。当我们需要释放内存的时候，我们就必须搜索何处能够重新插入该内存块。这个操作很缓慢。主要是为了线程安全，我们必须要对这些东西进行锁定和同步。 引用计数我们还有引用计数 (reference counting) 的概念，这个操作相对不怎么耗费性能，但是由于使用次数很多，因此它带来的性能影响仍然是很大的。引用计数是 Objective-C 和 Swift 中用于确定何时该释放对象的安全机制。目前，Swift 当中的引用计数是强制自动管理的，这意味着它很容易被开发者们所忽略。然而，当您打开 Instrument 查看何处影响了代码运行的速度的时候，您会发现 20,000 多次的 Swift 持有 (retain) 和释放 (release)，这些操作占用了 90% 的代码运行时间！123func perform(with object: Object) &#123; object.doAThing()&#125; 这是因为如果有这样一个函数接收了一个对象作为参数，并且执行了这个对象的 doAThing() 方法，编译器会自动插入对象持有和释放操作，以确保在这个方法的生命周期当中，这个对象不会被回收掉。12345func perform(with object: Object) &#123; __swift_retain(object) object.doAThing() __swift_release(object)&#125; 这些对象持有和释放操作是原子操作 (atomic operations)，所以它们运转缓慢就很正常了。或者，是因为我们不知道如何让它们能够运行得更快一些。 调度与对象此外还有调度 (dispatch) 的概念。Swift 拥有三种类型的调度方式。Swift 会尽可能将函数内联 (inline)，这样的话使用这个函数将不会有额外的性能开销。这个函数可以直接调用。静态调度 (static dispatch) 本质上是通过 V-table 进行的查找和跳转，这个操作会花费一纳秒的时间。然后动态调度 (dynamic dispatch) 将会花费大概五纳秒的时间，如果您只有几个这样的方法调用的话，这实际上并不会带来多大的问题，问题是当您在一个嵌套循环或者执行上千次操作当中使用了动态调度的话，那么它所带来的性能耗费将成百上千地累积起来，最终影响应用性能。 Swift 同样也有两种类型的对象。1234567class Index &#123; let section: Int let item: Int&#125;let i = Index(section: 1, item: 1) 这是一个类，类当中的数据都会在堆上分配内存。您可以在此处看到，这里我们创建了一个名为 Index 的类。其中包含了两个属性，一个 section 和一个 item。当我们创建了这个对象的时候，堆上便创建了一个指向此 Index 的指针，因此在堆上便存放了这个 section 和 item 的数据和空间。 如果我们对其建立引用，就会发现我们现在有两个指向堆上相同区域的指针了，它们之间是共享内存的。123456789class Index &#123; let section: Int let item: Int&#125;let i = Index(section: 1, item: 1)let i2 = i 这个时候，Swift 会自动插入对象持有操作。12345678910class Index &#123; let section: Int let item: Int&#125;let i = Index(section: 1, item: 1)__swift_retain(i)let i2 = i 结构体很多人都会说：要编写性能优异的 Swift 代码，最简单的方式就是使用结构体了，结构体通常是一个很好的结构，因为结构体会存储在栈上，并且通常会使用静态调度或者内联调度。 存储在栈上的 Swift 结构体将占用三个 Word 大小。如果您的结构体当中的数据数量低于三种的话，那么结构体的值会自动在栈上内联。Word 是 CPU 当中内置整数的大小，它是 CPU 所工作的区块。123456struct Index &#123; let section: Int let item: Int&#125;let i = Index(section: 1, item: 1) 在这里您可以看到，当我们创建这个结构体的时候，带有 section 和 item 值得 Index 结构体将会直接下放到栈当中，这个时候不会有额外的内存分配发生。那么如果我们在别处将其赋值到另一个变量的时候，会发生什么呢？1234567struct Index &#123; let section: Int let item: Int&#125;let i = Index(section: 1, item: 1)let i2 = i 如果我们将 i 赋给 i2，这会将我们存储在栈当中的值直接再次复制一遍，这个时候并不会出现引用的情况。这就是所谓的「值类型」。 那么如果结构体当中存放了引用类型的话又会怎样呢？持有内联指针的结构体。123456struct User &#123; let name: String let id: String&#125;let u = User(name: "Joe", id: "1234") 当我们将其赋值给别的变量的时候，我们就持有了共享两个结构体的相同指针，因此我们必须要对这两个指针进行持有操作，而不是在对象上执行单独的持有操作。12345678910struct User &#123; let name: String let id: String&#125;let u = User(name: "Joe", id: "1234")__swift_retain(u.name._textStorage)__swift_retain(u.id._textStorage)let u2 = u 如果其中包含了类的话，那么性能耗费会更大。 抽象类型正如我们此前所述，Swift 提供了许多不同的抽象类型 (abstraction)，从而允许我们自行决定代码该如何运行，以及决定代码的性能特性。现在我们来看一看抽象类型是如何在实际环境当中使用的。这里有一段很简单的代码：1234567891011struct Circle &#123; let radius: Double let center: Point func draw() &#123;&#125;&#125;var circles = (1..&lt;100_000_000).map &#123; _ in Circle(...) &#125;for circle in circles &#123; circle.draw()&#125; 这里有一个带有 radius 和 center 属性的 Circle 结构体。它将占用三个 Word 大小的空间，并存储在栈上。我们创建了一亿个 Circle，然后我们遍历这些 Circle 并调用这个函数。在我的电脑上，这段操作在发布模式下耗费了 0.3 秒的时间。那么当需求发生变更的时候，会发生什么事呢？ 我们不仅需要绘圆，还需要能够处理多种类型的形状。让我们假设我们还需要绘线。我非常喜欢面向协议编程，因为它允许我在不使用继承的情况下实现多态性，并且它允许我们只需要考虑这个「抽象类型」即可。123456789101112131415protocol Drawable &#123; func draw()&#125;struct Circle: Drawable &#123; let radius: Double let center: Point func draw() &#123;&#125;&#125;let drawables: [Drawable] = (1..&lt;100_000_000).map &#123; _ in Circle(...) &#125;for drawable in drawables &#123; drawable.draw()&#125; 我们需要做的，就是将这个 draw 方法析取到协议当中，然后将数组的引用类型变更为这个协议，这样做导致这段代码花费了 4.0 秒的时间来运行。速率减慢了 1300%，这是为什么呢？ 这是因为此前的代码可以被静态调度，从而在没有任何堆应用建立的情况下仍能够执行。这就是协议是如何实现的。 例如，如大家所见，这里是我们此前的 Circle 结构体。在这个 for 循环当中，Swift 编译器所做的就是前往 V-table 进行查找，或者直接将 draw 函数内联。 1234567891011struct Circle &#123; let radius: Double let center: Point func draw() &#123;&#125;&#125;var circles = (1..&lt;100_000_000).map &#123; _ in Circle(...) &#125;for circle in circles &#123; circle.draw()&#125; 当我们用协议来替代的时候，此时它并不知道这个对象是结构体还是类。因为这里可能是任何一个实现此协议的类型。 12345678910111213141516protocol Drawable &#123; func draw()&#125;struct Circle: Drawable &#123; let radius: Double let center: Point func draw() &#123;&#125;&#125;var drawables: [Drawable] = (1..&lt;100_000_000).map &#123; _ in return Circle(...) &#125;for drawable in drawables &#123; drawable.draw()&#125; 那么我们该如何去调度这个 draw 函数呢？答案就位于协议记录表 (protocol witness table，也称为虚函数表) 当中。它其中存放了您应用当中每个实现协议的对象名，并且在底层实现当中，这个表本质上充当了这些类型的别名。 123456789101112131415161718protocol Drawable &#123; func draw()&#125;struct Circle: Drawable &#123; let radius: Double let center: Point func draw() &#123;&#125;&#125;var drawables: [Drawable] = (1..&lt;100_000_000).map &#123; _ in return Circle(...)&#125;for drawable in drawables &#123; drawable.draw()&#125; 在这里的代码当中，我们该如何获取协议记录表呢？答案就是从这个既有容器 (existential container) 当中获取，这个容器目前拥有一个三个字大小的结构体，并且存放在其内部的值缓冲区当中，此外还与协议记录表建立了引用关系。 123456struct Circle: Drawable &#123; let radius: Double let center: Point func draw() &#123;&#125;&#125; 这里 Circle 类型存放在了三个字大小的缓冲区当中，并且不会被单独引用。 123456struct Line: Drawable &#123; let origin: Point let end: Point func draw() &#123;&#125;&#125; 举个例子，对于我们的 Line 类型来说，它其中包含了四个字的存储空间，因为它拥有两个点类型。这个 Line 结构体需要超过四个字以上的存储空间。我们该如何处理它呢？这会对性能有影响么？好吧，它的确会： 123456789101112131415protocol Drawable &#123; func draw()&#125;struct Line: Drawable &#123; let origin: Point let end: Point func draw() &#123;&#125;&#125;let drawables: [Drawable] = (1..&lt;100_000_000).map &#123; _ in Line(...) &#125;for drawable in drawables &#123; drawable.draw()&#125; 这需要花费 45 秒钟的时间来运行。为什么这里要花这么久的时间呢，发生了什么事呢？ 绝大部分的时间都花费在对结构体进行内存分配上了，因为现在它们无法存放在只有三个字大小的缓冲区当中了。因此这些结构会在堆上进行内存分配，此外这也与协议有一点关系。由于既有容器只能够存储三个字大小的结构体，或者也可以与对象建立引用关系，我们同样需要某种名为值记录表 (value witness table)。这就是我们用来处理任意值的东西。 因此在这里，编译器将创建一个值记录表，对每个���缓冲区、内敛结构体来说，都有三个字大小的缓冲区，然后它将负责对值或者类进行内存分配、拷贝、销毁和内存释放等操作。 1234567891011121314151617func draw(drawable: Drawable) &#123; drawable.draw()&#125;let value: Drawable = Line()draw(local: value)// Generatesfunc draw(value: ECTDrawable) &#123; var drawable: ECTDrawable = ECTDrawable() let vwt = value.vwt let pwt = value.pwt drawable.vwt = value.vwt drawable.pwt = value.pwt vwt.allocateBuffAndCopyValue(&amp;drawable, value) pwt.draw(vwt.projectBuffer(&amp;drawable)&#125; 这里是一个例子，这就是这个过程的中间产物。如果我们只有一个 draw 函数，那么它将会接受我们创建的 Line 作为参数，因此我们将它传递给这个 draw 函数即可。 实际情况时，它将这个 Drawable 协议传递到既有容器当中，然后在函数内部再次进行创建。这会对值和协议记录表进行赋值，然后分配一个新的缓冲区，然后将其他结构、类或者类似对象的值拷贝进这个缓冲区当中。然后就使用协议记录表当中的 draw 函数，把真实的 Drable 对象传递给这个函数。 您可以看到，值记录表和协议记录表将会存放在栈上，而 Line 将会被存放在堆上，从而最后将线绘制出来。 结论对我们进行数据建模的方式进行简单的更改将会对性能造成巨大的影响。让我们来看一看该如何来避免这些情况的发生。 首先让我们来说一说泛型。大家可能会说了，我给各位展示了协议会导致性能的下降，那么我们为什么还要使用泛型呢？答案在于：泛型允许我们做什么。 123struct Stack&lt;T: Type&gt; &#123;...&#125; 假设我们这里有一个带有泛型 T 的 Stack 结构体，它受到一个协议类型的约束。编译器所要做的，就是将这个 T 提换成相应的协议，或者替换为我们传入的具体类型。这些操作会一直沿着函数链 (function chain) 执行，并且编译器会创建直接对此类型进行操作的专用版本。 这样我们就无需再使用值记录表或者协议记录表了，并且还移除了既有容器，这可能是一个非常好的解决方式，这使得我们仍然能够写出真正快速运行的泛型代码，并且还具备 Swift 所提供的良好多态性。这就是所谓的静态多态性 (static polymorphism)。 您还可以通过使用枚举来改进数据模型，而不是从服务器中获取大量的字符串。例如，假设您正在构建一个社交应用，您需要对账户建立状态的管理，以前您可能会使用字符串来进行控制。 123enum AccountStatus: String, RawRepresentable &#123;case .banned, .verified, incomplete&#125; 如果我们改用枚举的话，那么我们就无需进行内存分配了，当我们传递这个类型的时候，我们只是将枚举值进行传递，这是一个加快代码运行速度的好方法，同时也可以为整个应用程序提供更安全、更可读的代码。 此外，使用 u-模型或者演示者 (Presenter) 或者不同的抽象类型的形式，来构建特定类型的模型也是非常有用的，这使得我们能够精简掉应用当中许多不必要的部分。 好的，我的讲演到此结束，内容很短，感谢诸位的参与！]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Swift 编译时性能优化笔记]]></title>
    <url>%2Fpost%2Fswift-build-times%2F</url>
    <content type="text"><![CDATA[Xcode在编译Swift代码的时候速度会越来越慢，就此查找原因，并列出自己的优化思路。 Xcode8.2添加User-Defind新的SWIFT_WHOLE_MODULE_OPTIMIZATION = YES可以过滤为修改framework。 针对运算符??的优化在使用??时，并不是所有的都需要优化，包裹在循环中的??会比较耗时比较厉害，目前不知道为啥，估计编译的时候需要检查的此时比较多吧😂。 尝试显式解包思路：??编译慢，就不用??，直接使用if else实施: 由于工程中使用的??比较多，所以比较修改起来比较麻烦。但是可以解决问题。真不行写方法转化调用喽。。 错误的尝试了重载运算符??方式思路: ??运算符编译耗时较多，直觉是??实现有复杂的操作,重新按照显式解包的方案进行实现。实施: 分析??的使用场景，左侧为T?,右侧为T，返回值T 重载函数名定义public func ?? &lt;T&gt;(left: T?, right: T) -&gt; T 实现 编译 error：Ambiguous use of operator &#39;??&#39; 思考：这丫的在重载运算符的时候不能使用泛型吧。。 更改函数为public func ?? &lt;Any&gt;(left: Any?, right: Any) -&gt; Any PL. OK了，可是问题来了，系统的??是可以返回对应的类型，可是这样重载之后返回一个Any，代码中如果出现let str = str1 ?? &quot;&quot;则str类型就变为Any而不是String。巨坑 顾不了那么多了，真不行一个一个跑。于是先修改一个较为严重的String类型。 尝试编译，结果时间惊人的没有变化。。依旧居高不下 以失败告终。。 总结: 这个??耗时较多并不是因为??的实现有问题，猜测是在为??准备左右参数的时候需要进行一层层的解包确定类型，再加上??可能有重载版本，进行类型匹配的时候比较耗时。 尝试扩展方法进行优化思路: 既然运算符会导致编译慢，那么就尝试使用方法直接进行转换。实现: 代码如下：123456789struct Operator &#123; /// ==&gt; ?? static func `try`&lt;T&gt;(_ origin: T?, _ then: T) -&gt; T &#123; guard let value = origin else &#123; return then &#125; return value &#125;&#125; 测试发现上述方法可以优化时间。 以下原文出自：关于 Swift 编译时性能优化的一些思考 原文链接 : Regarding Swift build time optimizations 原文作者 : Robert Gummesson 译文出自 : 掘金翻译计划 译者 : 杨龙龙 校对者: 申冠华, Jack King 关于 Swift 编译时性能优化的一些思考上周，我读了 @nickoneill 一篇优秀的帖子 Speeding Up Slow Swift Build Times 之后，我发现用一个略不同以往的角度去读Swift代码，并不是很难。 一行之前很简洁的代码，现在却出现了新的问题——它是否应该重构为9行代码来达到更快的编译速度？ (nil coalescing 运算符就是一个例子)孰轻孰重？简洁的代码还是对编译器友好的代码？ 我觉得，它取决于项目的大小和开发者的想法。 但请等等… 这里有一个Xcode插件在讲一些例子之前，我首先想到了通过手工提取日志信息是非常耗时的事情。通过命令行工具实现会相对容易一些，但是我把它往前推进了一步：集成为Xcode插件。 在这个例子中，最初的目的仅仅是识别并修复代码中最耗时的地方，但是现在我觉得它成为了一个必须要迭代的过程。这样我才可以更加高效地构建代码，并且防止在项目中出现耗时的函数。 不少惊喜我经常在不同的 Git 分支中跳转，并且等待一个暖慢的项目编译简直是在浪费我的生命。因此我思考了很长时间，一个玩具项目（大约两万行 Swift 代码）会编译如此长的时间。 当我知道是什么原因导致它如此慢之后，我不得不承认我震惊了，一行代码居然需要几秒的编译时间。 让我们来看几个例子。 Nil 合并运算符编译器肯定不喜欢这里的第一种方法。在展开下面两处简写的代码之后，构建时间减少了 99.4%。 // 构建时间： 5238.3ms return CGSize(width: size.width + (rightView?.bounds.width ?? 0) + (leftView?.bounds.width ?? 0) + 22, height: bounds.height) // 构建时间： 32.4ms var padding: CGFloat = 22 if let rightView = rightView { padding += rightView.bounds.width } if let leftView = leftView { padding += leftView.bounds.width } return CGSizeMake(size.width + padding, bounds.height) ArrayOfStuff + [Stuff]这个看起来像下面这样： return ArrayOfStuff + [Stuff] // 而不是 ArrayOfStuff.append(stuff) return ArrayOfStuff 我经常这么做，并且它影响了每次构建的时间。下面是最糟糕的一个例子，改写后构建时间可以减少 97.9%。 // 构建时间： 1250.3ms let systemOptions = [ 7, 14, 30, -1 ] let systemNames = (0...2).map{ String(format: localizedFormat, systemOptions[$0]) } + [NSLocalizedString(&quot;everything&quot;, comment: &quot;&quot;)] // Some code in-between labelNames = Array(systemNames[0..&lt;count]) + [systemNames.last!] // 构建时间： 25.5ms let systemOptions = [ 7, 14, 30, -1 ] var systemNames = systemOptions.dropLast().map{ String(format: localizedFormat, $0) } systemNames.append(NSLocalizedString(&quot;everything&quot;, comment: &quot;&quot;)) // Some code in-between labelNames = Array(systemNames[0..&lt;count]) labelNames.append(systemNames.last!) 三元运算符仅仅是通过替换三元运算符为 if else 语句就能减少 92.9% 的构建时间。如果使用一个for循环替换 map 函数，它又能减少另一个 75%（但是我的眼睛可就受不了咯😉）。 // 构建时间： 239.0ms let labelNames = type == 0 ? (1...5).map{type0ToString($0)} : (0...2).map{type1ToString($0)} // 构建时间： 16.9ms var labelNames: [String] if type == 0 { labelNames = (1...5).map{type0ToString($0)} } else { labelNames = (0...2).map{type1ToString($0)} } 转换 CGFloat 到 CGFloat这里我所说的并不一定正确。变量已经使用了 CGFloat 并且有一些括号也是多余的。在清理了这些冗余之后，构建时间能减少 99.9%。 // 构建时间： 3431.7 ms return CGFloat(M_PI) * (CGFloat((hour + hourDelta + CGFloat(minute + minuteDelta) / 60) * 5) - 15) * unit / 180 // 构建时间： 3.0ms return CGFloat(M_PI) * ((hour + hourDelta + (minute + minuteDelta) / 60) * 5 - 15) * unit / 180 Round()这个一个非常奇怪的例子，下面的例子中变量是一个局部变量与实例变量的混合。这个问题可能不是四舍五入本身，而是结合代码的方法。去掉四舍五入的方法大概能减少 97.6% 的构建时间。 // 构建时间： 1433.7ms let expansion = a — b — c + round(d * 0.66) + e // 构建时间： 34.7ms let expansion = a — b — c + d * 0.66 + e 注意：所有的测试都在 MacBook Air (13-inch, Mid 2013)中进行。 尝试它无论你是否面临过构建时间太长的问题，编写对编译器友好的代码都是非常有用的。我确定你自己会在其中找到一些惊喜。作为参考，这里有完整的代码，在我的工程中可以5秒内完成编译… import UIKit class CMExpandingTextField: UITextField { func textFieldEditingChanged() { invalidateIntrinsicContentSize() } override func intrinsicContentSize() -&gt; CGSize { if isFirstResponder(), let text = text { let size = text.sizeWithAttributes(typingAttributes) return CGSize(width: size.width + (rightView?.bounds.width ?? 0) + (leftView?.bounds.width ?? 0) + 22, height: bounds.height) } return super.intrinsicContentSize() } }]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Fastlane自动化笔记]]></title>
    <url>%2Fpost%2Ffastlane-note%2F</url>
    <content type="text"><![CDATA[之前在搭建Jenkins的时候，由于看到Fastlane的配置好复杂，那么多，而当时的需求就是自动打包。。所以没有用，现在想来好气！今天翻到InfoQ的一个文章，又详细的了解了Fastlane之后，觉得此大法甚好，解决很多痛点！决定搞通这一切！回看之前的build-ipa-sh.md确实比较僵硬。自动化还是很棒的。 基本知识 (@icyleaf)在Fastlane - iOS 和 Android 的自动化构建工具中说到： Fastlane 提供的流程的众多工具都是可以独立存在和使用（提供 cli 命令），也可以统一由 fastlane 来控制。它在使用中提出了两个概念： - action: Fastlane 的插件，截至当前内置 165 个至多，不过每个动作的颗粒度大小不一。查看详情 - lane: Fastlane 的任务（或者可以理解为命令），一个可以包含多个 lanes，通过 fastlane cli 传入制定的 lane 来执行。 自我感觉这句话这个对理解和使用很重要！ 配置 Fastlane已被Fabric收购，所以按照其安装也很随意(戳我配置)。 对于打包， 文章 深入浅出 Fastlane 一看你就懂 fir.im weekly - 「 持续集成 」实践教程合集 使用fastlane实现iOS持续集成 fastlane docs fastlane GitHub Fastlane实战（一）：移动开发自动化之道 Fastlane实战（二）：Action和Plugin机制 Fastlane实战（三）：Fastlane在Android平台的应用 Fastlane实战（四）：自动化测试篇 Fastlane实战（五）：高级用法]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>构建</tag>
        <tag>Fastlane</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[优雅的使用SwiftLint]]></title>
    <url>%2Fpost%2Felegant-to-use-swiftlint%2F</url>
    <content type="text"><![CDATA[接入了SwiftLine，修改2000+的warning、300+error的一点笔记心得。 SwiftLint SwiftLintA tool to enforce Swift style and conventions, loosely based on GitHub’s Swift Style Guide. SwiftLint hooks into Clang and SourceKit to use the AST representation of your source files for more accurate results. SwiftLint 是一个用于强制检查 Swift 代码风格和规定的一个工具，基本上以 GitHub’s Swift 代码风格指南为基础。 SwiftLint Hook 了 Clang 和 SourceKit 从而能够使用 AST 来表示源代码文件的更多精确结果。 对原有代码格式化自动格式化 1swiftlint autocorrect TrailingWhitespaceRule现象 xxx.swift:34: warning: Trailing Whitespace Violation: Lines should not have trailing whitespace. (trailing_whitespace) 规则实现：TrailingWhitespaceRule.swift 原因 Xcode中的”空白行”。其实并不空白，含有空的字符。最明显的表现为git提交的时候会有明显的黄色警告。 解决办法 Xcode中有选项可以直接控制，具体路径为 12345Xcode -&gt; Preferences-&gt; Text Editing-&gt; While editing-&gt; [V] Including whitespace-only lines ColonRule现象 xxx.swift:13:71: warning: Colon Violation: Colons should be next to the identifier when specifying a type. (colon) 原因 变量方法的 : 的右边应该有一个空格才能识别出来，且左侧不能留空格。所以写代码的时候随手写上还是比较好的。。 栗子： 12345678// OK:var responseData: [String : Any]? = nil // 返回结果，请求之前为nil// warning: 第一个&apos;:&apos;处左侧有空格var responseData : [String : Any]? = nil // 返回结果，请求之前为nil// warning: 第一个&apos;:&apos;处右侧无空格var responseData:[String : Any]? = nil // 返回结果，请求之前为nil 解决办法 规范书写 LineLengthRule现象 xxx.swift:90: warning: Line Length Violation: Line should be 100 characters or less: currently 101 characters (line_length) 原因 行数超了呗。。 解决办法 方法名字写的简单易懂 ControlStatementRule现象 xxx.swift:169:21: warning: Control Statement Violation: if,for,while,do statements shouldn’t wrap their conditionals in parentheses. (control_statement) 规则实现ControlStatementRule 原因 swift中if,for,while,do 语句不应该用() UnusedClosureParameterRule现象 xxx.swift:103:62: warning: Unused Closure Parameter Violation: Unused parameter “response” in a closure should be replaced with _. (unused_closure_parameter) 规则实现UnusedClosureParameterRule 原因 response 没有使用，建议替换为 _。 CyclomaticComplexityRule现象 xxx.swift:69:5: warning: Cyclomatic Complexity Violation: Function should have complexity 10 or less: currently complexity equals 14 (cyclomatic_complexity) 规则实现CyclomaticComplexityRule 原因 😂，他说你这函数写的太复杂了。看实现是说不能有过多的if {} OpeningBraceRule现象 xxx.swift:221:34: warning: Opening Brace Spacing Violation: Opening braces should be preceded by a single space and on the same line as the declaration. (opening_brace) 规则实现OpeningBraceRule 解决 {}的前面要有空格隔开]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>构建</tag>
        <tag>SwiftLint</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[科学上网之搬瓦工ss搭建笔记]]></title>
    <url>%2Fpost%2Fbandwagonhost-note%2F</url>
    <content type="text"><![CDATA[原来吧，用用goagent、Lantern、XX-Net，确实，这玩意只能Google出来结果，但是有的站点打不开才是最骚的。。同事搞了个搬瓦工挺便宜，于是乎就也搞了一个。不过强迫症犯了，尝试了各种SS版本以及各种优化，目的是找个流畅点的版本进行科学上网。 写在前面 红线越不得！红线越不得！红线越不得！重要的事情说3遍。 参看第一条 参看第一条 参看第一条 2017 07 18 say goog bay !]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>ss</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[正则表达式学习笔记]]></title>
    <url>%2Fpost%2Fbruch-up-regular-expressions%2F</url>
    <content type="text"><![CDATA[正则表达式基础学习笔记。 前面 上次找了个很好的文章，可是手残没保存。。找不到了😭，现在重新找了一个文章：正则表达式30分钟入门教程 正如作者说的： 声明本文非原创，是改编自《正则表达式30分钟入门教程》，因为原作者的排版个人不是很喜欢，而且内容上个人觉得有些地方需要改进，所以在 gitbook 上开了一本书。 OSC的在线正则表达式测试 开搞元字符 \ : 转义 \b : 单词开始或结束 ^ : 字符串开始 $ : 字符串结束 \d : 一个数字 \s : 任意空白字符：空格、制表符、换行符、中文全角空格、等 \w : 字母/数字/下划线/汉字 可见字符 . : 除换行符以外的任意字符 重复 {n} : 前置位重复匹配 [n] 次 {n,m} : 前置位重复匹配 [n-m] 次 {n,} : 前置位重复匹配 [n-∞] 次 * : 数量区间：[0-N] + : 数量区间：[1-N] ? : 数量区间：[0-1] 字符类 [nml] : 可以匹配到 n/m/l 条件 | : 或语句。存在逻辑短路 (m) : 分组语句。子式，可以指定重复什么的 反义 \W : 任意不是（字符、数字、下划线、汉字） \S : 任意不是 空白符 \D : 任意不是 数字 \B : 任意不是 单词开头或结尾 \^x : 除x以外的任意字符 [\^abc] : 除abc这几个字母以外的任意字符 后向引用 (\w+)这样用()的部分称为一个分组，其匹配到的内容可以使用\n来表示，n代表该分组为第n个分组。分组下标从1开始。 也可以自定义子表达式组名: (?&lt;Word&gt;M) \k&lt;Word&gt; : 或 (?&#39;Word&#39;M) \k&#39;Word&#39;，其中M为子式。 常用分组语法捕获 (exp) : 匹配exp,并捕获文本到自动命名的组里 (?exp) : 匹配exp,并捕获文本到名称为name的组里，也可以写成(?’name’exp) (?:exp) : 匹配exp,不捕获匹配的文本，也不给此分组分配组号 零宽断言 (?=exp) : 匹配exp前面的位置 (?&lt;=exp) : 匹配exp后面的位置 (?!exp) : 匹配后面跟的不是exp的位置 (?&lt;!exp) : 匹配前面不是exp的位置 注释 (?#comment) : 这种类型的分组不对正则表达式的处理产生任何影响，用于提供注释让人阅读 贪婪与懒惰 贪婪：匹配的尽可能长 懒惰：匹配的尽可能短 *? : 重复任意次，但尽可能少重复 +? : 重复1次或更多次，但尽可能少重复 ?? : 重复0次或1次，但尽可能少重复 {n,m}? : 重复n到m次，但尽可能少重复 {n,}? : 重复n次以上，但尽可能少重复 平衡组/递归匹配 # 我开始看不懂了😂 其他 \a : 报警字符(打印它的效果是电脑嘀一声) \b : 通常是单词分界位置，但如果在字符类里使用代表退格 \t : 制表符，Tab \r : 回车 \v : 竖向制表符 \f : 换页符 \n : 换行符 \e : Escape \0nn : ASCII代码中八进制代码为nn的字符 \xnn : ASCII代码中十六进制代码为nn的字符 \unnnn : Unicode代码中十六进制代码为nnnn的字符 \cN : ASCII控制字符。比如\cC代表Ctrl+C \A : 字符串开头(类似^，但不受处理多行选项的影响) \Z : 字符串结尾或行尾(不受处理多行选项的影响) \z : 字符串结尾(类似$，但不受处理多行选项的影响) \G : 当前搜索的开头 \p{name} : Unicode中命名为name的字符类，例如\p{IsGreek} (?&gt;exp) : 贪婪子表达式 (?&lt;x&gt;-&lt;y&gt;exp) : 平衡组 (?im-nsx:exp) : 在子表达式exp中改变处理选项 (?im-nsx) : 为表达式后面的部分改变处理选项 (?(exp)yes|no) : 把exp当作零宽正向先行断言，如果在这个位置能匹配，使用yes作为此组的表达式；否则使用no (?(exp)yes) : 同上，只是使用空表达式作为no (?(name)yes|no) : 如果命名为name的组捕获到了内容，使用yes作为表达式；否则使用no (?(name)yes) : 同上，只是使用空表达式作为no 栗子 5-12位QQ：^\d{5,12}$ IPv4地址：((2[0-4]\d|25[0-5]|[01]?\d\d?)\.){3}(2[0-4]\d|25[0-5]|[01]?\d\d?) go go、kitty kitty这样的叠词：\b(\w+)\b\s+\1\b 后向引用：\b(\w+)\b\s+\1\b == \b(?&lt;Word&gt;\w+)\b\s+\k&lt;Word&gt;\b == \b(?&#39;Word&#39;\w+)\b\s+\k&#39;Word&#39;\b 最后 知识研究了一下语法，还未详细测试。思考：这玩意真心厉害😂。 思维导图]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>正则表达式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DEBUG - swift中取出通知中的frame]]></title>
    <url>%2Fpost%2Fdebug-swift-notifa-frame%2F</url>
    <content type="text"><![CDATA[swift中获取OC存储的Frame两种获取方案。 Swift下在Notification.userInfo取Frame，Debug和Release情况下还不一样。。 –&gt;更新于2016.12.1 Version 8.1 (8B62) 1234567891011func keyboardShow(sender: Notification) &#123; var endFrame = CGRect.zero if let frame = sender.userInfo?[UIKeyboardFrameEndUserInfoKey] as? CGRect &#123; endFrame = frame // *** Debug是可以通过的。但是Release无法通过。 NSLog("&lt;&lt;&lt;INFO&gt;&gt;&gt;: as CGRect") &#125; else if let value = sender.userInfo?[UIKeyboardFrameEndUserInfoKey] as? NSValue &#123; endFrame = value.cgRectValue // *** Release会取出NSValue NSLog("&lt;&lt;&lt;INFO&gt;&gt;&gt;: as NSValue") &#125; 由于Release无法调试，所以费了不少劲。首先Swift中的字典已经可以存放值类型，其本身也是值类型。所以我首先选择了第一种写法let frame = sender.userInfo?[UIKeyboardFrameEndUserInfoKey] as? CGRect, 但是Release情况下却发生解包失败的情况。所以采用OC的传统写法let value = sender.userInfo?[UIKeyboardFrameEndUserInfoKey] as? NSValue。就能解析出来。但是总感觉OC的方法不够swift😂。。。 有同事直接强制转换为NSValue是没有问题的，于是乎试了一下，发现直接校验NSValue就可以。但是swift中感觉不应该有这个转换了，毕竟本身就可以存储CGRect.. 猜测原因：目前阶段Swift的字典和OC的字典数据结构还并未完全一致。。]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>DEBUG</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DEBUG - Xcode8解析.crash]]></title>
    <url>%2Fpost%2Fdebug-xcode8-analysis-crash-file%2F</url>
    <content type="text"><![CDATA[5步解析.crash文件 Xcode8中解析.crash文件 导出x.crash文件，放置在目录A下 复制工程名.app.dSYM到目录A 配置环境变量，运行export DEVELOPER_DIR=/Applications/Xcode.app/Contents/Developer 拷贝脚本文件，运行cp /Applications/Xcode.app/Contents/SharedFrameworks/DVTFoundation.framework/Versions/A/Resources/symbolicatecrash 目录A 到目录A解析，运行./symbolicatecrash x.crash 工程名.app.dSYM &gt; 自定义输出结果文件名]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>DEBUG</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DEBUG - UIView.h#190]]></title>
    <url>%2Fpost%2Fdebug-uiview-m-190%2F</url>
    <content type="text"><![CDATA[CRASH:void UIViewReportBrokenSuperviewChain(UIView *__strong, UIView *__strong, BOOL)() UIView.m:190 - UIViewReportBrokenSuperviewChain异常信息： 123*** Assertion failure in void UIViewReportBrokenSuperviewChain(UIView *__strong, UIView *__strong, BOOL)(), /BuildRoot/Library/Caches/com.apple.xbs/Sources/UIKit/UIKit-3599.6.1/UIView.m:190invalid mode &apos;kCFRunLoopCommonModes&apos; provided to CFRunLoopRunSpecific - break on _CFRunLoopError_RunCalledWithInvalidMode to debug. This message will only appear once per execution.libc++abi.dylib: terminate_handler unexpectedly threw an exception 异常分析 APP crash在 1[keyWindow addSubview:weakSelf]; 错误堆栈信息。 但是真正造成crash的代码为： 1[self.layer insertSublayer:xxxView.layer atIndex:0]; 解决方案： 12[self layoutIfNeeded];[self.layer insertSublayer:xxxView.layer atIndex:0]; 原因分析： 下面这个说的很在理 http://stackoverflow.com/questions/39565424/swift-uiviewreportbrokensuperviewchain-cause-by-layer-manipulation I had this issue with a library when moving over to Xcode 8 (Material-Controls-For-iOS - MDTextField). I found that the problem was coming from where the layer of one view (which had no superview) was being added to another. It looks like this may be the case for yourself also - your toolbar being created has not been added to a superview first. The fix I used was to add the view as a subview of the view that the layer was being added to, so in your case adding the toolbar as a subview of myModelView should stop the error. 碰到该问题的还有 Google出来的一个，但是并未看到相关回复。。。 IOS10上崩溃错误“View has lost track of its superview, most (并未找到原贴) stackoverflow(这个分析的很到位) 错误堆栈 &lt;脱敏&gt; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667*** Assertion failure in void UIViewReportBrokenSuperviewChain(UIView *__strong, UIView *__strong, BOOL)(), /BuildRoot/Library/Caches/com.apple.xbs/Sources/UIKit/UIKit-3599.6.1/UIView.m:190invalid mode &apos;kCFRunLoopCommonModes&apos; provided to CFRunLoopRunSpecific - break on _CFRunLoopError_RunCalledWithInvalidMode to debug. This message will only appear once per execution.libc++abi.dylib: terminate_handler unexpectedly threw an exception(lldb) bt* thread #1: tid = 0x87c18, 0x000000018238c524 libobjc.A.dylib`objc_exception_throw, queue = &apos;com.apple.main-thread&apos;, stop reason = breakpoint 1.2 frame #0: 0x000000018238c524 libobjc.A.dylib`objc_exception_throw frame #1: 0x0000000183954094 CoreFoundation`+[NSException raise:format:arguments:] + 104 frame #2: 0x00000001843de898 Foundation`-[NSAssertionHandler handleFailureInFunction:file:lineNumber:description:] + 88 frame #3: 0x0000000189a7cf9c UIKit`UIViewReportBrokenSuperviewChain + 472 frame #4: 0x0000000189a7d658 UIKit`_UIViewTopDownSubtreeTraversal + 1496 frame #5: 0x000000018a0f3390 UIKit`-[UIView(UIConstraintBasedLayout_EngineDelegate) _invalidateSystemLayoutSizeFittingSizeAtEngineDelegateLevel] + 232 frame #6: 0x00000001843832ac Foundation`-[NSISEngine tryToAddConstraintWithMarker:expression:integralizationAdjustment:mutuallyExclusiveConstraints:] + 920 frame #7: 0x0000000184382dcc Foundation`-[NSLayoutConstraint _addLoweredExpression:toEngine:integralizationAdjustment:lastLoweredConstantWasRounded:mutuallyExclusiveConstraints:] + 284 frame #8: 0x00000001843809e0 Foundation`-[NSLayoutConstraint _addToEngine:integralizationAdjustment:mutuallyExclusiveConstraints:] + 272 frame #9: 0x000000018989cfdc UIKit`__57-[UIView(AdditionalLayoutSupport) _switchToLayoutEngine:]_block_invoke_2 + 396 frame #10: 0x0000000184380510 Foundation`-[NSISEngine withBehaviors:performModifications:] + 168 frame #11: 0x000000018989cde8 UIKit`__57-[UIView(AdditionalLayoutSupport) _switchToLayoutEngine:]_block_invoke + 564 frame #12: 0x00000001897995e0 UIKit`-[UIView(AdditionalLayoutSupport) _switchToLayoutEngine:] + 224 frame #13: 0x000000018989cf14 UIKit`__57-[UIView(AdditionalLayoutSupport) _switchToLayoutEngine:]_block_invoke_2 + 196 frame #14: 0x0000000184380510 Foundation`-[NSISEngine withBehaviors:performModifications:] + 168 frame #15: 0x000000018989cde8 UIKit`__57-[UIView(AdditionalLayoutSupport) _switchToLayoutEngine:]_block_invoke + 564 frame #16: 0x00000001897995e0 UIKit`-[UIView(AdditionalLayoutSupport) _switchToLayoutEngine:] + 224 frame #17: 0x000000018989cf14 UIKit`__57-[UIView(AdditionalLayoutSupport) _switchToLayoutEngine:]_block_invoke_2 + 196 frame #18: 0x0000000184380510 Foundation`-[NSISEngine withBehaviors:performModifications:] + 168 frame #19: 0x000000018989cde8 UIKit`__57-[UIView(AdditionalLayoutSupport) _switchToLayoutEngine:]_block_invoke + 564 frame #20: 0x00000001897995e0 UIKit`-[UIView(AdditionalLayoutSupport) _switchToLayoutEngine:] + 224 frame #21: 0x000000018989cf14 UIKit`__57-[UIView(AdditionalLayoutSupport) _switchToLayoutEngine:]_block_invoke_2 + 196 frame #22: 0x0000000184380510 Foundation`-[NSISEngine withBehaviors:performModifications:] + 168 frame #23: 0x000000018989cde8 UIKit`__57-[UIView(AdditionalLayoutSupport) _switchToLayoutEngine:]_block_invoke + 564 frame #24: 0x00000001897995e0 UIKit`-[UIView(AdditionalLayoutSupport) _switchToLayoutEngine:] + 224 frame #25: 0x00000001898a4bb0 UIKit`-[UIWindow(UIConstraintBasedLayout) _switchToLayoutEngine:] + 72 frame #26: 0x00000001898a4b04 UIKit`-[UIWindow(UIConstraintBasedLayout) _initializeLayoutEngine] + 256 frame #27: 0x00000001898a4910 UIKit`-[UIView(UIConstraintBasedLayout) _layoutEngine_windowDidChange] + 132 frame #28: 0x00000001897996dc UIKit`-[UIView(Internal) _didMoveFromWindow:toWindow:] + 200 frame #29: 0x0000000189798d90 UIKit`__45-[UIView(Hierarchy) _postMovedFromSuperview:]_block_invoke + 156 frame #30: 0x0000000189798be8 UIKit`-[UIView(Hierarchy) _postMovedFromSuperview:] + 792 frame #31: 0x00000001897a4ad0 UIKit`-[UIView(Internal) _addSubview:positioned:relativeTo:] + 1788 frame #32: 0x00000001897a43bc UIKit`-[UIView(Hierarchy) addSubview:] + 828 * frame #33: 0x00000001004f78ec Project_ent`__31-[EsfCommentReportView show]_block_invoke((null)=&lt;unavailable&gt;) + 228 at EsfCommentReportView.m:293 frame #34: 0x00000001897d2b88 UIKit`+[UIView(UIViewAnimationWithBlocks) _setupAnimationWithDuration:delay:view:options:factory:animations:start:animationStateGenerator:completion:] + 660 frame #35: 0x00000001897d28e8 UIKit`+[UIView(UIViewAnimationWithBlocks) animateWithDuration:animations:] + 56 frame #36: 0x00000001004f77a0 Project_ent`-[EsfCommentReportView show](self=0x000000015fe32020, _cmd=&quot;show&quot;) + 492 at EsfCommentReportView.m:291 frame #37: 0x0000000100858a04 Project_ent`__53-[BuyerAdviserProfileViewController reportAction:]_block_invoke((null)=&lt;unavailable&gt;) + 308 at BuyerAdviserProfileViewController.m:174 frame #38: 0x00000001003f93e4 Project_ent`+[MyLoginViewController ifShouldLoginFromViewController:sourceType:afterCheckOrLogin:cancelLogin:](self=MyLoginViewController, _cmd=&quot;ifShouldLoginFromViewController:sourceType:afterCheckOrLogin:cancelLogin:&quot;, viewController=0x000000015fd2e320, sourceType=2, afterCheckOrLogin=0x00000001008588d0, cancelLogin=(null)) + 236 at MyLoginViewController.m:123 frame #39: 0x00000001003f92b0 Project_ent`+[MyLoginViewController ifShouldLoginFromViewController:afterCheckOrLogin:cancelLogin:](self=MyLoginViewController, _cmd=&quot;ifShouldLoginFromViewController:afterCheckOrLogin:cancelLogin:&quot;, viewController=0x000000015fd2e320, afterCheckOrLogin=0x00000001008588d0, cancelLogin=(null)) + 156 at MyLoginViewController.m:114 frame #40: 0x00000001003f9124 Project_ent`+[MyLoginViewController ifShouldLoginFromViewController:afterCheckOrLogin:](self=MyLoginViewController, _cmd=&quot;ifShouldLoginFromViewController:afterCheckOrLogin:&quot;, viewController=0x000000015fd2e320, afterCheckOrLogin=0x00000001008588d0) + 120 at MyLoginViewController.m:104 frame #41: 0x0000000100858870 Project_ent`-[BuyerAdviserProfileViewController reportAction:](self=0x000000015fd2e320, _cmd=&quot;reportAction:&quot;, button=0x000000015fe26650) + 452 at BuyerAdviserProfileViewController.m:156 frame #42: 0x00000001897d27b0 UIKit`-[UIApplication sendAction:to:from:forEvent:] + 96 frame #43: 0x00000001897d2730 UIKit`-[UIControl sendAction:to:forEvent:] + 80 frame #44: 0x00000001897bcbe4 UIKit`-[UIControl _sendActionsForEvents:withEvent:] + 452 frame #45: 0x00000001897d201c UIKit`-[UIControl touchesEnded:withEvent:] + 584 frame #46: 0x00000001897d1b44 UIKit`-[UIWindow _sendTouchesForEvent:] + 2484 frame #47: 0x00000001897ccd8c UIKit`-[UIWindow sendEvent:] + 2988 frame #48: 0x000000018979d858 UIKit`-[UIApplication sendEvent:] + 340 frame #49: 0x0000000189f8acb8 UIKit`__dispatchPreprocessedEventFromEventQueue + 2736 frame #50: 0x0000000189f84720 UIKit`__handleEventQueue + 784 frame #51: 0x0000000183902278 CoreFoundation`__CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE0_PERFORM_FUNCTION__ + 24 frame #52: 0x0000000183901bc0 CoreFoundation`__CFRunLoopDoSources0 + 524 frame #53: 0x00000001838ff7c0 CoreFoundation`__CFRunLoopRun + 804 frame #54: 0x000000018382e048 CoreFoundation`CFRunLoopRunSpecific + 444 frame #55: 0x00000001852b1198 GraphicsServices`GSEventRunModal + 180 frame #56: 0x0000000189808628 UIKit`-[UIApplication _run] + 684 frame #57: 0x0000000189803360 UIKit`UIApplicationMain + 208 frame #58: 0x0000000100a3db78 Project_ent`main + 460 at main.swift:24 frame #59: 0x00000001828105b8 libdyld.dylib`start + 4(lldb)]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>DEBUG</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Xcode打包脚本]]></title>
    <url>%2Fpost%2Fbuild-ipa-sh%2F</url>
    <content type="text"><![CDATA[Jenkins自动构建脚本解决方案。 写在前面2017.9.26更新：xcode9更新又无法构建咯 2017.6.14更新:xcpretty格式化输出日志。很溜，输出效果和 fastlane 差不多哈哈 2017.1.13更新： 好吧，其实有更加强悍的打包工具，虽然早有耳闻但是没弄。然后最近搭建了一下，这打包脚本也不用了，毕竟有成套工具嘛。嘿嘿 不过最后上传osc的脚本还是很可以的。 传送门：Fastlane自动化笔记 Xcode8好悲催，Xcode8更新之后Jenkins打包失败了。。由于代码库中使用了swift3语法，故必须使用Xcode8。。 先来重点：可用脚本： 12345678910111213141516171819202122232425#!/bin/bash# 追上fir API token 自动上传# 基于当前代码进行打包打包目录：MyProject/build/MyProject_ent.ipacd MyProjectrm -rf ./build/*xcodebuild -archivePath "./build/xxx.xcarchive" -workspace MyProject.xcworkspace -sdk iphoneos -scheme "MyProject_ent" -configuration "Release Inhouse" archiveecho "&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd"&gt;&lt;plist version="1.0"&gt;&lt;dict&gt;&lt;key&gt;method&lt;/key&gt;&lt;string&gt;enterprise&lt;/string&gt;&lt;key&gt;compileBitcode&lt;/key&gt;&lt;string&gt;YES&lt;/string&gt;&lt;/dict&gt;&lt;/plist&gt;" &gt; ./build/exportOptionsPlist.plistxcodebuild -exportArchive -archivePath "./build/xxx.xcarchive" -exportPath "./build/" -exportOptionsPlist ./build/exportOptionsPlist.plistcd build/fir i ./MyProject_ent.ipaif [ -n "$1" ]; then git log -10 &gt; git.log fir p ./MyProject_ent.ipa -T $1 -c git.logfi 之前漏掉了一个错误：The flag -exportFormat cannot be specified along with -exportOptionsPlist 导致了最终包签名错误，而无法安装。 exportOptionsPlist参考的iOS 打包总结 手动上传123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135#!/bin/bash# 追上fir API token 自动上传# 基于当前代码进行打包打包目录：xxxx/build/xxxx_ent.ipaworkspace_name=xxxxscheme_name=xxxx_entcd $workspace_namerm -rf ./build/*xcodebuild clean -workspace $workspace_name.xcworkspace -scheme $scheme_nam -configuration Release | xcprettyxcodebuild archive -archivePath &quot;./build/xxx.xcarchive&quot; -workspace $workspace_name.xcworkspace -sdk iphoneos -scheme $scheme_name -configuration &quot;Release Inhouse&quot;cat &lt;&lt; EOF &gt; ./build/exportOptionsPlist.plist&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE plist PUBLIC &quot;-//Apple//DTD PLIST 1.0//EN&quot; &quot;http://www.apple.com/DTDs/PropertyList-1.0.dtd&quot;&gt;&lt;plist version=&quot;1.0&quot;&gt; &lt;dict&gt; &lt;key&gt;method&lt;/key&gt; &lt;string&gt;enterprise&lt;/string&gt; &lt;key&gt;compileBitcode&lt;/key&gt; &lt;false/&gt; &lt;/dict&gt;&lt;/plist&gt;EOFxcodebuild -exportArchive -archivePath &quot;./build/xxx.xcarchive&quot; -exportOptionsPlist &quot;./build/exportOptionsPlist.plist&quot; -exportPath &quot;./build/&quot;cd build/git log -10 &gt; git.log#拷贝ipa到临时文件夹中cp ./$scheme_name.ipa ./tmp.zip#将ipa解压unzip tmp.zip#app文件中Info.plist文件路径app_infoplist_path=$(pwd)/Payload/*.app/Info.plist#取bundleIdentifierbundleIdentifier=$(/usr/libexec/PlistBuddy -c &quot;print CFBundleIdentifier&quot; $&#123;app_infoplist_path&#125;)#取build值bundleVersion=$(/usr/libexec/PlistBuddy -c &quot;print CFBundleVersion&quot; $&#123;app_infoplist_path&#125;)#显示名称ipa_name=$workspace_name#ipa下载urlipa_download_url=&quot;https://***/install_ipa/raw/master/xxxx_ent.ipa&quot;#itms-services协议串ios_install_url=&quot;itms-services://?action=download-manifest&amp;url=https://***/install_ipa/raw/master/xxxx_ent.plist&quot;#生成install.html文件cat &lt;&lt; EOF &gt; index.html&lt;!DOCTYPE HTML&gt;&lt;html&gt; &lt;head&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot; /&gt; &lt;title&gt;安装&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;br&gt; &lt;br&gt; &lt;br&gt; &lt;br&gt; &lt;p align=center&gt; &lt;font size=&quot;8&quot;&gt; &lt;a href=&quot;$&#123;ios_install_url&#125;&quot;&gt;点击这里安装&lt;/a&gt; &lt;/font&gt; &lt;/p&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt;EOF#生成plist文件cat &lt;&lt; EOF &gt; $&#123;workspace_name&#125;.plist&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE plist PUBLIC &quot;-//Apple//DTD PLIST 1.0//EN&quot; &quot;http://www.apple.com/DTDs/PropertyList-1.0.dtd&quot;&gt;&lt;plist version=&quot;1.0&quot;&gt;&lt;dict&gt; &lt;key&gt;items&lt;/key&gt; &lt;array&gt; &lt;dict&gt; &lt;key&gt;assets&lt;/key&gt; &lt;array&gt; &lt;dict&gt; &lt;key&gt;kind&lt;/key&gt; &lt;string&gt;software-package&lt;/string&gt; &lt;key&gt;url&lt;/key&gt; &lt;string&gt;$&#123;ipa_download_url&#125;&lt;/string&gt; &lt;/dict&gt; &lt;dict&gt; &lt;key&gt;kind&lt;/key&gt; &lt;string&gt;display-image&lt;/string&gt; &lt;key&gt;needs-shine&lt;/key&gt; &lt;true/&gt; &lt;key&gt;url&lt;/key&gt; &lt;string&gt;http://git.oschina.net/logo.svg&lt;/string&gt; &lt;/dict&gt; &lt;dict&gt; &lt;key&gt;kind&lt;/key&gt; &lt;string&gt;full-size-image&lt;/string&gt; &lt;key&gt;needs-shine&lt;/key&gt; &lt;true/&gt; &lt;key&gt;url&lt;/key&gt; &lt;string&gt;http://git.oschina.net/logo.svg&lt;/string&gt; &lt;/dict&gt; &lt;/array&gt;&lt;key&gt;metadata&lt;/key&gt; &lt;dict&gt; &lt;key&gt;bundle-identifier&lt;/key&gt; &lt;string&gt;$&#123;bundleIdentifier&#125;&lt;/string&gt; &lt;key&gt;bundle-version&lt;/key&gt; &lt;string&gt;$&#123;bundleVersion&#125;&lt;/string&gt; &lt;key&gt;kind&lt;/key&gt; &lt;string&gt;software&lt;/string&gt; &lt;key&gt;subtitle&lt;/key&gt; &lt;string&gt;$&#123;ipa_name&#125;&lt;/string&gt; &lt;key&gt;title&lt;/key&gt; &lt;string&gt;$&#123;ipa_name&#125;&lt;/string&gt; &lt;/dict&gt; &lt;/dict&gt; &lt;/array&gt;&lt;/dict&gt;&lt;/plist&gt;EOFfir i $scheme_name.ipa 手动上传到OSC脚本123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232#!/bin/bashroot_path=$(pwd)workspace_name=Fangduoduoscheme_name=XXX# 编译cd $root_pathcd $workspace_namerm -rf ./build/*xcodebuild -archivePath ./build/$scheme_name.xcarchive -workspace $workspace_name.xcworkspace -sdk iphoneos -scheme $scheme_name -configuration &quot;Release Inhouse&quot; archiveecho &quot;&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE plist PUBLIC &quot;-//Apple//DTD PLIST 1.0//EN&quot; &quot;http://www.apple.com/DTDs/PropertyList-1.0.dtd&quot;&gt;&lt;plist version=&quot;1.0&quot;&gt;&lt;dict&gt;&lt;key&gt;method&lt;/key&gt;&lt;string&gt;enterprise&lt;/string&gt;&lt;key&gt;compileBitcode&lt;/key&gt;&lt;false/&gt;&lt;/dict&gt;&lt;/plist&gt;&quot; &gt; ./build/exportOptionsPlist.plistxcodebuild -exportArchive -archivePath ./build/$scheme_name.xcarchive -exportOptionsPlist &quot;./build/exportOptionsPlist.plist&quot; -exportPath &quot;./build/&quot;cd build/if [ ! -f $scheme_name.ipa ]; then echo &quot;*** 无法打包 ***&quot; exit -1fifir i ./$scheme_name.ipagit log -10 &gt; git.loggit_log=$(cat git.log)# fir 上传if [ -n &quot;$1&quot; ]; then fir p ./$scheme_name.ipa -T $1 -c git.logfi# 校验HTML并上传public_git_path=$root_path/public_ipa_tmp/public_git_root=&quot;install_ipa&quot;public_git=&quot;https://***/install_ipa.git&quot;#ipa下载urlipa_download_url=&quot;https://***/install_ipa/raw/master/XXX.ipa&quot;#itms-services协议串ios_install_url=&quot;itms-services://?action=download-manifest&amp;url=https://***/install_ipa/raw/master/XXX.plist&quot;cd $root_path/# checkout path is OKif [ ! -e $public_git_path ]; then mkdir $public_git_pathfiif [ -n $public_git_path ]; then rm -rf $public_git_pathfimkdir $public_git_pathcd $public_git_pathgit initgit remote add origin $public_gitcd $root_path/$workspace_name/build/#拷贝ipa到临时文件夹中cp ./$scheme_name.ipa ./tmp.ziprm -rf Payload#将ipa解压unzip tmp.zip#app文件中Info.plist文件路径app_infoplist_path=$(pwd)/Payload/*.app/Info.plist#取bundleIdentifierbundleIdentifier=$(/usr/libexec/PlistBuddy -c &quot;print CFBundleIdentifier&quot; $&#123;app_infoplist_path&#125;)#取build值bundleVersion=$(/usr/libexec/PlistBuddy -c &quot;print CFBundleVersion&quot; $&#123;app_infoplist_path&#125;)#取shortVersionbuild值shortVersion=$(/usr/libexec/PlistBuddy -c &quot;print CFBundleShortVersionString&quot; $&#123;app_infoplist_path&#125;)#显示名称ipa_name=$(/usr/libexec/PlistBuddy -c &quot;print CFBundleDisplayName&quot; $&#123;app_infoplist_path&#125;)nowTime=$(date +%Y-%m-%d\ %H:%M)log_url=&quot;https://madordie.github.io/uploads/avatar.png&quot;#生成install.html文件cat &lt;&lt; EOF &gt; index.html&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot; /&gt;&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1,minimum-scale=1,maximum-scale=1,user-scalable=0&quot;&gt;&lt;title&gt;$&#123;ipa_name&#125;安装&lt;/title&gt;&lt;style&gt;.containor &#123; position: relative; top: 0; left: 0; right: 0; margin: 0 auto; width: 100%; max-width: 640px; text-align: center;&#125;.logo &#123; width: 120px; margin-top: 30px;&#125;.title,.version_history,.update_time &#123; text-align: center; color: #999; font-size: 16px;&#125;.title &#123; margin-top: 10px;&#125;.version_history,.update_time &#123; margin-top: 5px;&#125;.download &#123; display: block; width: 150px; height: 30px; line-height: 30px; margin: 0 auto; margin-top: 20px; border: 1px solid #eee; border-radius: 20px; text-decoration: none; color: #999;&#125;.log_title &#123; margin-top: 20px; font-size: 18px; color: #333;&#125;.log &#123; color: #aaa; padding: 20px; text-align: left; font-size: 12px; line-height: 15px; white-space: pre-wrap; word-wrap: break-word; overflow: hidden;&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=&quot;containor&quot;&gt; &lt;img class=&quot;logo&quot; src=$&#123;log_url&#125; /&gt; &lt;div class=&quot;title&quot;&gt;$ipa_name&lt;/div&gt; &lt;div class=&quot;version_history&quot;&gt;$&#123;shortVersion&#125;(bundle:$&#123;bundleVersion&#125;)&lt;/div&gt; &lt;div&gt;&lt;/div&gt; &lt;div class=&quot;update_time&quot;&gt;$&#123;nowTime&#125;&lt;/div&gt; &lt;a class=&quot;download&quot; href=&quot;$&#123;ios_install_url&#125;&quot;&gt;点击这里安装&lt;/a&gt; &lt;div class=&quot;log_title&quot;&gt;更新日志&lt;/div&gt; &lt;div class=&quot;log&quot;&gt; $&#123;git_log&#125; &lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;EOF#生成plist文件cat &lt;&lt; EOF &gt; $&#123;scheme_name&#125;.plist&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE plist PUBLIC &quot;-//Apple//DTD PLIST 1.0//EN&quot; &quot;http://www.apple.com/DTDs/PropertyList-1.0.dtd&quot;&gt;&lt;plist version=&quot;1.0&quot;&gt;&lt;dict&gt; &lt;key&gt;items&lt;/key&gt; &lt;array&gt; &lt;dict&gt; &lt;key&gt;assets&lt;/key&gt; &lt;array&gt; &lt;dict&gt; &lt;key&gt;kind&lt;/key&gt; &lt;string&gt;software-package&lt;/string&gt; &lt;key&gt;url&lt;/key&gt; &lt;string&gt;$&#123;ipa_download_url&#125;&lt;/string&gt; &lt;/dict&gt; &lt;dict&gt; &lt;key&gt;kind&lt;/key&gt; &lt;string&gt;display-image&lt;/string&gt; &lt;key&gt;needs-shine&lt;/key&gt; &lt;true/&gt; &lt;key&gt;url&lt;/key&gt; &lt;string&gt;http://git.oschina.net/logo.svg&lt;/string&gt; &lt;/dict&gt; &lt;dict&gt; &lt;key&gt;kind&lt;/key&gt; &lt;string&gt;full-size-image&lt;/string&gt; &lt;key&gt;needs-shine&lt;/key&gt; &lt;true/&gt; &lt;key&gt;url&lt;/key&gt; &lt;string&gt;http://git.oschina.net/logo.svg&lt;/string&gt; &lt;/dict&gt; &lt;/array&gt;&lt;key&gt;metadata&lt;/key&gt; &lt;dict&gt; &lt;key&gt;bundle-identifier&lt;/key&gt; &lt;string&gt;$&#123;bundleIdentifier&#125;&lt;/string&gt; &lt;key&gt;bundle-version&lt;/key&gt; &lt;string&gt;$&#123;bundleVersion&#125;&lt;/string&gt; &lt;key&gt;kind&lt;/key&gt; &lt;string&gt;software&lt;/string&gt; &lt;key&gt;subtitle&lt;/key&gt; &lt;string&gt;$&#123;ipa_name&#125;&lt;/string&gt; &lt;key&gt;title&lt;/key&gt; &lt;string&gt;$&#123;ipa_name&#125;&lt;/string&gt; &lt;/dict&gt; &lt;/dict&gt; &lt;/array&gt;&lt;/dict&gt;&lt;/plist&gt;EOF#fir i $scheme_name.ipacp $scheme_name.ipa $public_git_pathcp $scheme_name.plist $public_git_pathcp index.html $public_git_pathcd $public_git_pathls -l &gt; README.mdif [ ! -e &quot;./.git/&quot; ]; then echo &quot;*** OSC的git目录不完整，无法上传，请联系开发! ***&quot; exit -1fiecho &quot;commit and pushing ...&quot;git add .git commit -am $bundleVersiongit push -f origin master 将符号表dsym上传至bugly1234567891011121314151617181920212223242526272829path='/Users/xx/.jenkins/workspace/xzx'schem='xx'package='xx'bugly_id='xx'bugly_key='xx'cp $&#123;path&#125;/xx/Info.plist ./Info.plistcp $&#123;path&#125;/xx.app.dSYM.zip ./dsym.zip# ------------ post dsym ------------ #unzip -o dsym.zip -d dsymapp_infoplist_path='Info.plist'version=$(/usr/libexec/PlistBuddy -c "print CFBundleVersion" $&#123;app_infoplist_path&#125;)java -jar ./bugly/buglySymboliOS.jar \ -i dsym/$&#123;scheme&#125; \ -dsym \ -u \ -id $&#123;bugly_id&#125; \ -key $&#123;bugly_key&#125; \ -package $&#123;package&#125; \ -version $&#123;version&#125;# ------------ UUID ------------ #unzip -o ./dsym/$&#123;scheme&#125;.zipxcrun dwarfdump --uuid ./$&#123;scheme&#125; &gt;&gt; ./uuids-$&#123;version&#125;.txt 修改环境代码1sed -i '' "s/#define RELEASE_MODE [[:digit:]]/#define RELEASE_MODE $&#123;mode&#125;/g" ./Fangduoduo/config/AppConfig.h Jenkins安装 Installing Jenkins OS X Homebrew 后台运行1brew services start jenkins 无法识别gerrit…. 1nohup jenkins &gt; ~/fdd-backup/jenkins.log g 2&gt;&amp;1 &amp; 无法签名… 上面2个方案并不是不能运行，而是需要额外配置。。😂 https://gxnotes.com/article/61107.html]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>构建</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UI素材与代码解耦的讨论与思考]]></title>
    <url>%2Fpost%2Fui-source-and-code-decoupling%2F</url>
    <content type="text"><![CDATA[个人对UI素材和代码的解耦的一些粗浅的看法。比如：解耦方案、是否该解耦。 起因 群里听到有人讨论这个话题，当时觉得比较新鲜，就十分好奇的请教了两位经验丰富的@kkk、@AK，虽然未得其中真髓，但是也得到一些自己的思考。总结一下两人的方案，以及自己的思考， 问题 代码内部引入的素材属于设计管理，代码则是码农管理，从这个角度来说两个工做都有码农管理则是一种耦合，为了减轻设计师频繁更换素材而带来的码农的无休止的协作，所以可以进行着方面的解藕。 解决方案 哪坏哪补。有问题就会有解决方案。群中说的方案一由于当时不方便，所以并没有弄明白。方案二、方案三是自己的一些解决方案。 方案一 群中讨论的是素材、代码放在一个仓库，分支不同，使用脚本进行整合(其实并没有想明白怎么弄。。下周请教一下)。另外，@夏汁泡泡 还有一个简化就是这个处理的脚本可以放在Add Run Script Build Phase，暴露出来已知的问题： 操作麻烦 图片可能重复 命名规范 方案二 按照Pods的集成方式，可以将素材看作一个第三方库，直接将素材做成一个bundle，采用Pods私有库或者其他方式放入工程。暴露出来已知的问题： 什么时候更新这个bundle 多人合作时这个bundle冲突问题 命名规范 方案三 工程使用xcassets进行素材打包，然后使用子库进行持续集成。这样，设计师的素材可以放在另一个独立素材仓库，内含更新脚本，直接将素材生成对应的xcassets结构，并上传至子库。这样设计师做完素材直接扔在文件夹中，自动或手动跑一下脚本即可更新到素材仓库。暴露出来已知的问题： 由于没有测试过，不知道如果素材比较多的话会不会发生冲突。因该不会吧，都是加文件或者修改😂 (有时间去研究一下之后更新) 命名规范的问题依旧存在 方案四 字体库 。最近同事提出关于用字体库去存储素材图片的方案。感觉非常的赞，虽然并未实践，但是这种方案就像emoji一样，不但减少了相同图片内容之间存在多个不同尺寸版本的问题，也能够比较好的进行压缩管理。设计师需要做的就是做出一套字体库，然后将所有的素材图全部按照设计字体的方案进行设计和制作，这样在使用的时候只需要导入一个字体文件就好了。对于这个字体文件如何管理都好说，毕竟只有一个字体文件。字体库的制作方面还不是很了解，所以只提着么一下吧嘿嘿。。 思考 好了，重要的问题来了，上面的问题都是存在命名规范的问题。此问题如何化解呢？ 素材的引入需根据素材名写入代码中，那么如何才能不用素材名呢？那时不可能的😝，毕竟你要有一个唯一标识符去标志着一个素材。可能有的人说可以做一个json用来保存代码的命名和素材的命名呀，我只想说MDZZ，那不是有两套需要维护的命名规则么。。得不偿失。 这个命名的问题其实不能复杂化。参看iOS的项目国际化操作，使用一个key作为文案的唯一标识符，需要显示该文案，通过这个唯一标识符就能直接取到。回头看下素材，是不是也能炮制一个呢？ 如果素材名字有统一的规则，就不需要这样的key作为统一标识符，直接使用素材名字即可，这样维护一套素材命名规则总比两套更容易维护。所以，直接使用素材名即可。 如果素材不能统一命名规则，那么这样的对照文件存在也是很不错的。话又说回来，要进行UI素材和代码的解耦，素材名都不能统一，还如何解耦，此问题也不存在了。。 退一步，我们的目的是让素材让设计师自己维护，代码不去维护素材。设计师和码农的耦合在于图片本身的交换比较烦。不论采用哪种解耦方案，都是把图片的耦合转换为图片名字的耦合(也可以理解为素材对应的KEY的耦合)。结果是 为了解除一个耦合,而引入了一个新的耦合 。个人认为这样是不靠谱的。。除非有强力的人去推动设计师走标准的命名。 结论 其实这个问题大可不必纠结，如果有强力的人去推动这个标准持续走下去那么这个问题才有价值。如果真的要进行题中说的代码解耦的话，我认为第三种是比较靠谱的。 命名标准、命名标准、命名标准… 。 说明 经验有限，如果有更好的方案，望告知。拜谢！]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[开发小记]]></title>
    <url>%2Fpost%2Fnote%2F</url>
    <content type="text"><![CDATA[开发中的小笔记。记录开发中的点滴滴点。 批量替换json文件中的注释备份至.bat 1$ perl -i.bat -lpe 's/\/\/[^"]+$//g' xx 批量正则替换的另一种思路 1234#!/base/shfind . -name &apos;*.swift&apos; | while read file; do perl -i -lpe &apos;s/if \(([^\)].*)\) \&#123;/if $1 \&#123;/g&apos; $filedone 批量删除空格组成的空行中的空格 1234#!/base/shfind . -name &apos;*.swift&apos; | while read file; do sed -i &apos;&apos; &apos;s/^[[:space:]][[:space:]]*$//g&apos; $filedone 获取代码执行时间 1234567891011121314151617181920212223242526272829#import &lt;mach/mach_time.h&gt;static NSMutableDictionary *__times;static inline void debug_start_of(NSString *key)&#123; __times = __times ?: [NSMutableDictionary new]; uint64_t start = mach_absolute_time(); __times[key] = @(start);&#125;static inline void debug_stop_of(NSString *key)&#123; if (__times) &#123; uint64_t end = mach_absolute_time(); uint64_t start = [__times[key] unsignedLongLongValue]; if (start != 0) &#123; uint64_t elapsed = end - start; mach_timebase_info_data_t info; if (mach_timebase_info(&amp;info) != KERN_SUCCESS) &#123; printf("mach_timebase_info failed\n"); &#125; uint64_t nanosecs = elapsed * info.numer / info.denom; uint64_t millisecs = nanosecs / 1000000; printf("[DEBUG code rt] %s:%llu ms\n", [key cStringUsingEncoding:NSUTF8StringEncoding], millisecs); &#125; else &#123; printf("[DEBUG code rt] %s error: no start\n", [key cStringUsingEncoding:NSUTF8StringEncoding]); &#125; &#125;&#125; NAN A对B除余时，如果B == 0 则会造成NAN，truncatingRemainder(dividingBy:)是swift的方法，也会造成此问题 当NSUInteger 0 - 1时，运算结果为 NAN，iOS中有一个宏isnan(x)返回是否为nan。另外这里有一篇文章Objective-C 中 判断 NaN大致记录了一下12345678910111213// math.h #56#if defined(__GNUC__)# define HUGE_VAL __builtin_huge_val()# define HUGE_VALF __builtin_huge_valf()# define HUGE_VALL __builtin_huge_vall()# define NAN __builtin_nanf("0x7fc00000")#else# define HUGE_VAL 1e500# define HUGE_VALF 1e50f# define HUGE_VALL 1e5000L# define NAN __nan()#endif 另外，NAN不能直接判断 == 需要调用下面的宏。否则会发生莫名其妙的问题123456 // math.h #178#define isnan(x) \ ( sizeof(x) == sizeof(float) ? __inline_isnanf((float)(x)) \ : sizeof(x) == sizeof(double) ? __inline_isnand((double)(x)) \ : __inline_isnanl((long double)(x)))]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[项目中的UITableView]]></title>
    <url>%2Fpost%2Fabout-project-tableview%2F</url>
    <content type="text"><![CDATA[前两天听到有人说多人合作的项目并不需要处理很多事情，只需要处理好自己的那部分业务逻辑就好了。感觉这是一个很不负责任的说法。 作为一个APP的开发者，自己负责的事其中的一个模块，但是都是这个APP的开发者，也要往里面塞代码，如果每个人都用不同的逻辑风格去组织代码。那么整个项目就是一坨坨坨，这个坨会影响项目的演进、日后的发展。 当然有的是看不出来的，比如说：当一个请假的人写的代码出现一个BUG，需要修复上线的时候，对于不同的代码风格，需要找到问题的关键代码，这个过程是撕心裂肺的，但是如果同一套代码风格，心中就会有一个大致的位置，去修改时候就会比较快速的定位问题。 从协议入手UITableView是项目中非常常见的iOS高级控件，在页面中所有相似的页面几乎都是由该控件进行完成。其广泛运用的不止是使用方便，最主要的是内部的复用优化也是相当给力的。 协议模式下的UITableViewUITableView是典型的 协议-代理模式 ，比例id &lt;UITableViewDataSource&gt; dataSource和id &lt;UITableViewDelegate&gt; delegate，所以使用对于这种比较规整的列表来说把协议继续扩展到下一级也是可以的。 为了统一UITableView.dataSource和UITableView.delegate，构建如下协议：1234567// 直接填充Cell的cellModel@protocol CellModelProtocol &lt;NSObject&gt;- (NSString *)cellClassName; // cellModel绑定的类名- (void)cellModelForCell:(UITableViewCell *)cell; // cellModel填充上面绑定的cell@end 那么只需要在代理中做如下设置: 12345678910111213141516171819202122232425#pragma mark &lt;UITableViewDelegate, UITableViewDataSource&gt;- (NSInteger)numberOfSectionsInTableView:(UITableView*)tableView&#123; return 1;&#125;- (NSInteger)tableView:(UITableView*)tableView numberOfRowsInSection:(NSInteger)section&#123; return self.viewModel.dataSource.count;&#125;- (UITableViewCell*)tableView:(UITableView*)tableView cellForRowAtIndexPath:(NSIndexPath*)indexPath&#123; id&lt;CellModelProtocol&gt; cellModel = self.viewModel.dataSource[indexPath.row]; UITableViewCell* cell = [tableView dequeueReusableCellWithIdentifier:[cellModel cellClassName]]; cell.frame = tableView.bounds; [cellModel cellModelForCell:cell]; [cell sizeToFit]; return cell;&#125;- (CGFloat)tableView:(UITableView*)tableView heightForRowAtIndexPath:(NSIndexPath*)indexPath&#123; id&lt;CellModelProtocol&gt; cellModel = self.viewModel.dataSource[indexPath.row]; UITableViewCell* cell = [tableView ktj_cacheHeightCellForReuseIDFA:[cellModel cellClassName]]; [cellModel cellModelForCell:cell]; return [cell sizeThatFits:tableView.bounds.size].height;&#125; 而在cell中，默认在sizeThatFits:中进行布局的设置和算高即可。如下： 12345678910111213// xxxCell.m- (CGSize)sizeThatFits:(CGSize)size &#123; CGRect frame = CGRectZero; // 根据Cell的实际内容进行布局并设置高度 frame.origin = CGPointMake(10, 15); frame.size = [self.infoLabel sizeThatFits:CGSizeMake(size.width-frame.origin.x*2, size.height)]; self.infoLabel.frame = frame; size.height = CGRectGetMaxY(self.infoLabel.frame)+frame.origin.y; return size;&#125; 如果cell采用autolayout，则计算采用UITableView-FDTemplateLayoutCell的计算方法。 123456789101112131415161718192021@implementation UITableViewCell (KTJCellAutoLayoutForSize)// autolout布局计算高度- (CGSize)ktj_ALCellSizeThatFits:(CGSize)size &#123; // Add a hard width constraint to make dynamic content views (like labels) expand vertically instead // of growing horizontally, in a flow-layout manner. NSLayoutConstraint *tempWidthConstraint = [NSLayoutConstraint constraintWithItem:self.contentView attribute:NSLayoutAttributeWidth relatedBy:NSLayoutRelationEqual toItem:nil attribute:NSLayoutAttributeNotAnAttribute multiplier:1.0 constant:size.width]; [self.contentView addConstraint:tempWidthConstraint]; // Auto layout engine does its math size = [self.contentView systemLayoutSizeFittingSize:UILayoutFittingCompressedSize]; size.height += 1; [self.contentView removeConstraint:tempWidthConstraint]; return size;&#125;@end 另外在&lt;UITableViewDelegate, UITableViewDataSource&gt;中只写了1组，只有cell，没有header、footer的情况，如果需要，炮制即可。 说一下这个其中的ktj_cacheHeightCellForReuseIDFA:类别方法。这个方法是为了算高进行缓存的一个cell，这个cell保存在 NSCache中。所以为了统一，需要在数据初始化时候注册所有的cell。当然你也可以根据类名直接生成，这个自主决定。 说到算高，需要说一下这其中的dequeueReusableCellWithIdentifier:方法。该方法是从tableView的缓存池中取出指定ID的cell。请注意是 取出 ，并且UITableView并没有暴露出如何放进缓存池，也没有必要暴露出放进缓存池的方法。 而且UITableView只有一个地方能够接收Cell那就是tableView:cellForRowAtIndexPath:。所以请保证dequeueReusableCellWithIdentifier:取出的方法 需要通过tableView:cellForRowAtIndexPath:返回给UITableView 。这就是我上面说的ktj_cacheHeightCellForReuseIDFA:方法为何要做一个 cache去缓存我取出的cell，目的是为了减少cell的浪费。 同理，对于UITableView的headerView、footerView来说，可以炮制以上协议、方法。不再赘述 PS. UITableView-FDTemplateLayoutCell: sunnyxx打造的优化UITableView的一个库，6000的star，很赞。 规范化的代码风格对于多人开发，最崩溃的事情就要数去读别人的代码。就算不是多人开发，接手别人的代码也是让人最崩溃的事情。如果有不用考虑这件事的叫我！ 不同的公司可以有不同的代码风格，但是一个公司的代码风格需要保持一致，这样就不会出现一人请假，无人能接受项目的尴尬局面，就算能接，也是需要为了加一个逻辑判断，需要花费很大的精力去处理。 至于其中的代码不统一的坑，恐怕要等踩过才知道吧😂。 业务逻辑的拆分对于复杂的业务逻辑，对其拆分是非常重要的，不拆分很可能写出来的代码一个文件 &gt;1000 行。复杂的业务逻辑对于写出来需要一气呵成，修改起来也就出现了牵一发动全身(虽然拆分完成之后可能也会关键逻辑代码不可拆分，但是会好很多)。 筛选重构筛选主要处理的是筛选项，针对众多筛选条件拆分为不同的业务逻辑模块是必须的。遵照拆分的原则，于是乎根据UI划分出来位置、价格、户型、筛选、排序这么几个模块。针对每个模块自行处理选中数据、UI展示。对外只暴露选中项输入和选中回调。 对于每个数据大致都可分为一个列表，然后可选中1项或多项。于是乎，这个代码如果不拉出来是要写好多次的，拉出来，但是选中需要把选中的逻辑扔出来，方便自定义。]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>UITableView</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于转载的文章]]></title>
    <url>%2Fpost%2Fabout-reprint-article%2F</url>
    <content type="text"><![CDATA[一点删除原链接的转载文章的牢骚 缘由前两天看到朋友圈一个哥们转载了许多关于iOS的一些文章，很是兴奋，去围观。突然发现这文笔绝对是经过校对的。心中大喜，以为淘到宝了（因为文章并没有署名转载出处，所以应该是原创）。之后看了一下他的另一个文章，刚好我百度过这个文章的原作者的最后一个系列的，于是我又翻阅了一下看看是不是不一样，结果和我想的一样，除了删除了作者的署名之外其他的都是一样的。于是关掉了网页，心中默默的鄙视。 关于转载的别人文章对于一些大神的技术文章都是喜欢的，爱不释手的那种，我也是。有的能转载的我就转载，不能转载的，我会复制下来，放在我自己的文件夹中，为的是方便查询。在转载的时候我会特意标示转载的地址。而且一般情况下我会在文章的开始写上几句简单的主要的思想（比如：《[转]蓝牙开发》、《[搬运] mac下安装GDB》、《［搬运］MAC 下安装 brew》），当然有时候没来得及的就忘了😂（比如：《[搬运] iOS 7 侧滑返回手势使用和错误集》）。 还有关于文章的排版，殊不知原作者为了让读者更好的阅读会对排版做的比较好，有的人为了阅读方便会去阅读原作者的文章。比如说我这种强迫症。 我对删除原链的转载文章态度然后说一下我对于那些抄袭的，然后删除了原链接的人鄙视一下。每一篇文章都是别人花费了大量的精力去完成的，有的为了让读者能够更清楚的理解，所以会在发布的时候找别人去读一读，看能不能理解其中云云。然而对文章的原链接保存是一种对别人劳动成果的尊重，对原作者最基本的尊重。 别的不想多说了。转载请注明出处。谢谢！且行且珍惜。]]></content>
      <categories>
        <category>牢骚</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[准备食用RAC(ReactiveCocoa)的顾虑]]></title>
    <url>%2Fpost%2Freactivecocoa-ready-to-use%2F</url>
    <content type="text"><![CDATA[对于目前的项目，如果引用RAC，会对项目造成哪些影响的相关思考。 说明众所周知，RAC很火，有很多崇拜者。本文只是一个新手第一次使用RAC时候所顾忌的一些问题，如果有比较好的解决方案及时告知我，我会及时更改。 OC简单食用方法先来个例子代码： 123456789101112131415161718RACSignal *RSignal = [[self.R rac_newValueChannelWithNilValue:@0] startWith:@(self.R.value)];RACSignal *GSignal = [[self.G rac_newValueChannelWithNilValue:@0] startWith:@(self.G.value)];RACSignal *BSignal = [[self.B rac_newValueChannelWithNilValue:@0] startWith:@(self.B.value)];NSString*(^valueFormat)(NSNumber *value) = ^(NSNumber *value) &#123; return [NSString stringWithFormat:@"%.0f", [value doubleValue]*255];&#125;;[RSignal subscribeNext:^(id x) &#123; self.RVaule.text = valueFormat(x);&#125;];[GSignal subscribeNext:^(id x) &#123; self.GValue.text = valueFormat(x);&#125;];[BSignal subscribeNext:^(id x) &#123; self.BValue.text = valueFormat(x);&#125;]; 是不是超级简单！ 顾虑可是我有一个问题： OC属于运行时语法，这个里面的id x的不确定因素可能会导致类型识别出现错误。如果说项目是多人维护，那么A可能不知道B写的Signal走的类型是什么，所以这个问题就不适用于松散的多人开发。如果需要使用RAC恐怕需要在项目启动时进行规避这些不确定的问题才能引入。 Swift简单食用方法在ReactiveCocoa的README.md中有这么一段话： Objective-C and Swift Although ReactiveCocoa was started as an Objective-C framework, as of [version 3.0][CHANGELOG], all major feature development is concentrated on the [Swift API][]. RAC’s [Objective-C API][] and Swift API are entirely separate, but there is a [bridge][Objective-C Bridging] to convert between the two. This is mostly meant as a compatibility layer for older ReactiveCocoa projects, or to use Cocoa extensions which haven’t been added to the Swift API yet. The Objective-C API will continue to exist and be supported for the foreseeable future, but it won’t receive many improvements. For more information about using this API, please consult our [legacy documentation][]. We highly recommend that all new projects use the Swift API.]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>ReactiveCocoa</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo的博客让百度收录]]></title>
    <url>%2Fpost%2Fuse-hexo-setup-blog%2F</url>
    <content type="text"><![CDATA[这个github.io搭建的过程参考，以及向百度推送的python、js脚本。 参考博客感谢 岁月如歌 的这个《Hexo 3.1.1 静态博客搭建指南》同时感谢这个《向百度推送hexo博客所有链接的Python脚本》(别问我为啥点不开，这个要问博主，不过要看这个文章也不是没办法的😂，因为这个博客也用git管理的。。。你懂) 另外还有一个soul的百度主动推送hexo生成的文章 python自动推送脚本修改上面说的博主大约用的是windows，所以脚本并不能立马的运行在Mac上，需要做些修改：故修改为： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#!/usr/bin/env python# -*- coding: utf-8 -*-# @Author: LoveNight# @Date: 2015-11-16 20:45:59# @Last Modified by: LoveNight# @Last Modified time: 2015-11-18 18:07:19# @Last Modified by: Keith# @Last Modified time: 2016-07-06 16:22:45import osimport sysimport jsonfrom bs4 import BeautifulSoup as BSimport requests#import msvcrt"""hexo 博客专用，向百度站长平台提交所有网址本脚本必须放在hexo博客的根目录下执行！需要已安装生成百度站点地图的插件。百度站长平台提交链接：http://zhanzhang.baidu.com/linksubmit/index主动推送：最为快速的提交方式，推荐您将站点当天新产出链接立即通过此方式推送给百度，以保证新链接可以及时被百度收录。从中找到自己的接口调用地址python环境：pip install beautifulsoup4pip install requestsxcode-select --install pip install lxml """# ❌❌❌ 抄的需要更改这个URL！！这是我的！！❌❌❌url = 'http://data.zz.baidu.com/urls?site=https://madordie.github.io&amp;token=j33t0VEPFl24tJ8N'baidu_sitemap = os.path.join(sys.path[0], 'public', 'baidusitemap.xml')google_sitemap = os.path.join(sys.path[0], 'public', 'sitemap.xml')sitemap = [baidu_sitemap, google_sitemap]assert (os.path.exists(baidu_sitemap) or os.path.exists( google_sitemap)), "没找到任何网站地图，请检查！"# 从站点地图中读取网址列表def getUrls(): urls = [] for _ in sitemap: if os.path.exists(_): with open(_, "r") as f: xml = f.read() soup = BS(xml, "xml") tags = soup.find_all("loc") urls += [x.string for x in tags] if _ == baidu_sitemap: tags = soup.find_all("breadCrumb", url=True) urls += [x["url"] for x in tags] return urls# POST提交网址列表def postUrls(urls): urls = set(urls) # 先去重 print("一共提取出 %s 个网址" % len(urls)) print(urls) data = "\n".join(urls) return requests.post(url, data=data).textif __name__ == '__main__': urls = getUrls() result = postUrls(urls) print("提交结果：") print(result)# msvcrt.getch() js脚本这个脚本是我在soul的百度主动推送hexo生成的文章发现的，感觉也很赞。 github 脚本地址 推送 今天发现百度没收录我的站..主要是我的站点换来换去的..估计被ban了..然后想用sitemap来推送一下..结果发现github禁用了百度爬虫..没办法只能主动推送了. 利用插件 这里利用到了一款插件 hexo-generator-baidu-sitemap 设置很简单 只需要在.config.yml添加一些数据即可, 下面附上我的添加数据 theme这个可以随意更改 下面的copy即可 123456# Extensions## Plugins: http://hexo.io/plugins/## Themes: http://hexo.io/themes/theme: yiliabaidusitemap:path: baidusitemap.xml 运行 然后hexo g 生成一下数据 会在public下面发现一个文件名为baidusitemap.xml 脚本 这里用nodejs写了一款脚本 大概流程是 获取baidusitemap.xml里面的内容 然后读取本地的一个site_file.json这个文件 这个文件存储的是上一次数据 与上一次数据进行对比 如果对比发现新数据那么就上传新数据 否则全部上传. 运行脚本 把ActivePush.js脚本放在hexo文件夹主目录 然后用nodejs ActivePush.js一下即可 这里还支持一个参数nodejs ActivePush.js all 则是不对比直接上传数据]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>SEO</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[博客迁移公告]]></title>
    <url>%2Fpost%2Fabout-change-blog%2F</url>
    <content type="text"><![CDATA[你敢信！我又搬家了。。 之前在博客园后来又去了蚂蚁笔记，最后吧，我就到了这里。 说下大体感受： 博客园挺好的，不过不喜欢其编码方式，真的不喜欢。博客园的主题什么的都是可以定制，但是总归是写起来比较费劲的。 蚂蚁笔记不错，我开始时候logo还不是这个原来logo是😂,不过现在已经很厉害了，开始了各种业务。期待会走得更好更远。 蚂蚁笔记已不支持免费用户部署博客，这里是价格方案。 我是看了巧哥的这个博文才开始准备转到Github的。。赶脚markdown很好玩，虽然出来很早了，但是并没有仔细的去学习这个语法，于是乎这个博客就用hexo进行搭建。 虽然我还不知道怎么让百度收录我的Github，但是主要的是能尝试着自己想试试确没有尝试的事情！]]></content>
      <categories>
        <category>公告</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[个人资料页]]></title>
    <url>%2Fpost%2Fabout-me%2F</url>
    <content type="text"><![CDATA[基本资料孙继刚QQ: 453870736博客：https://madordie.github.ioGitHub：https://github.com/madordieE-mail: e.madordie@gmail.com 教育背景2011.09-2015.06 南阳理工学院 软件工程(移动设备应用开发方向) 本科 简介：移动设备应用开发主要面向移动设备所培养的软件工程师。主要分为嵌入式、安卓、iOS三个分支。其中嵌入式系统为主要发展方向，为快速适应市场的需求，同时开设安卓、iOS基础课程。所学课程涵盖软件工程、嵌入式系统等方面。 专业技能 擅长C、Objective-C、Swift开发，有较为扎实的iOS环境开发经验。 熟悉shell、ruby、python、等语言。 有良好的编程习惯，较强的分析问题、解决问题的能力，并能积极总结所遇到的问题及解决方案。 对项目整体架构有一定的认识和把控，能够搭建较为适合当前项目发展的架构。 能够搭建gitlab、Jenkins服务器，并熟练使用Jenkins进行打包、自定义操作、更新iconfont等操作。 善于制作工具组件提高开发效率，比如：Jenkins打不同环境包、统一更新iconfont、制作sketch自定义填充插件等。 熟练使用AutoLayout进行代码、IB适配，以及frame的适配。 熟练使用Cocoapods进行项目拆分、并能够编写部分ruby脚本进行一些自定义操作。 熟练使用MVVM、MVC、等模式。 能够使用RxSwift进行响应式编程。 熟练掌握GCD、NSThread等多线程编程技术。 熟练掌握SwiftLint的配置以及规则定制。 熟悉iOS核心动画、CALayer的开发。 对cocos2d游戏开发有一定的了解。 工作经验房多多2015.05-至今 深圳房好多网络科技有限公司（上海分公司）新房、二手房交易服务平台。工作职责：（团队项目） 主要业务模块的开发(比如：大首页、筛选、IM基础框架、等)。 创建sketch自动填充文本、图片素材插件生成工具。 创建iconfont自动更新组件。 开辟CocoaPods的组件化道路。 创建Jenkins的自动化。 顽固crash的研究修复。 开发语言：C、OC、Swift 肌肤管家2014.10-2015.05 上海商路网络科技有限公司使用自主研发的肌肤测试仪进行水、油、脂肪的参数的测量、分享、交流社区类APP。工作职责：(个人项目) 项目2.x的所有版本迭代，包括社区、IM、活动等。 一代硬件肌肤测试仪功能开发。 主要采用IB+autolayout进行页面适配布局。开发语言：OC、C eTalk2014.04-2014.06大学毕设。局域网的自定义协议聊天工具。自己搭建C的服务+iOS的客户端。工作职责：(个人项目) 基于TCP进行多iOS端链接C的服务端。 采用自定义协议进行通信。 完成联系人的增、删、查、改功能；用户的自定义表情、头像、单点／多点登录等功能开发语言：OC、C、shell 个人特质热衷于技术。一个典型处女座强迫症重度患者, 并伴有代码洁癖。]]></content>
  </entry>
  <entry>
    <title><![CDATA[如何正确的连续推新页面]]></title>
    <url>%2Fpost%2Fpush-queue-for-navigation%2F</url>
    <content type="text"><![CDATA[题记当使用某个页面还没有进行viewDidAppear:的时候再进行一次推页面是不安全的。苹果在iPhone5C iOS7.1.2中Push时给出的警告： “nested push animation can result in corrupted navigation bar. Finishing up a navigation transition in an unexpected state. Navigation Bar subview tree might get corrupted.” 这说明这个不安全的操作可能会导致应用Crash，Crash统计系统统计的原因为： “Can’t add self as subview”。 本文尝试解决该Crash，实现嵌套安全的去推页面。 问题所在苹果给出的警告中指出嵌套推页面可能导致导航栏损坏，其导航栏子视图树可能损坏。也就是说当我对VC1进行Push出VC2时候要注意，必须要等到VC1显示周期完全结束，才能进行PushVC2操作。 此问题的发生并不是简单的一个代码块中使用同一个导航控制器进行连续Push操作。回想一下ViewController的生命周期。其实标志着ViewController完全显示的是viewDidAppear:调用，那么在此方法生命周期之前的方法中进行Push均有可能造成“nested push animation can result in corrupted navigation bar”。 由于iOS7.1.2的iPhone5C被升级，无法必现此BUG，所以没有截图。可以自己找个测一下。。 解决方案方案一：通过延时避开此时间段。在很多源码中会看到这样一行代码： 1234// 0.1是我随手写的。。是一个根据自己情况估算上一个PUSH的耗时，dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(0.1 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123; [self.navigationController pushViewController:vc animated:YES];&#125;); 如上代码，在GitHub中很常见，起初并不懂其用意，当遇到这个问题时候我才明白。 还有一种代码： 123456// objccn.iodispatch_async(dispatch_get_main_queue(), ^&#123; // Some UIKit call that had timing issues but works fine // in the next runloop. [self updatePopoverSize];&#125;); 这种代码是切换到下个代码周期，来避开嵌套的时序问题。objc.io有这么个文章说了这个问题的弊端： 用 dispatch_async 修复时序问题 在使用 UIKit 的时候遇到了一些时序上的麻烦？很多时候，这样进行“修正”看来非常完美： 12345dispatch_async(dispatch_get_main_queue(), ^&#123; // Some UIKit call that had timing issues but works fine // in the next runloop. [self updatePopoverSize];&#125;); 千万别这么做！相信我，这种做法将会在之后你的 app 规模大一些的时候让你找不着北。这种代码非常难以调试，并且你很快就会陷入用更多的 dispatch 来修复所谓的莫名其妙的”时序问题”。审视你的代码，并且找到合适的地方来进行调用（比如在 viewWillAppear 里调用，而不是 viewDidLoad 之类的）才是解决这个问题的正确做法。我在自己的代码中也还留有一些这样的 hack，但是我为它们基本都做了正确的文档工作，并且对应的 issue 也被一一记录过。 记住这不是真正的 GCD 特性，而只是一个在 GCD 下很容易实现的常见反面模式。事实上你可以使用 performSelector:afterDelay: 方法来实现同样的操作，其中 delay 是在对应时间后的 runloop。 其实这样设计很简单，目的就是通过GCD的延迟提交来“巧妙”的避开Push的时间，很显然这个时间对于机型、系统版本、当前手机状况来说很难把握。但是不得不说的是确实有些作用，那就是能避开部分问题。所以本来小概率发生的事情，这个再过滤一些，这个BUG就微乎其微了。 方案二：强制在viewDidAppear:之后进行Push。不得不说这样的做法我曾经用过一个页面，不多说，麻烦程度自己测一下。 如果说多人合作项目呢，如果说页面比较多、工作比较忙呢？呵呵哒 方案三：对UINavigationController所Push的VC进行队列化。对于VC是否已经Push结束，UINavigationController最清楚，而这一结果刚好通过代理传递出来。所以可以利用这一点对Push的VCs进行队列化，防止其进行嵌套Push。 那么问题就可以得到很好的解决。 对 方案三 的详细封装 对于该问题的最简单的、便于合作、便于更改的就是方案三了，对方案三进行展开可得如下步骤： 设置UINavigationController的代理，并实现willShowViewController、didShowViewController方法。 拦截到UINavigationController的Push方法，通过步骤1的代理判断到是否正在Show,如果不在Show则显示，如果正在Show则把当前的VC入队列。在didShowViewController中判断队列中是否有数据，如果有则说明发生了重叠，该队列中第一个进行Push。为了更好的兼容所遇到的Push情况，使用0.5秒作为兜底，对队列进行放开。结束，就是这样子。 说下我实现的方法，其实重点在于如何拦截Push操作。 我最开始采用了继承UINavigationController的方法，因为继承但一，不会干扰其他的类。值得一赞。 对于要解决其问题，所有的都需要进行继承，过于麻烦，于是增加了第二种方案：HOOK。 两种方案为了达到统一的效果，所以拉出其中的代理，就完成了统一。 代码＋Demo]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>debug</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「转」一个NB的补救项目国际化的方案]]></title>
    <url>%2Fpost%2Fyi-ge-nb-de-bu-jiu-xiang-mu-guo-ji-hua-de-fang-an%2F</url>
    <content type="text"><![CDATA[写在前面 iOS 多语言版本的开发（二） 中我们实现了如何让用户自己去切换系统语言的功能，我们还写了Demo 以供辅助学习；但是，继以上两篇文章都是建立在项目刚刚启动或启动不久，项目中存在的中文字符串还不是很多，手动改起来也还可以接受; 那么问题来了，如果项目已经竣工或者已经迭代几个版本了，那该如何实现了？手动改起来也不太现实，耗时耗力不讨好的手动，在这里就不用考虑了。 不让考虑，是因为我有更简单快捷高效的方法，让我慢慢与您道来； 如何辨别项目中的中文字符串? 既然要替换项目中使用到的中文字符串，那么前提就必须要先找到这些个字符串，然后将这些字符串，替换成我们定义的宏， 为了替换方便，可将这些字符串自身作为key， 这里不理解的不要紧，下面我还会讲到。 既然是辨别中文字符串，那也就是说在项目文件中进行匹配查找，说到匹配，那就需要正则表达式了，用正则表达式匹配Xcode中的使用的中文字符串，使用(@&quot;[^&quot;]*[\u4E00-\u9FA5]+[^&quot;\n]*?&quot;)\s* 即可， 打开你的Xcode 试试看，切记find 后面的选项要选择 Regular Expression, 默认选中的是Text, 如图 如何取出识别到的中文字符串？ 我们已经知道如何识别项目中的字符串了，但是如何取出来使用呢？ 这就需要遍历项目中所有的指定后缀（e.g: .h、.m等）的文件，然后利用正则表达匹配所有使用到的中文字符串，并写入文件中。为了方便起见，我将此过程写了一个Mac客户端小应用，可直接将选中的项目中所有的中文字符串，导出到指定的路径下；该应用还可以选择对于重复出现的中文字符串进行处理，以及还可以将中文字符串导出为繁体； 小应用更值得关注的是它导出的文件，可以直接拿来当做多语言文件中的key=value 使用，非常简单，喜欢的可以去下载看看， 含有源码的哦；小应用运行图如下： 如何使用取出的中文字符串？ 已经拿到取出的中文字符串文件，这个文件是可以直接拿来用做多语言文件使用的，小应用导出的文件，只可以用于中文以及繁体多语言文件，而对于其他的语言，就需要你拿着导出的文件，找你们公司的翻译人员，进行翻译； 拿繁体版来举个例子，导出来的繁体文件如下（收留我App导出的文件）： 这个繁体文件，可以直接作为繁体多语言使用，如何想要翻译成英文，可以将此文件拷贝一份，交给翻译人员，让其翻译。翻译的时候，你一定要给翻译人员沟通好，让其只翻译value, 也就是图中= 后面双引号中的内容，格式什么的也不要让他乱改，否则容易出现问题，导致key与value对不上号。 一切沟通妥当后，等翻译把文件给你后，直接将文件中的内容，复制到多语言文件的英语文件中即可； 如何将项目中的中文字符串进行替换 多语言文件已经配置完成，到了这里，那么问题来了，我们只是取出项目中使用的中文字符串，然后将字符串封装成多语言文件，但是对于项目中使用的中文字符串依然还是中文字符串，我们还并没有进行替换处理。当然，这一步我们是不能够忘了，由于是替换项目中所有的使用中文字符串，我们还是谨慎为好，首先将你的项目进行备份、备份、备份，非常重要的事情说三篇，切记一定要备份。备份好后，我们就可以开始替换工作了，没有备份的不要往下看了，赶紧备份去； 假设你已经备份好了，你就可以开始替换工作了，前面我们说过让中文字符串自身作为key 进行替换，之所以让其自身作为key, 是因为这样可以大大减轻替换的困难度，而且还有利于代码的可读性，基本上算是保持原有代码；既然要替换项目中的使用中文字符串，就要用到Xcode 自带的字符串替换功能，首先还需要使用正则表达式(@&quot;[^&quot;]*[\u4E00-\u9FA5]+[^&quot;\n]*?&quot;)\s*，匹配出项目中使用的中文字符串，然后在对其进行替换处理。 由于我们在iOS 多语言版本的开发（二）中，对取key对应的语言内容，进行了宏的封装, 这里我们可以将匹配到的使用中文字符直接替换成我们定义的宏的使用 1#define ASLocalizedString(key) [NSString stringWithFormat:@&quot;%@&quot;, [[NSBundle bundleWithPath:[[NSBundle mainBundle] pathForResource:[NSString stringWithFormat:@&quot;%@&quot;,[[NSUserDefaults standardUserDefaults] objectForKey:@&quot;appLanguage&quot;]] ofType:@&quot;lproj&quot;]] localizedStringForKey:(key) value:nil table:@&quot;ASLocalized&quot;]] 以上是宏的定义，我们需要将字符串进行替换成宏的使用，如： 替换前是这样的_lbl.text = @&quot;我是多语言&quot;; 替换后_lbl.text = ASLocalizedString(@&quot;我是多语言&quot;) 替换规则如图： 这次选中的是Replace, 不是Find。按图中所示，选择完毕后，点击ReplaceAll, 会出来一个弹框，不用管它直接继续，即可，然后你在看项目中使用到的中文字符串是否已经替换掉了，到这里基本上大功告成了； 遗留问题1、正则表达式，不懂得可以先照文章里写就行，然后再去学习下，这里有篇基础文章2、ASLocalizedString(key) ， 该宏使用面积广，可以将其定义成公共头文件中，然后用时引用头文件即可，也可将文件封装进pch文件中，这样无需使用头文件接口使用3、替换后，可能会有些地方报错，command + b 编译下，看看报错的地方，进行相应修改即可。报错原因：a. 可能是你定义的常量字符串； b. 可能是定义的宏； c. 可能是替换后没有换行； 基本上报的错误很明显，进行修改即可；4、在迭代版本中，再次使用中文字符串，就需要使用ASLocalizedString(key)， 来代替了，然后再多语言文件中，进行key=value 配置； 相关文章 iOS 多语言版本的开发（一） iOS 多语言版本的开发（二） 文章转自 iOS 多语言版本的开发（三）]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>国际化</tag>
      </tags>
  </entry>
</search>
